def post(self):
    from PIL import Image, ImageDraw, ImageFont
    import time
    import json
    import base64
    import StringIO
    import cloudstorage as gcs
    from io import BytesIO
    from google.appengine.api import app_identity
    from google.appengine.api import search
    from datetime import date
    from datetime import datetime
    from datetime import timedelta

    self.session = get_current_session()

    if self.session.is_active():
        try:
            fn = self.request.get("fn")
            user_identifier = self.session["user_identifier"]
            agent = self.request.headers['User-Agent']
            request = self.request.__dict__

            if user_identifier in ["38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c", "dc631c23b596486b297ec52bce4b285efae9b823cd34dc73e475468626f00f41b12242a10b5c06817144b4e7fd9617de6a36c803923ed961bcbbed651a09e036", "818d28feb58223c7ebc1aabb52f7692dee22bbf74c2e55e077d64baf96c4eba377e26582424a8429de315334649b6187bf35bb9767db3c4d5249030ef070fa5b"]:
                Helpers.server_log(fn, user_identifier, agent, request)
        except:
            self.session = self.session


    if self.request.get("fn") == "admin":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["entries"] = []
        query = FieldApplicationEntry.query(FieldApplicationEntry.processed == 0).order(-FieldApplicationEntry.insert_time).fetch(8, offset=int(self.request.get("offset")))
        for item in query:
            if item.archived:
                continue

            entry = {}

            entry["identifier"] = item.identifier
            entry["customer_first_name"] = item.customer_first_name
            entry["customer_last_name"] = item.customer_last_name
            entry["rep_email"] = item.rep_email
            entry["rep_phone"] = item.rep_phone
            entry["customer_kwh_price"] = item.customer_kwh_price
            entry["insert_time"] = item.insert_time
            entry["processed"] = item.processed
            entry["image_extension"] = item.image_extension

            ret_json["entries"].append(entry)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "enumerate_readers_for_user":
        self.response.content_type = "application/json"
        reader_data = []
        readers = SolarReader.query(SolarReader.rep_ownership == self.request.get("identifier"))
        for reader in readers:
            reader_data.append(reader.hash.upper())
            
        ret_json = {"readers": reader_data}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_bank":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == self.request.get("identifier") + "_bank")
        if kv is None:
            kv = KeyValueStoreItem()
            kv.keyy = self.request.get("identifier") + "_bank"
            kv.expiration = datetime(1970, 1, 1)
            kv.identifier = Helpers.guid()

        data = {"account": self.request.get("account"), "routing": self.request.get("routing"), "bank_name": self.request.get("bank_name")}
        kv.val = json.dumps(data)
        kv.put()

    elif self.request.get("fn") == "cs_plan_lookup":
        ret = {"price": None}
        self.response.content_type = "application/json"

        f = GCSLockedFile("/CustomerService/bulk.json")
        content = f.read()
        if content is None:
            content = "[]"
        f.unlock()
        data = json.loads(content)
        for item in data:
            if item["field_app_identifier"] == self.request.get("identifier"):
                ret["price"] = int(item["price"])

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "cs_plan_set":
        f = GCSLockedFile("/CustomerService/bulk.json")
        content = f.read()
        if content is None:
            content = "[]"

        f.unlock()
        found_customer = False
        data = json.loads(content)
        for item in data:
            if item["field_app_identifier"] == self.request.get("identifier"):
                item["price"] = int(self.request.get("price"))
                found_customer = True

        if not found_customer:
            data.append({"field_app_identifier": self.request.get("identifier"), "price": int(self.request.get("price"))})

        f.write(json.dumps(data), "application/json", "public-read")
        f.unlock()


    elif self.request.get("fn") == "view_outstanding_balances":
        self.response.content_type = "application/json"
        ret_json = []
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        rep_ids_to_query = ["-1"]
        rep_identifier_name_dict = {}
        for user in users:
            rep_ids_to_query.append(user.identifier)
            rep_identifier_name_dict[user.identifier] = user.first_name.strip().title() + " " + user.last_name.strip().title()

        debts = UserDebt.query(UserDebt.total > float(0))
        for debt in debts:
            if debt.field_app_identifier in rep_ids_to_query:
                obj = {"identifier": debt.identifier, "rep_identifier": debt.field_app_identifier, "total": debt.total, "name": rep_identifier_name_dict[debt.field_app_identifier]}
                ret_json.append(obj)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "carillo_debugging":
        notes = CustomerNote.query(CustomerNote.field_app_identifier == "65dcc60e016e986f9ffba1435749af7ac5b2f304e6789b5ca4f6d24df3e4dd63c8408c1b761d82ea201fb360ca41d1e2c4b886199ca08f0b77b064a3a8de5fa6")
        for note in notes:
            content = json.loads(note.content)
            text = content["txt"][0]
            for t in text:
                try:
                    self.response.out.write(str(t))
                except:
                    self.response.out.write("|||" + note.identifier + "|||")

    elif self.request.get("fn") == "accounts_receivable_customers":
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.save_me == False
            )
        )
        app_ids_to_query = ["-1"]
        signing_kvs_to_query = ["-1110011"]
        app_identifier_name_dict = {}

        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
            signing_kvs_to_query.append("customer_signature_" + app_entry.identifier)
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        app_identifier_signed_dict = {}
        kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(signing_kvs_to_query))
        for kv in kvs:
            app_identifier = kv.keyy.replace("customer_signature_", "")
            app_identifier_signed_dict[app_identifier] = str(kv.modified.date())

        keepers = []
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            keep = True
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "final_payment_received" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["final_payment_received"].keys():
                        if info["project_management_checkoffs"]["final_payment_received"]["checked"]:
                            if "install_payment_received" in info["project_management_checkoffs"].keys():
                                if "checked" in info["project_management_checkoffs"]["install_payment_received"].keys():
                                    if info["project_management_checkoffs"]["install_payment_received"]["checked"]:
                                        if "first_payment_received" in info["project_management_checkoffs"].keys():
                                            if "checked" in info["project_management_checkoffs"]["first_payment_received"].keys():
                                                if info["project_management_checkoffs"]["first_payment_received"]["checked"]:
                                                    keep = False

            if keep:
                obj = {"identifier": pp_sub.field_application_identifier, "name": app_identifier_name_dict[pp_sub.field_application_identifier], "signed": app_identifier_signed_dict[pp_sub.field_application_identifier]}
                keepers.append(obj)

        keepers = Helpers.bubble_sort(keepers, "signed")
        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(keepers))

    elif self.request.get("fn") == "update_amount_collected_for_customer":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["amount_collected"] = self.request.get("amount")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "accounts_receivable_details":
        ret_json = {}
        self.response.content_type = "application/json"
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
            if not pp_sub is None:
                info = json.loads(pp_sub.extra_info)
                ret_json["install_date"] = "1970-01-01"
                if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "date" in info["project_management_checkoffs"]["install"].keys():
                            ret_json["install_date"] = info["project_management_checkoffs"]["install"]["date"]

                ret_json["pm"] = "Unassigned"
                if "project_manager" in info.keys():
                    pm = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                    if not pm is None:
                        ret_json["pm"] = pm.first_name.strip().title() + " " + pm.last_name.strip().title()

                

                ret_json["solar_pro"] = "n/a"
                if not app_entry.lead_generator == "-1":
                    solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not solar_pro is None:
                        ret_json["solar_pro"] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

                ret_json["sales_rep"] = "Error"
                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not rep is None:
                    ret_json["sales_rep"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

                ret_json["address"] = app_entry.customer_address
                ret_json["city"] = app_entry.customer_city
                ret_json["state"] = app_entry.customer_state
                ret_json["postal"] = app_entry.customer_postal

                ret_json["amount_collected"] = float(0)
                if "amount_collected" in info.keys():
                    ret_json["amount_collected"] = float(info["amount_collected"].replace("$", "").replace(",", ""))

                funds = Helpers.list_funds()
                pricing_structures = Helpers.get_pricing_structures()
                ret_json["fund"] = "Unknown"
                ret_json["dealer_fee_percentage"] = "0%"
                ret_json["system_size"] = float(0)
                booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
                if not booking is None:
                    for fund in funds:
                        if fund["value"] == booking.fund:
                            ret_json["fund"] = fund["value_friendly"]
                            val = str(fund["dealer_fee_percentage"])
                            if not "%" in val:
                                val = val + "%"
                            ret_json["dealer_fee_percentage"] = val

                ret_json["total_system_cost"] = float(0)
                office_location = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                if not office_location is None:
                    market_key = office_location.parent_identifier
                    proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                    if not proposal is None:
                        proposal.fix_additional_amount()
                        proposal.fix_system_size()
                        prop_info = json.loads(proposal.info)                        
                        ret_json["total_system_cost"] = round(float(Helpers.crunch("fx_Total_System_Cost", market_key, app_entry, booking, prop_info, pricing_structures, funds)), 2)
                        ret_json["system_size"] = float(prop_info["system_size"])

                ret_json["dealer_fee"] = ret_json["total_system_cost"] * float(float(ret_json["dealer_fee_percentage"].replace("%", "")) * 0.01)
                ret_json["dealer_fee"] = round(ret_json["dealer_fee"], 2)

        ret_json["notes"] = []

        notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "accounts_receivable"
            )
        )

        notes_cpy = []
        for note in notes:
            notes_cpy.append(note)

        notes_cpy = Helpers.bubble_sort(notes_cpy, "inserted_pacific")

        for note in notes_cpy:
            ret_json["notes"].append({"identifier": note.identifier, "content": json.loads(note.content)["txt"][0]})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "accounts_receivable_stats":
        ret_json = {}
        self.response.content_type = "application/json"

        funds = Helpers.list_funds()
        pricing_structures = Helpers.get_pricing_structures()

        identifiers = json.loads(self.request.get("identifiers"))
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(identifiers))
        app_identifier_app_entry_dict = {}
        app_identifier_office_identifier_dict = {}
        office_ids_to_query = ["-1"]
        for app_entry in app_entries:
            app_identifier_app_entry_dict[app_entry.identifier] = app_entry
            app_identifier_office_identifier_dict[app_entry.identifier] = app_entry.office_identifier
            if not app_entry.office_identifier in office_ids_to_query:
                office_ids_to_query.append(app_entry.office_identifier)

        offices = OfficeLocation.query(OfficeLocation.identifier.IN(office_ids_to_query))
        office_identifier_market_identifier_dict = {}
        for office in offices:
            office_identifier_market_identifier_dict[office.identifier] = office.parent_identifier

        app_identifier_booking_dict = {}
        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(identifiers))
        for booking in bookings:
            app_identifier_booking_dict[booking.field_app_identifier] = booking

        app_identifier_proposal_dict = {}
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(identifiers))
        for proposal in proposals:
            proposal.fix_additional_amount()
            proposal.fix_system_size()

            app_identifier_proposal_dict[proposal.field_app_identifier] = json.loads(proposal.info)

        app_identifier_amount_collected_dict = {}
        app_identifier_install_date_dict = {}
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(identifiers))
        for pp_sub in pp_subs:
            amount_collected = float(0)
            info = json.loads(pp_sub.extra_info)
            if "amount_collected" in info.keys():
                amount_collected = str(info["amount_collected"]).replace("$", "").replace(",", "")
                amount_collected = float(amount_collected)
            app_identifier_amount_collected_dict[pp_sub.field_application_identifier] = amount_collected

            install_dt_str = "2200-01-01"
            if "project_management_checkoffs" in info.keys():
                if "install" in info["project_management_checkoffs"].keys():
                    if "date" in info["project_management_checkoffs"]["install"].keys():
                        install_dt_str = info["project_management_checkoffs"]["install"]["date"]
                        if "1800" in install_dt_str:
                            install_dt_str = "2200-01-01"

            dt_vals = install_dt_str.split("-")
            dt = date(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
            app_identifier_install_date_dict[pp_sub.field_application_identifier] = dt

        app_identifier_total_system_cost_dict = {}
        for app_identifier in app_identifier_app_entry_dict.keys():
            office_identifier = app_identifier_office_identifier_dict[app_identifier]
            market_key = office_identifier_market_identifier_dict[office_identifier]

            ae = app_identifier_app_entry_dict[app_identifier]
            bk = app_identifier_booking_dict[app_identifier]
            pr = app_identifier_proposal_dict[app_identifier]

            sys_cost = round(float(Helpers.crunch("fx_Total_System_Cost", market_key, ae, bk, pr, pricing_structures, funds)), 2)

            app_identifier_total_system_cost_dict[app_identifier] = sys_cost


        total_remaining_to_collect = float(0)
        for app_identifier in app_identifier_total_system_cost_dict.keys():
            total_remaining_to_collect += app_identifier_total_system_cost_dict[app_identifier]

        for app_identifier in app_identifier_amount_collected_dict.keys():
            total_remaining_to_collect -= app_identifier_amount_collected_dict[app_identifier]

        ret_json["Total AR"] = round(total_remaining_to_collect, 2)

        today = Helpers.pacific_today()

        ret_json["Accounts Past Install"] = 0
        for app_identifier in app_identifier_install_date_dict.keys():
            ret_json["Accounts Past Install"] += int(app_identifier_install_date_dict[app_identifier] < today)

        available_to_collect = float(0)
        for app_identifier in app_identifier_total_system_cost_dict.keys():
            install_date = app_identifier_install_date_dict[app_identifier]
            cont = install_date < today

            if cont:
                available_to_collect += app_identifier_total_system_cost_dict[app_identifier]

        for app_identifier in app_identifier_amount_collected_dict.keys():
            install_date = app_identifier_install_date_dict[app_identifier]
            cont = install_date < today

            if cont:
                available_to_collect -= app_identifier_amount_collected_dict[app_identifier]

        available_to_collect = round(available_to_collect, 2)
        ret_json["Available to Collect"] = available_to_collect

        avg_per_past = float(0)
        if ret_json["Accounts Past Install"] > 0:
            avg_per_past = ret_json["Available to Collect"] / float(ret_json["Accounts Past Install"])
            avg_per_past = round(avg_per_past, 2)

        ret_json["Average Per Past Install"] = avg_per_past

        self.response.out.write(json.dumps(ret_json))



    elif self.request.get("fn") == "courtney_fix":
        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.dt >= Helpers.pacific_now() + timedelta(days=-90),
                LeaderBoardStat.metric_key == "leads_acquired"
            )
        )
        app_ids_to_query = ["-1"]
        app_identifier_rep_id_dict = {}
        for stat in stats:
            if stat.rep_id == "DAVI0425" or stat.rep_id == "TONK0928" or stat.rep_id == "WEIS0605":
                app_ids_to_query.append(stat.field_app_identifier)
                app_identifier_rep_id_dict[stat.field_app_identifier] = stat.rep_id

        to_save = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            r_id = app_identifier_rep_id_dict[app_entry.identifier]
            if r_id == "DAVI0425":
                app_entry.lead_generator = "3c69a3c09823b7d63bed5e64d609a25352b934fa8c7afb58e5f6a726d42e6ef807c5df4750554368ed0fc40d12b27422584bbb2d911743a2cce39ce50679e57c"
                app_entry.is_lead = True
            if r_id == "TONK0928":
                app_entry.lead_generator = "78f97ffcffba8be32786e4ccc2970a6278c6b2e14446060ba7ad0d75fd175045760605d098155e73e6c3880d323541a6c3cbb8e0d11d51d45cec90423a0f3fe8"
                app_entry.is_lead = True
            if r_id == "WEIS0605":
                app_entry.lead_generator = "8be10a2d12e838572496a78654dbe573f2cfaf1e46d8c7bcd53f520a8c17f9497cf3ab1694d2352b1af12c77594252f54033c844874e2cd5e8d49251b578170c"
                app_entry.is_lead = True

            to_save.append(app_entry)

        ndb.put_multi(to_save)

    elif self.request.get("fn") == "get_my_abs":
        self.response.content_type = "application/json"
        ret_json = {"abs": []}
        min_insert_time = tyme = int(time.time() * 1000) - (1000 * 60 * 60 * 24 * 30)
        app_identifier_name_dict = {}
        app_identifier_address_dict = {}
        app_identifier_phone_dict = {}
        app_identifier_rep_id_dict = {}
        app_identifier_sp2_dict = {}
        app_ids_to_query = ["-1"]
        rep_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.insert_time >= min_insert_time)
        for app_entry in app_entries:
            if app_entry.lead_generator == self.request.get("identifier") and app_entry.processed and (not app_entry.archived) and (not app_entry.save_me):
                app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                app_identifier_address_dict[app_entry.identifier] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
                app_identifier_phone_dict[app_entry.identifier] = Helpers.format_phone_number(app_entry.customer_phone)
                app_identifier_rep_id_dict[app_entry.identifier] = app_entry.rep_id
                app_identifier_sp2_dict[app_entry.identifier] = app_entry.sp_two_time
                app_ids_to_query.append(app_entry.identifier)
                if not app_entry.rep_id in rep_ids_to_query:
                    rep_ids_to_query.append(app_entry.rep_id)

        rep_id_rep_identifier_dict = {}
        rep_id_rep_name_dict = {}
        rep_id_phone_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            rep_id_rep_identifier_dict[rep.rep_id] = rep.identifier
            rep_id_rep_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_id_phone_dict[rep.rep_id] = Helpers.format_phone_number(rep.rep_phone)

        app_identifier_status_dict = {}
        leads = Lead.query(Lead.field_app_identifier.IN(app_ids_to_query))
        for lead in leads:
            app_identifier_status_dict[lead.field_app_identifier] = lead.status

        app_identifier_idx_dict = {}
        for item in app_identifier_status_dict.keys():
            obj = {"field_app_identifier": item}
            obj["name"] = app_identifier_name_dict[item]
            obj["address"] = app_identifier_address_dict[item]
            obj["phone"] = app_identifier_phone_dict[item]
            obj["status"] = app_identifier_status_dict[item]
            obj["rep_name"] = rep_id_rep_name_dict[app_identifier_rep_id_dict[item]]
            obj["rep_identifier"] = rep_id_rep_identifier_dict[app_identifier_rep_id_dict[item]]
            obj["rep_phone"] = rep_id_phone_dict[app_identifier_rep_id_dict[item]]
            obj["sp_two"] = app_identifier_sp2_dict[item]
            obj["cd"] = False
            obj["ak"] = False
            obj["notes"] = "No notes were recorded"
            app_identifier_idx_dict[item] = len(ret_json["abs"])
            ret_json["abs"].append(obj)

        if len(app_identifier_status_dict.keys()) > 0:
            stats = LeaderBoardStat.query(LeaderBoardStat.field_app_identifier.IN(app_identifier_status_dict.keys()))
            for stat in stats:
                if stat.metric_key == "appointments_kept":
                    ret_json["abs"][app_identifier_idx_dict[stat.field_app_identifier]]["ak"] = True
                elif stat.metric_key == "packets_submitted":
                    ret_json["abs"][app_identifier_idx_dict[stat.field_app_identifier]]["cd"] = True

            notes = CustomerNote.query(
                ndb.AND(
                    CustomerNote.field_app_identifier.IN(app_identifier_status_dict.keys()),
                    CustomerNote.note_key == "rep_lead_notes"
                )
            )
            for note in notes:
                ret_json["abs"][app_identifier_idx_dict[note.field_app_identifier]]["notes"] = json.loads(note.content)["txt"][0]

        ret_json["abs"] = Helpers.bubble_sort(ret_json["abs"], "sp_two")
        ret_json["abs"].reverse()
        for item in ret_json["abs"]:
            item["sp_two"] = str(item["sp_two"]).split(".")[0]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "carlos_fix":
        debt = UserDebt(
            identifier=Helpers.guid(),
            field_app_identifier="ac1fcc6c860c65e9d61685bfec537de351d944069a4d78e74407b43e38686e3a97dec916c10af15e3370ede2257534d335f8f4d844745001154c0ca919dea30a",
            items="[]",
            modified=datetime(1970, 1, 1),
            total=float(0)
        )
        debt.put()


    elif self.request.get("fn") == "confirm_sp2_lead":
        data = json.loads(self.request.get("data"))
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == data["identifier"])
        if not app_entry is None:
            if not "solar_pro" in data.keys():
                data["solar_pro"] = None
                if not app_entry.lead_generator == "-1":
                    data["solar_pro"] = app_entry.lead_generator
            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
            if not rep is None:
                existing_stat = LeaderBoardStat.first(
                    ndb.AND(
                        LeaderBoardStat.field_app_identifier == data["identifier"],
                        LeaderBoardStat.metric_key == "appointments_kept"
                    )
                )
                if existing_stat is None:
                    rep_stat = LeaderBoardStat(                
                            identifier=Helpers.guid(),
                            rep_id=rep.rep_id,
                            office_identifier=rep.main_office,
                            field_app_identifier=data["identifier"],
                            in_bounds=True,
                            pin_identifier="-1",
                            metric_key="appointments_kept",
                            dt=Helpers.pacific_now()
                    )
                    rep_stat.put()

                if not data["solar_pro"] is None:
                    solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == data["solar_pro"])
                    if not solar_pro is None:
                        if existing_stat is None:
                            sp_stat = LeaderBoardStat(                
                                identifier=Helpers.guid(),
                                rep_id=solar_pro.rep_id,
                                office_identifier=solar_pro.main_office,
                                field_app_identifier=data["identifier"],
                                in_bounds=True,
                                pin_identifier="-1",
                                metric_key="appointments_kept",
                                dt=Helpers.pacific_now()
                            )
                            sp_stat.put()


                            if not self.request.get("care_value") == "1":
                                Helpers.send_sms(solar_pro.rep_phone, "Congrats! " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was an AK.")

                            pending_ak = PendingAK(
                                identifier=Helpers.guid(),
                                dt=Helpers.pacific_now(),
                                field_app_identifier=app_entry.identifier,
                                solar_pro_identifier=solar_pro.identifier,
                                rep_identifier=rep.identifier
                            )
                            pending_ak.put()

                            notification = Notification.first(Notification.action_name == "Solar Pro AK")
                            if not notification is None:
                                for p in notification.notification_list:
                                    msg = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was an AK. Solar Pro => " + solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title() + ", Sales Guy => " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + "."
                                    extra_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ak_extras_" + sp_stat.field_app_identifier)
                                    if not extra_kv is None:
                                        deserialized = json.loads(extra_kv.val)
                                        msg += "\r\n\r\n"
                                        if self.request.get("ran_credit") == "1":
                                            msg += "PLEASE ISSUE PAYMENT, CREDIT was run"
                                            msg += "\r\n\r\n"
                                        msg += "Did you get inside the home, sit down, and present? => " + deserialized["got_inside"]
                                        msg += "\r\n"
                                        msg += "How many decision makers were there with you? => " + deserialized["decision_makers_tally"]
                                        msg += "\r\n"
                                        msg += "Were ALL decision makers present for the appointment? => " + deserialized["all_present"]
                                        msg += "\r\n"
                                        msg += "CARE/Medical? => "
                                        care_value = "No"
                                        if str(self.request.get("care_value")) == "1":
                                            care_value = "Yes"
                                        msg += care_value
                                        msg+= "\r\n"
                                        msg += "Usage Type => " + self.request.get("usage_type")


                                    Helpers.send_email(p.email_address, "New AK", msg)



                kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="sp2_annoy_" + data["identifier"],
                    val="1",
                    expiration=Helpers.pacific_now() + timedelta(days=180)
                )
                kv.put()
                kv5 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="sp2_annoy_" + app_entry.identifier + "_" + str(app_entry.sp_two_time.year) + "-" + str(app_entry.sp_two_time.month) + "-" + str(app_entry.sp_two_time.day) + "-" + str(app_entry.sp_two_time.hour) + "-" + str(app_entry.sp_two_time.minute),
                    val="1",
                    expiration=Helpers.pacific_now() + timedelta(days=90)
                )
                kv5.put()

                if len(self.request.get("note_txt").strip()) > 0:
                    note = CustomerNote.first(
                        ndb.AND(
                            CustomerNote.field_app_identifier == data["identifier"],
                            CustomerNote.note_key == "rep_lead_notes"
                        )
                    )
                    if note is None:
                        content_dict = {}
                        content_dict["txt"] = [self.request.get("note_txt")]            
                        CustomerTranscriber.transcribe_object(data["identifier"],
                                                                self.request.get("identifier"),
                                                                content_dict,
                                                                0,
                                                                "rep_lead_notes")
                    else:
                        content_dict = json.loads(note.content)
                        content_dict["txt"][0] = self.request.get("notes_txt")
                        note.content = json.dumps(content_dict)
                        note.put()


                if str(self.request.get("care_value")) == "1":
                    existing_note = CustomerNote.first(
                        ndb.AND(
                            CustomerNote.field_app_identifier == data["identifier"],
                            CustomerNote.note_key == "welfare"
                        )
                    )
                    if existing_note is None:
                        new_note = CustomerNote(
                            identifier=Helpers.guid(),
                            field_app_identifier=data["identifier"],
                            inserted_pacific=Helpers.pacific_now(),
                            inserted_utc=datetime.now(),
                            author=self.request.get("identifier"),
                            perms="public",
                            content=json.dumps({"txt": ["This customer is on a government-based discount program"]}),
                            blob_count=0,
                            note_key="welfare",
                            read=True
                        )
                        new_note.put()

                if str(self.request.get("usage_type")) in ["estimated", "real"]:
                    usage_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "real_or_estimated_" + data["identifier"])
                    if not usage_kv is None:
                        usage_kv.val = self.request.get("usage_type")
                        usage_kv.put()

                    usage_kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "original_real_or_estimated_" + data["identifier"])
                    if not usage_kv2 is None:
                        usage_kv2.val = self.request.get("usage_type")
                        usage_kv2.put()

    elif self.request.get("fn") == "get_company_holidays":
        self.response.content_type = "application/json"
        ret_json = {"holidays": []}
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "company_holidays")
        if not kv is None:
            ret_json["holidays"] = json.loads(kv.val)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pull_threads_for_postal_campaign":
        self.response.content_type = "application/json"
        ret = []
        messages = PostalCampaignMessageV2.query(PostalCampaignMessageV2.customer_phone == self.request.get("phone"))
        for message in messages:
            obj = {}
            obj["message"] = message.content
            obj["dt"] = str(message.dt).split(".")[0]
            obj["rep_identifier"] = message.rep_identifier
            ret.append(obj)

        messages = Helpers.bubble_sort(ret,"dt")
        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "postal_campaign_send":
        msg = PostalCampaignMessageV2(
            identifier=Helpers.guid(),
            rep_identifier=self.request.get("identifier"),
            customer_phone=self.request.get("phone"),
            dt=Helpers.pacific_now(),
            content=self.request.get("msg")
        )
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            mapping = {"9514046912": "6194898681", "4358687415": "6194898676", "8017030001": "6194899203", "8584147413": "9513385574", "9517290802": "9513374684", "6614925737": "9513385565", "8312750754": "8312735984"}
            msg.put()
            Helpers.send_sms(self.request.get("phone"), self.request.get("msg"), "+1" + mapping[rep.rep_phone])

    elif self.request.get("fn") == "write_company_holidays":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "company_holidays")        
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="company_holidays",
                val="[]",
                expiration=datetime(1970, 1, 1)
            )
        
        holiday_str = json.dumps(json.loads(self.request.get("holidays")))
        kv.val = holiday_str
        kv.put()

    elif self.request.get("fn") == "ak_text_notification_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/ak_text_notification", params={})

    elif self.request.get("fn") == "sp2_annoy":
        from google.appengine.api import app_identity
        ret_json = {"has_item": False, "item": {}}
        if app_identity.get_application_id() in ["npfieldapp", "devnpfieldapp2"]:
            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
            if not rep is None:
                rep_id = rep.rep_id
                start_dt = datetime(2018, 2, 7)
                tyme = int(time.time() * 1000)
                tyme -= (1000 * 60 * 60 * 24 * 14)
                app_entries = FieldApplicationEntry.query(FieldApplicationEntry.sp_two_time >= Helpers.pacific_now() + timedelta(days=-14))

                hrs = 2
                if str(self.request.get("tres")) == "1":
                    hrs = 3

                #forcing to 30 mins
                hrs = 0.5

                hpn = Helpers.pacific_now()
                app_entries_cpy = []
                for app_entry in app_entries:                    
                    if ((app_entry.sp_two_time + timedelta(hours=hrs)) <= hpn) and (app_entry.sp_two_time >= start_dt) and (app_entry.rep_id == rep_id):
                        app_entries_cpy.append(app_entry)

                app_entries = app_entries_cpy

                kvs_to_query = ["-1"]
                for app_entry in app_entries:
                    #kvs_to_query.append("sp2_annoy_" + app_entry.identifier)
                    kvs_to_query.append("sp2_annoy_" + app_entry.identifier + "_" + str(app_entry.sp_two_time.year) + "-" + str(app_entry.sp_two_time.month) + "-" + str(app_entry.sp_two_time.day) + "-" + str(app_entry.sp_two_time.hour) + "-" + str(app_entry.sp_two_time.minute))

                kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kvs_to_query))
                already_found_identifiers = []
                for kv in kvs:
                    if "-" in kv.keyy:
                        identifier = kv.keyy.split("_")[2]
                    else:
                        identifier = kv.keyy.replace("sp2_annoy_", "")
                    if not identifier in already_found_identifiers:
                        already_found_identifiers.append(identifier)

                done = False
                for app_entry in app_entries:
                    if done:
                        break

                    if not app_entry.identifier in already_found_identifiers:
                        done = True
                        ret_json["has_item"] = True
                        solar_pro = None
                        if not app_entry.lead_generator == "-1":
                            solar_pro = app_entry.lead_generator
                        ret_json["item"] = {"identifier": app_entry.identifier, "solar_pro": solar_pro, "name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()}

                        lead_identifier = None
                        lead = Lead.first(Lead.field_app_identifier == app_entry.identifier)
                        if not lead is None:
                            lead_identifier = lead.identifier
                        ret_json["item"]["lead_identifier"] = lead_identifier
                        ret_json["item"]["is_lead"] = app_entry.is_lead

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "store_cpf_credentials":
        username = self.request.get("email")
        password = self.request.get("password")
        data_to_store = {};
        data_to_store["username"] = username
        data_to_store["password"] = password
        json_to_store = json.dumps(data_to_store)
        encrypted_json = Helpers.encrypt(json_to_store)

        bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())

        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/cpf_info_' + app_identity.get_application_id() + '.txt'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(
                        filename,
                        'w',
                        content_type="text/plain",
                        options={'x-goog-meta-foo': 'foo',
                                 'x-goog-meta-bar': 'bar',
                                 'x-goog-acl': 'public-read'},
                        retry_params=write_retry_params)
        gcs_file.write(encrypted_json)
        gcs_file.close()
        self.response.out.write("")

    elif self.request.get("fn") == "test_cpf_credentials":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        php_session_id = ""
        while php_session_id == "":

            #pick up a PHP session ID
            resp = urlfetch.fetch(url="https://tools.cleanpowerfinance.com/user/login",
                method=urlfetch.GET)

            try:
                val = resp.header_msg.getheaders("Set-Cookie")[0]

                if not val == "":

                    if val.index("PHPSESSID") >= 0:

                        php_session_id = val[0:val.index(";")]
            except:
                php_session_id = ""

        # we have a session id
        form_fields = {}
        form_fields["username"] = self.request.get("email")
        form_fields["password"] = self.request.get("password")

        resp = urlfetch.fetch(
            url="https://tools.cleanpowerfinance.com/user/login",
            method=urlfetch.POST,
            payload=urllib.urlencode(form_fields),
            deadline=30,
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cookie': php_session_id
            }
        )
        new_sess_id = False
        try:
            val = resp.header_msg.getheaders("Set-Cookie")[0]

            if not val == "":
                if val.index("PHPSESSID") >= 0:
                   new_sess_id = True
        except:
            ret_json["success"] = True

        ret_json["success"] = (not new_sess_id)

        final_url = ""
        if ret_json["success"]:

            try:
                final_url = getattr(resp, "final_url")
                if final_url is None:
                    ret_json["success"] = False
            except:
                ret_json["success"] = False

            ret_json["success"] = ret_json["success"] and (not (final_url == ""  or final_url is None))
        self.response.out.write(json.dumps(ret_json))



    elif self.request.get("fn") == "heartbeat":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["a"] = "b"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "time_slot_days_available":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["dates"] = []
        right_now = Helpers.pacific_now()
        right_now = right_now + timedelta(days=1)
        right_now_date = right_now.date()
        day_of_week = right_now_date.isoweekday()

        office_id = self.request.get("office_id")
        lead_id = self.request.get("lead_id")
        v2_param = str(self.request.get("v2") == "1")
        sunday_hit_count = 0
        done = False
        current_datetime = right_now
        already_suggested = False

        while not done:
            current_date = current_datetime.date()
            current_day_of_week = current_date.isoweekday()

            if current_day_of_week == 7:
                sunday_hit_count += 1

            item = {}
            #check if there's an exception for this date
            found_exception = False
            exceptions = SlotDateException.query(ndb.AND(SlotDateException.office_identifier == office_id, SlotDateException.exception_day == current_date.day, SlotDateException.exception_month == current_date.month, SlotDateException.exception_year == current_date.year))

            for exception in exceptions:
                found_exception = True
                slots = exception.slots
                count = 1

                while count < 13:
                    prop_str = "slot_" + str(count) + "_enabled"
                    item[prop_str] = getattr(slots, prop_str)
                    count = count + 1

            if not found_exception:
                days_map = {}
                days_map["1"] = "monday"
                days_map["2"] = "tuesday"
                days_map["3"] = "wednesday"
                days_map["4"] = "thursday"
                days_map["5"] = "friday"
                days_map["6"] = "saturday"
                days_map["7"] = "sunday"

                office_locations = OfficeLocation.query(OfficeLocation.identifier == office_id)

                for office_location in office_locations:
                    prop_str1 = days_map[str(current_day_of_week)] + "_slots"
                    slots = getattr(office_location, prop_str1)
                    count = 1

                    while count < 13:
                        prop_str2 = "slot_" + str(count) + "_enabled"
                        item[prop_str2] = getattr(slots, prop_str2)
                        count = count + 1

            month_str = str(current_date.month)

            if len(month_str) == 1:
                month_str = "0" + month_str

            day_str = str(current_date.day)

            if len(day_str) == 1:
                day_str = "0" + day_str

            #disable the slot if there are bookings or reservations
            survey_bookings = SurveyBooking.query(
                ndb.AND(
                    SurveyBooking.booking_day == int(day_str),
                    SurveyBooking.booking_month == int(month_str),
                    SurveyBooking.booking_year == current_date.year,
                    SurveyBooking.office_identifier == office_id,
                    ndb.OR(
                        SurveyBooking.completion_state == 0,
                        SurveyBooking.completion_state == 1,
                        SurveyBooking.completion_state == 2,
                        SurveyBooking.completion_state == 3
                    )
                )
            )
            for survey_booking in survey_bookings:
                if not survey_booking.archived:
                    item["slot_" + str(survey_booking.slot_number) + "_enabled"] = False

            count = 1

            while count < 13:
                full_key = office_id + "_" + day_str + "_" + month_str + "_" + str(current_date.year) + "_" + "slot_" + str(count)
                key = hashlib.md5(full_key).hexdigest()
                val = memcache.get(key)

                if not val is None:

                    if not val == lead_id:

                        item["slot_" + str(count) + "_enabled"] = False

                count = count + 1

            #autosuggest the next date
            if not already_suggested:
                count = 1

                while count < 13:
                    prop_str = "slot_" + str(count) + "_enabled"

                    if item[prop_str]:
                        month_str = str(current_date.month)

                        if len(month_str) == 1:
                            month_str = "0" + month_str

                        day_str = str(current_date.day)

                        if len(day_str) == 1:
                            day_str = "0" + day_str

                        full_key = office_id + "_" + day_str + "_" + month_str + "_" + str(current_date.year) + "_" + "slot_" + str(count)
                        key = hashlib.md5(full_key).hexdigest()

                        val = memcache.get(key)
                        pre_booked = True

                        if val is None:
                            pre_booked = False
                        else:

                            if val == lead_id and (not v2_param):
                                pre_booked = False

                        if not pre_booked:
                            ret_json["suggested_date"] = month_str + "-" + day_str + "-" + str(current_date.year)
                            ret_json["suggested_slot_number"] = count
                            already_suggested = True
                            count = 13

                    count = count + 1


            item["date"] = month_str + "-" + day_str + "-" + str(current_date.year)
            ret_json["dates"].append(item)

            if current_day_of_week == 7 and sunday_hit_count == 2:
                done = True

            current_datetime = current_datetime + timedelta(days=1)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_geo_data_for_office":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.geo_data = json.dumps([self.request.get("lat") + "," + self.request.get("lng")])
            office.put()

    elif self.request.get("fn") == "add_new_office":
        self.response.content_type = "application/json"
        ret_json = {}
        empty_slots = []
        count = 0
        while count < 7:
            survey_slot_block = SurveySlotBlock(
                identifier = Helpers.guid(),
                slot_1_enabled = False,
                slot_2_enabled = False,
                slot_3_enabled = False,
                slot_4_enabled = False,
                slot_5_enabled = False,
                slot_6_enabled = False,
                slot_7_enabled = False,
                slot_8_enabled = False,
                slot_9_enabled = False,
                slot_10_enabled = False,
                slot_11_enabled = False,
                slot_12_enabled = False
            )
            empty_slots.append(survey_slot_block)
            count = count + 1

        office_location = OfficeLocation(
            identifier = Helpers.guid(),
            name = self.request.get("office_name"),
            sales_rabbit_id=-1,
            sales_rabbit_area_id=-1,
            is_parent=(self.request.get("parent") == "n/a"),
            parent_identifier=self.request.get("parent"),
            active=True,
            override_data="{}",
            distribution_list=json.dumps(["thomas@newpower.net"]),
            residual_overrides=False,
            geo_data=json.dumps(["33.997989,-117.330541"])
        )
        if not office_location.is_parent:
            office_location.set_override_data({"recipients": [], "data": {}, "yielders": [], "other_accounts": {}})
        office_location.put()
        ret_json["identifier"] = office_location.identifier
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "office_deactivation":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.active = False
            office.put()

    elif self.request.get("fn") == "office_reactivation":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.active = True
            office.put()

    elif self.request.get("fn") == "modify_slot_data":
        office_locations = OfficeLocation.query(OfficeLocation.identifier == self.request.get("office"))
        for office_location in office_locations:
            slots = getattr(office_location, self.request.get("day") + "_slots")
            setattr(slots, "slot_" + self.request.get("slot_num") + "_enabled", self.request.get("value") == "1")
            setattr(office_location, self.request.get("day") + "_slots", slots)
            office_location.put()

    elif self.request.get("fn") == "add_date_exception":
        target_date = self.request.get("date").split("-")
        slot_entries = self.request.get("slots").split(",")
        ex_day = int(target_date[1])
        ex_month = int(target_date[0])
        ex_year = int(target_date[2])
        slot_date_exception_count = SlotDateException.query(ndb.AND(SlotDateException.exception_year == ex_year, SlotDateException.exception_day == ex_day, SlotDateException.exception_month == ex_month)).count()

        if slot_date_exception_count == 0:
            new_slot = SurveySlotBlock(
                identifier=Helpers.guid(),
                slot_1_enabled = slot_entries[0] == "1",
                slot_2_enabled = slot_entries[1] == "1",
                slot_3_enabled = slot_entries[2] == "1",
                slot_4_enabled = slot_entries[3] == "1",
                slot_5_enabled = slot_entries[4] == "1",
                slot_6_enabled = slot_entries[5] == "1",
                slot_7_enabled = slot_entries[6] == "1",
                slot_8_enabled = slot_entries[7] == "1",
                slot_9_enabled = slot_entries[8] == "1",
                slot_10_enabled = slot_entries[9] == "1",
                slot_11_enabled = slot_entries[10] == "1",
                slot_12_enabled = slot_entries[11] == "1"
            )
            new_exception = SlotDateException(
                identifier=Helpers.guid(),
                office_identifier = self.request.get("office"),
                exception_day=ex_day,
                exception_month=ex_month,
                exception_year=ex_year,
                slots=new_slot
            )
            new_exception.put();
        else:
            slot_date_exceptions = SlotDateException.query(ndb.AND(SlotDateException.exception_year == ex_year, SlotDateException.exception_day == ex_day, SlotDateException.exception_month == ex_month))
            for slot_date_exception in slot_date_exceptions:
                count = 1
                for item in slot_entries:
                    setattr(slot_date_exception.slots, "slot_" + str(count) + "_enabled", item == "1")
                    count = count + 1
                slot_date_exception.put()

    elif self.request.get("fn") == "office_slot_testing":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["slots"] = []
        offices1 = OfficeLocation.query(OfficeLocation.identifier == self.request.get("office"))
        for office in offices1:
            ret_json["office_name"] = office.name

        date_items = self.request.get("date").split("-")
        d = int(date_items[1])
        m = int(date_items[0])
        y = int(date_items[2])

        exceptions = SlotDateException.query(ndb.AND(SlotDateException.exception_day == d, SlotDateException.exception_month == m, SlotDateException.exception_year == y, SlotDateException.office_identifier == self.request.get("office")))
        found_exception = False
        for exception in exceptions:
            found_exception = True
            ret_json["exception_generated"] = True
            ret_json["rule_generated"] = False

            count = 1
            slots = exception.slots
            while count < 13:
                ret_json["slots"].append(getattr(slots, "slot_" + str(count) + "_enabled"))
                count = count + 1
        if not found_exception:
            #find out what day of the week it is
            days_map = {}
            days_map["1"] = "monday"
            days_map["2"] = "tuesday"
            days_map["3"] = "wednesday"
            days_map["4"] = "thursday"
            days_map["5"] = "friday"
            days_map["6"] = "saturday"
            days_map["7"] = "sunday"
            dt = date(y, m, d)
            day_of_week = dt.isoweekday()
            day_of_week_num_str = str(day_of_week)

            #do the query
            office_locations = OfficeLocation.query(OfficeLocation.identifier == self.request.get("office"))
            for office_location in office_locations:
                ret_json["exception_generated"] = False
                ret_json["rule_generated"] = True

                count = 1;
                slots = getattr(office_location, days_map[day_of_week_num_str] + "_slots")
                while count < 13:
                    ret_json["slots"].append(getattr(slots, "slot_" + str(count) + "_enabled"))
                    count = count + 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_bookings":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["slot_reservations"] = [False, False, False, False, False, False, False, False, False, False, False, False]
        office_id = self.request.get("office")

        date_items = self.request.get("date").split("-")
        d = int(date_items[1])
        m = int(date_items[0])
        y = int(date_items[2])

        d_str = date_items[1]
        m_str = date_items[0]
        y_str = date_items[2]

        lead_id = self.request.get("lead_id")

        v2_param = (str(self.request.get("v2")) == "1")

        #assume slots turned off is the same as being "reserved"
        office_locations = OfficeLocation.query(OfficeLocation.identifier == office_id)

        for office_location in office_locations:
            days_map = {}
            days_map["1"] = "monday"
            days_map["2"] = "tuesday"
            days_map["3"] = "wednesday"
            days_map["4"] = "thursday"
            days_map["5"] = "friday"
            days_map["6"] = "saturday"
            days_map["7"] = "sunday"

            dt = datetime(y, m, d)
            day_of_the_week = dt.isoweekday()
            day_of_the_week_num_str = str(day_of_the_week)

            slots = getattr(office_location, days_map[day_of_the_week_num_str] + "_slots")
            count = 1

            while count < 13:
                prop_str = "slot_" + str(count) + "_enabled"
                reserved = not getattr(slots, prop_str)
                ret_json["slot_reservations"][count - 1] = reserved
                count = count + 1

        exceptions = SlotDateException.query(ndb.AND(SlotDateException.office_identifier == office_id, SlotDateException.exception_day == d, SlotDateException.exception_month == m, SlotDateException.exception_year == y))

        for exception in exceptions:
            slots = exception.slots
            count = 1

            while count < 13:
                prop_str = "slot_" + str(count) + "_enabled"
                reserved = not getattr(slots, prop_str)
                ret_json["slot_reservations"][count -1] = reserved
                count = count + 1

        survey_bookings = SurveyBooking.query(
            ndb.AND(
                SurveyBooking.office_identifier == office_id,
                SurveyBooking.booking_day == d,
                SurveyBooking.booking_month == m,
                SurveyBooking.booking_year == y,
                ndb.OR(
                    SurveyBooking.completion_state == 0,
                    SurveyBooking.completion_state == 1,
                    SurveyBooking.completion_state == 2,
                    SurveyBooking.completion_state == 3
                )
            )
        )

        for survey_booking in survey_bookings:
            if not survey_booking.archived:
                ret_json["slot_reservations"][survey_booking.slot_number - 1] = True

        count = 1

        while count < 13:
            if not ret_json["slot_reservations"][count - 1]:
                full_key = office_id + "_" + d_str + "_" + m_str + "_" + y_str + "_" + "slot_" + str(count)
                key = hashlib.md5(full_key).hexdigest()

                val = memcache.get(key)

                if not val is None:
                    ret_json["slot_reservations"][count - 1] = (not val == lead_id)
                    if v2_param:
                        ret_json["slot_reservations"][count - 1] = True

            count = count + 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "reserve_slot":
        lead_id = self.request.get("lead_id")
        office_id = self.request.get("office")
        dayte = self.request.get("date")
        date_items = dayte.split("-")
        slot = self.request.get("slot")

        d = int(date_items[1])
        m = int(date_items[0])
        y = int(date_items[2])

        d_str = date_items[1]
        m_str = date_items[0]
        y_str = date_items[2]

        full_key = office_id + "_" + d_str + "_" + m_str + "_" + y_str + "_" + "slot_" + slot
        keyy = hashlib.md5(full_key).hexdigest()
        memcache.set(key=keyy, value=lead_id, time=900)

    elif self.request.get("fn") == "confirm_availability":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["still_good"] = True

        lead_id = self.request.get("lead_id")
        office_id = self.request.get("office_id")
        slot_num = int(self.request.get("slot"))
        slot_str = self.request.get("slot")
        dayte = self.request.get("date")
        date_items = dayte.split("-")

        d = int(date_items[1])
        m = int(date_items[0])
        y = int(date_items[2])

        d_str = date_items[1]

        if len(d_str) == 1:
            d_str = "0" + d_str

        m_str = date_items[0]

        if len(m_str) == 1:
            m_str = "0" + m_str
        y_str = date_items[2]

        dt = date(y, m, d)
        weekday = dt.isoweekday()

        days_map = {}
        days_map["1"] = "monday"
        days_map["2"] = "tuesday"
        days_map["3"] = "wednesday"
        days_map["4"] = "thursday"
        days_map["5"] = "friday"
        days_map["6"] = "saturday"
        days_map["7"] = "sunday"

        #check the rules
        office_locations = OfficeLocation.query(OfficeLocation.identifier == office_id)

        for office_location in office_locations:
            slots = getattr(office_location, days_map[str(weekday)] + "_slots")
            prop = getattr(slots, "slot_" + slot_str + "_enabled")

            ret_json["still_good"] = prop
            ret_json["rules_were_good"] = prop

        #check the exceptions
        exceptions = SlotDateException.query(ndb.AND(SlotDateException.office_identifier == office_id, SlotDateException.exception_day == d, SlotDateException.exception_month == m, SlotDateException.exception_year == y))

        for exception in exceptions:
            slots = exception.slots
            prop = getattr(slots, "slot_" + slot_str + "_enabled")

            ret_json["still_good"] = prop
            ret_json["exception_was_good"] = prop

        if ret_json["still_good"]:
            #check the actual bookings
            bookings = SurveyBooking.query(
                ndb.AND(
                    SurveyBooking.office_identifier == office_id,
                    SurveyBooking.booking_day == d,
                    SurveyBooking.booking_month == m,
                    SurveyBooking.booking_year == y,
                    SurveyBooking.slot_number == slot_num,
                    ndb.OR(
                        SurveyBooking.completion_state == 0,
                        SurveyBooking.completion_state == 1,
                        SurveyBooking.completion_state == 2,
                        SurveyBooking.completion_state == 3
                    )
                )
            )

            for booking in bookings:
                if not booking.archived:
                    ret_json["still_good"] = False
                    ret_json["booking_set_to_false"] = True

        if ret_json["still_good"]:
            #check reservations
            full_key = office_id + "_" + d_str + "_" + m_str + "_" + y_str + "_" + "slot_" + slot_str
            key = hashlib.md5(full_key).hexdigest()
            val = memcache.get(key)
            ret_json["checked_key"] = full_key
            ret_json["checked_hash"] = key
            ret_json["val_is_none"] = val is None
            if not val is None:
                ret_json["val_equals_leadid"] = val == lead_id
                ret_json["val"] = val
                ret_json["lead_id"] = lead_id
                if not val == lead_id:
                    ret_json["still_good"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "kill_reservations":
        keyss = self.request.get("keys").split(",")
        hashes = map(lambda key: hashlib.md5(key).hexdigest(), keyss)
        if len(hashes) >= 2:
            memcache.delete_multi(hashes, seconds=5)
        if len(hashes) == 1:
            memcache.delete(hashes[0])

    elif self.request.get("fn") == "add_appt_ajax":
        self.response.content_type = "application/json"
        date_items = self.request.get("appt_date").split("-")

        booking = SurveyBooking(
            identifier=Helpers.guid(),
            office_identifier=self.request.get("office_id"),
            field_app_identifier="notquiteanemptystring",
            field_app_lead_id="noequiteanemptystring",
            has_associated_field_entry=False,
            slot_number=int(self.request.get("appt_slot")),
            booking_day=int(date_items[1]),
            booking_month=int(date_items[0]),
            booking_year=int(date_items[2]),
            address=self.request.get("cust_address"),
            city=self.request.get("cust_postal"),
            state=self.request.get("cust_state"),
            postal=self.request.get("cust_postal"),
            phone_number=self.request.get("cust_phone"),
            email=self.request.get("cust_email"),
            name=self.request.get("cust_first")[0].upper() + self.request.get("cust_first")[1:] + " " + self.request.get("cust_last")[0].upper() + self.request.get("cust_last")[1:],
            completion_state=0,
            associated_rep_id=self.request.get("rep_id").upper(),
            utility_no=self.request.get("cust_utility"),
            notes="",
            fund="n/a",
            trust_docs="n/a",
            utility_provider="n/a",
			archived=False,
            save_me=False
        )
        success = True
        bookings = SurveyBooking.query(
            ndb.AND(
                SurveyBooking.booking_day == int(date_items[1]),
                SurveyBooking.booking_month == int(date_items[0]),
                SurveyBooking.booking_year == int(date_items[2]),
                SurveyBooking.slot_number == int(self.request.get("appt_slot")),
                SurveyBooking.office_identifier == self.request.get("office_id"),
                ndb.OR(
                    SurveyBooking.completion_state == 0,
                    SurveyBooking.completion_state == 1,
                    SurveyBooking.completion_state == 2,
                    SurveyBooking.completion_state == 3
                    )
            )
        )

        for booking_item in bookings:
            if not booking_item.archived:
                success = False

        if success:
            #booking.put()
            keyss = self.request.get("reservation_keys").split(",")
            hashes = map(lambda key: hashlib.md5(key).hexdigest(), keyss)

            if len(hashes) >= 2:
                memcache.delete_multi(hashes, seconds=5)

            if len(hashes) == 1:
                memcache.delete(hashes[0])

        ret_json = {}
        ret_json["success"] = success
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_open_appointments":
        self.response.content_type = "application/json"
        office_id = str(self.request.get("office_id"))
        is_surveyor = str(self.request.get("surveyor")) == "1"
        if office_id == "":
            office_id = self.session["user_rep_office"]

        if is_surveyor:
            office_id = self.request.get("o_id")

        date_items = self.request.get("appointment_date").split("-")
        appointment_date = date(int(date_items[2]), int(date_items[0]), int(date_items[1]))
        ret_json = {}
        ret_json["bookings"] = []
        bookings = None
        if not is_surveyor:
            bookings = SurveyBooking.query(
                ndb.AND(
                    SurveyBooking.office_identifier == office_id,
                    SurveyBooking.booking_day == appointment_date.day,
                    SurveyBooking.booking_month == appointment_date.month,
                    SurveyBooking.booking_year == appointment_date.year,
                    SurveyBooking.completion_state == 0
                    )
                ).order(SurveyBooking.slot_number)
        else:
            bookings = SurveyBooking.query(
                ndb.AND(
                    SurveyBooking.office_identifier == office_id,
                    SurveyBooking.booking_day == appointment_date.day,
                    SurveyBooking.booking_month == appointment_date.month,
                    SurveyBooking.booking_year == appointment_date.year,
                    ndb.OR(
                        SurveyBooking.completion_state == 0,
                        SurveyBooking.completion_state == 1,
                        SurveyBooking.completion_state == 2,
                        SurveyBooking.completion_state == 3
                        )
                    )
                ).order(SurveyBooking.slot_number)

        for booking in bookings:
            if booking.archived:
                continue

            item = {}
            item["identifier"] = booking.identifier
            item["address"] = booking.address
            item["city"] = booking.city
            item["state"] = booking.state
            item["postal"] = booking.postal
            item["name"] = booking.name
            item["slot_number"] = booking.slot_number
            item["phone_number"] = booking.phone_number
            item["phone_number_formatted"] = Helpers.format_phone_number(booking.phone_number)
            item["utility_no"] = booking.utility_no
            item["fund"] = booking.fund

            item["has_rep_info"] = False
            item["has_rep_name"] = False
            item["notes"] = str(booking.notes)
            item["completion_state"] = booking.completion_state
            item["rep_info"] = {}
            if booking.has_associated_field_entry:
                item["has_rep_info"] = True
                field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier)

                for field_app in field_apps:
                    item["rep_info"]["phone_formatted"] = Helpers.format_phone_number(field_app.rep_phone)
                    item["rep_info"]["phone"] = field_app.rep_phone
                    item["rep_info"]["email"] = field_app.rep_email
                    item["rep_info"]["opt_rep_notes"] = field_app.opt_rep_notes
                    item["sp2_time"] = str(field_app.sp_two_time)

            yousers = FieldApplicationUser.query(FieldApplicationUser.rep_id == booking.associated_rep_id)

            for youser in yousers:
                item["has_rep_name"] = True
                item["rep_info"]["name"] = youser.first_name + " " + youser.last_name

                if not item["has_rep_info"]:
                    item["rep_info"]["phone"] = youser.rep_phone
                    item["rep_info"]["phone_formatted"] = Helpers.format_phone_number(youser.rep_phone)
                    item["rep_info"]["email"] = youser.rep_email

            ret_json["bookings"].append(item)

        ret_json["date_queried"] = self.request.get("appointment_date")
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "cancel_booking":
        h_p_t = Helpers.pacific_today()
        deleted_bookings_entry = None
        new_deleted_bookings_entry = DeletedSurveyBooking(identifier = Helpers.guid(),
                                                          year = h_p_t.year,
                                                          month = h_p_t.month,
                                                          bookings = [])
        deleted_booking_entries = DeletedSurveyBooking.query(
            ndb.AND
            (
                DeletedSurveyBooking.year == h_p_t.year,
                DeletedSurveyBooking.month == h_p_t.month
            )
        )

        for item in deleted_booking_entries:
            deleted_bookings_entry = item

        if deleted_bookings_entry is None:
            deleted_bookings_entry = new_deleted_bookings_entry

        identifier = self.request.get("identifier")
        bookings = SurveyBooking.query(SurveyBooking.identifier == identifier)
        for booking in bookings:
            deleted_bookings_entry.bookings.append(booking)
            deleted_bookings_entry.put()

            for entity_results in [FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier),
                               SurveyBooking.query(SurveyBooking.field_app_identifier == booking.field_app_identifier),
                               PerfectPacketEntry.query(PerfectPacketEntry.field_application_identifier == booking.field_app_identifier),
                               PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier == booking.field_app_identifier),
                               PerfectPacketApproval.query(PerfectPacketApproval.field_application_identifier == booking.field_app_identifier),
                               CustomerProgressItem.query(CustomerProgressItem.field_app_identifier == booking.field_app_identifier),
                               Lead.query(Lead.field_app_identifier == booking.field_app_identifier)
                               ]:

                for entity in entity_results:
                    entity.archived = True
                    entity.hold_items = "[]"
                    entity.has_holds = False
                    entity.put()


            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
            if not app_entry is None:
                usr = None
                try:
                    usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                except:
                    usr = usr

                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "booking_cancelled")

                try:
                    app_entry.hide_from_recent_view = True
                    app_entry.put()
                except:
                    app_entry = app_entry

                lb_stat = LeaderBoardStat(
                    identifier=Helpers.guid(),
                    rep_id=app_entry.rep_id,
                    dt=Helpers.pacific_now(),
                    metric_key="appointment_cancelled",
                    office_identifier=app_entry.office_identifier,
                    field_app_identifier=app_entry.identifier,
                    in_bounds=True,
                    pin_identifier="-1"
                )
                lb_stat.put()

            booking.key.delete()

    elif self.request.get("fn") == "update_cust_postal":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.customer_postal = self.request.get("postal")
            app_entry.put()

            booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
            if not booking is None:
                booking.postal = self.request.get("postal")
                booking.put()

    elif self.request.get("fn") == "enumerate_field_app_entries_from_range":
        self.response.content_type = "text/plain"
        floor = int(self.request.get("floor"))
        ceiling = int(self.request.get("ceiling"))

        query = FieldApplicationEntry.query(
                    ndb.AND(
                        FieldApplicationEntry.insert_time >= floor,
                        FieldApplicationEntry.insert_time <= ceiling
                    )
                )
        ret_json = {}
        ret_json["entries"] = []

        #find out if there are any dupes
        entry_info_pieces = {}
        for entry in query:
            if entry.archived:
                continue

            l_name = entry.customer_last_name.lower.strip().replace(" ", "_")
            address = entry.customer_address.lower().strip().replace(" ", "_")

            key = l_name + "_" + address

            info_item = {}
            info_item["first_name"] = entry.customer_first_name
            info_item["last_name"] = entry.customer_last_name
            info_item["address"] = entry.customer_address
            info_item["city"] = entry.customer_city


            if not key in entry_info_pieces:
                enty_info_pieces[key] = []

            entry_info_pieces[key].append(info_item)

    elif self.request.get("fn") == "save_notification_list":
        identifier = self.request.get("identifier")
        email_list = self.request.get("values").strip()
        email_list = email_list.replace("\r", "\n");
        email_addresses = email_list.split("\n")

        notifications = Notification.query(Notification.identifier == identifier)

        for notification in notifications:
            new_notification_list = []

            for emayle_address in email_addresses:
                person = PersonToNotify(
                    identifier=Helpers.guid(),
                    email_address=emayle_address
                )
                new_notification_list.append(person)

            notification.notification_list = new_notification_list
            notification.put()

    elif self.request.get("fn") == "update_booking_status":
        apps_script_mailer_url = Helpers.get_apps_script_mailer_url()
        identifier = self.request.get("identifier")
        status = int(self.request.get("status"))
        notes = self.request.get("notes").strip()
        notes = notes.replace("\r\n", "\n")
        notes = notes.replace("\r", "\n")

        office_name = ""
        bookings = SurveyBooking.query(SurveyBooking.identifier == identifier)
        for booking in bookings:
            booking.completion_state = status
            booking.notes = notes
            booking.put()

            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
            if not app_entry is None:
                usr = None
                try:
                    usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                except:
                    usr = usr

                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "survey_status_update")

            office_locations = OfficeLocation.query(OfficeLocation.identifier == booking.office_identifier)
            for office_location in office_locations:
                office_name = office_location.name

            if status == 3:
                #get the notification for this action
                notifications = Notification.query(Notification.action_name == "Customer Cancels Appointment")
                emails = []
                for notification in notifications:
                    for notification_person in notification.notification_list:
                        emails.append(notification_person.email_address)

                date_str = "";
                date_str += str(booking.booking_month)

                if len(date_str) == 1:
                    date_str = "0" + date_str

                date_str += "/"
                day = str(booking.booking_day)

                if len(day) == 1:
                    day = "0" + day

                date_str += (day + "/")
                date_str += str(booking.booking_year)

                cancellation_msg = "A survey appointment has been reported cancelled.\nThe customer was " + booking.name + ".\nThe appointment would have been on " + date_str + ".\n The appointment was associated with the " + office_name + " office.\n\n"
                cancellation_msg += "The following notes were left by the surveyor:\n\n"
                cancellation_msg += notes

                final_email_str = None
                if len(emails) == 1:
                    final_email_str = emails[0]
                elif len(emails) > 1:
                    final_email_str = string.join(emails, ",")
                else:
                    #nadah
                    x = 25
                form_fields = {"to": final_email_str, "subject": "Appointment Cancelled","message": cancellation_msg}

                if len(emails) > 1:
                    form_fields["mutliple"] = "1"

                if not final_email_str is None:
                    form_data = urllib.urlencode(form_fields)
                    resp = urlfetch.fetch(url=apps_script_mailer_url,
                        payload=form_data,
                        method=urlfetch.POST,
                        headers={'Content-Type': 'application/x-www-form-urlencoded'})

            rep_id = booking.associated_rep_id
            users = FieldApplicationUser.query(FieldApplicationUser.rep_id == rep_id)
            for user in users:
                msg = "Customer Name: " + booking.name + "\n"
                msg += "Customer Address:\n\t" + booking.address + "\n\t" + booking.city + ", " + booking.state + "\n"
                msg += "Update on status: " + Helpers.get_booking_status_type(booking.completion_state) + "\n\n"
                msg += "The following notes were left by the surveyor:\n\n"
                msg += notes
                form_fields = {}
                form_fields["to"] = user.rep_email
                form_fields["subject"] = "Survey Appointment Status Update"
                form_fields["message"] = msg

                form_data = urllib.urlencode(form_fields)
                resp = urlfetch.fetch(url=apps_script_mailer_url,
                    payload=form_data,
                    method=urlfetch.POST,
                    headers={'Content-Type': 'application/x-www-form-urlencoded'})

    elif self.request.get("fn") == "get_upcoming_view":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["offices"] = []

        now  = Helpers.pacific_now()
        # skip ahead a day
        #now = now + timedelta(days=1)
        # except don't
        tomorrow = now + timedelta(days=1)
        day_after_tomorrow = tomorrow + timedelta(days=1)
        day_after_day_after_tomorrow = day_after_tomorrow + timedelta(days=1)

        date_items = {}
        date_items["years"] = []
        date_items["months"] = []
        date_items["days"] = []

        date_map = {}
        for dt in [now, tomorrow, day_after_tomorrow, day_after_day_after_tomorrow]:
            dt_date = dt.date()
            date_items["years"].append(dt_date.year)
            date_items["months"].append(dt_date.month)
            date_items["days"].append(dt_date.day)

            date_map[str(dt_date.month) + "-" + str(dt_date.day) + "-" + str(dt_date.year)] = Helpers.get_weekday_str(dt_date.isoweekday())


        offices = OfficeLocation.query(OfficeLocation.parent_identifier != "n/a")
        for office in offices:
            office_item = {}
            office_item["name"] = office.name
            office_item["appointments"] = {}

            for dt in [now, tomorrow, day_after_tomorrow, day_after_day_after_tomorrow]:
                day_str = Helpers.get_weekday_str(dt.date().isoweekday())
                office_item["appointments"][day_str] = {}

                count = 1
                while count < 13:
                    office_item["appointments"][day_str]["slot_" + str(count)] = None
                    count = count + 1


            #booking = SurveyBooking.query(ndb.AND(SurveyBooking.identifier != "", SurveyBooking.identifier != " "))
            bookings = SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.office_identifier == office.identifier,
                    SurveyBooking.completion_state == 0,
                    ndb.OR
                    (
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][0],
                            SurveyBooking.booking_month == date_items["months"][0],
                            SurveyBooking.booking_day == date_items["days"][0]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][1],
                            SurveyBooking.booking_month == date_items["months"][1],
                            SurveyBooking.booking_day == date_items["days"][1]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][2],
                            SurveyBooking.booking_month == date_items["months"][2],
                            SurveyBooking.booking_day == date_items["days"][2]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][3],
                            SurveyBooking.booking_month == date_items["months"][3],
                            SurveyBooking.booking_day == date_items["days"][3]
                        )
                    )
                )
            )
            for booking in bookings:
                if booking.archived:
                    continue

                appointment_item = {}
                appointment_item["identifier"] = booking.identifier
                appointment_item["name"] = booking.name
                appointment_item["slot_number"] = booking.slot_number
                appointment_item["address"] = booking.address
                appointment_item["city"] = booking.city
                appointment_item["state"] = booking.state
                appointment_item["postal"] = booking.postal
                appointment_item["phone_number"] = booking.phone_number
                appointment_item["phone_number_formatted"] = Helpers.format_phone_number(booking.phone_number)
                appointment_item["email"] = booking.email
                appointment_item["slot_number"] = booking.slot_number
                appointment_item["fund"] = booking.fund
                appointment_item["trust_docs"] = booking.trust_docs

                appointment_item["associated_rep_id"] = booking.associated_rep_id

                weekday_key = date_map[str(booking.booking_month) + "-" + str(booking.booking_day) + "-" + str(booking.booking_year)]
                office_item["appointments"][weekday_key]["slot_" + str(booking.slot_number)] = appointment_item


            ret_json["offices"].append(office_item)

        ret_json["funding_list"] = Helpers.list_funds()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_upcoming_view_v2":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["offices"] = []

        #now  = Helpers.pacific_now()
        today = self.request.get("today").split("-")
        now = datetime(int(today[2]), int(today[0]), int(today[1]), 0, 0, 1)

        # skip ahead a day
        #now = now + timedelta(days=1)
        # except don't
        tomorrow = now + timedelta(days=1)
        day_after_tomorrow = tomorrow + timedelta(days=1)
        day_after_day_after_tomorrow = day_after_tomorrow + timedelta(days=1)

        times_lst = [now, tomorrow, day_after_tomorrow, day_after_day_after_tomorrow]

        sunday_idx = -1
        cnt = 0
        while cnt < len(times_lst):
            item_wd = times_lst[cnt].isoweekday()
            if item_wd == 7 and sunday_idx == -1:
                sunday_idx = cnt

            cnt += 1

        if not sunday_idx == -1:
            times_lst_cpy = times_lst[0:sunday_idx]
            cnt = sunday_idx
            while cnt < len(times_lst):
                times_lst_cpy.append(times_lst[cnt] + timedelta(days=1))
                cnt += 1

            times_lst = times_lst_cpy

        date_items = {}
        date_items["years"] = []
        date_items["months"] = []
        date_items["days"] = []

        date_map = {}
        for dt in times_lst:
            dt_date = dt.date()
            date_items["years"].append(dt_date.year)
            date_items["months"].append(dt_date.month)
            date_items["days"].append(dt_date.day)

            date_map[str(dt_date.month) + "-" + str(dt_date.day) + "-" + str(dt_date.year)] = Helpers.get_weekday_str(dt_date.isoweekday())


        offices = OfficeLocation.query(OfficeLocation.parent_identifier != "n/a")
        for office in offices:
            office_item = {}
            office_item["name"] = office.name
            office_item["appointments"] = {}

            for dt in times_lst:
                day_str = Helpers.get_weekday_str(dt.date().isoweekday())
                office_item["appointments"][day_str] = {}

                count = 1
                while count < 13:
                    office_item["appointments"][day_str]["slot_" + str(count)] = None
                    count = count + 1


            #booking = SurveyBooking.query(ndb.AND(SurveyBooking.identifier != "", SurveyBooking.identifier != " "))
            bookings = SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.office_identifier == office.identifier,
                    SurveyBooking.completion_state == 0,
                    ndb.OR
                    (
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][0],
                            SurveyBooking.booking_month == date_items["months"][0],
                            SurveyBooking.booking_day == date_items["days"][0]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][1],
                            SurveyBooking.booking_month == date_items["months"][1],
                            SurveyBooking.booking_day == date_items["days"][1]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][2],
                            SurveyBooking.booking_month == date_items["months"][2],
                            SurveyBooking.booking_day == date_items["days"][2]
                        ),
                        ndb.AND
                        (
                            SurveyBooking.booking_year == date_items["years"][3],
                            SurveyBooking.booking_month == date_items["months"][3],
                            SurveyBooking.booking_day == date_items["days"][3]
                        )
                    )
                )
            )
            field_app_identifiers_to_query = ["-1"]
            booking_identifier_field_app_identifier_dict = {}
            field_app_identifier_booking_identifier_dict = {}

            for booking in bookings:
                if booking.archived:
                    continue

                appointment_item = {}
                appointment_item["identifier"] = booking.identifier
                appointment_item["name"] = booking.name
                appointment_item["slot_number"] = booking.slot_number
                appointment_item["address"] = booking.address
                appointment_item["city"] = booking.city
                appointment_item["state"] = booking.state
                appointment_item["postal"] = booking.postal
                appointment_item["phone_number"] = booking.phone_number
                appointment_item["phone_number_formatted"] = Helpers.format_phone_number(booking.phone_number)
                appointment_item["email"] = booking.email
                appointment_item["slot_number"] = booking.slot_number
                appointment_item["fund"] = booking.fund
                appointment_item["trust_docs"] = booking.trust_docs
                appointment_item["utility_provider"] = booking.utility_provider

                appointment_item["associated_rep_id"] = booking.associated_rep_id

                field_app_identifiers_to_query.append(booking.field_app_identifier)
                booking_identifier_field_app_identifier_dict[appointment_item["identifier"]] = booking.field_app_identifier
                field_app_identifier_booking_identifier_dict[booking.field_app_identifier] = appointment_item["identifier"]

                weekday_key = date_map[str(booking.booking_month) + "-" + str(booking.booking_day) + "-" + str(booking.booking_year)]
                office_item["appointments"][weekday_key]["slot_" + str(booking.slot_number)] = appointment_item

            field_app_id_extra_info_dict = {}
            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_identifiers_to_query))
            for field_app in field_apps:
                dct = {}
                dct["customer_dob"] = str(field_app.customer_dob)
                dct["utility_no"] = field_app.customer_utility_account_number
                field_app_id_extra_info_dict[field_app.identifier] = dct

            for wday_key in office_item["appointments"].keys():
                for slot_key in office_item["appointments"][wday_key].keys():

                        appt = office_item["appointments"][wday_key][slot_key]

                        if not appt is None:
                            try:
                                dct = field_app_id_extra_info_dict[booking_identifier_field_app_identifier_dict[appt["identifier"]]]
                                appt["customer_dob"] = dct["customer_dob"]
                                appt["utility_no"] = dct["utility_no"]
                            except:
                                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.booking_identifier == appt.booking_identifier)
                                logging.info(appt)
                                dct = field_app_id_extra_info_dict[booking_identifier_field_app_identifier_dict[appt["identifier"]]]


            ret_json["offices"].append(office_item)

        ret_json["funding_list"] = Helpers.list_funds()
        ret_json["utility_providers"] = Helpers.read_setting("utility_providers")

        self.response.out.write(json.dumps(ret_json))



    elif self.request.get("fn") == "set_funding_tier_for_booking":
        booking = SurveyBooking.first(SurveyBooking.identifier == self.request.get("identifier"))
        if not booking is None:
            booking.funding_tier = self.request.get("tier")
            booking.put()

    elif self.request.get("fn") == "set_fund_for_booking":
        booking = SurveyBooking.first(SurveyBooking.identifier == self.request.get("identifier"))
        funds = Helpers.list_funds()
        if not booking is None:
            booking.fund = self.request.get("fund")
            booking.funding_tier = "n/a"
            booking.put()

            app_entree = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
            if not app_entree is None:
                usr = None
                try:
                    usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                except:
                    usr = usr
                if not usr is None:
                    CustomerTranscriber.transcribe(app_entree, usr, "fund_set")

                    user2 = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entree.rep_id)
                    if not user2 is None:
                        for f in funds:
                            if f["value"] == booking.fund:
                                msg = app_entree.customer_first_name.strip().title() + " " + app_entree.customer_last_name.strip().title() + "'s fund has been set to " + f["value_friendly"] + "."
                                t = "t"#Helpers.send_sms(user2.rep_phone, msg)

            if (not booking.fund == "fail") and (not booking.fund == "failed"):

                if booking.has_associated_field_entry:

                    field_app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier)

                    for app_entry in field_app_entries:

                        sp_two_dt = app_entry.sp_two_time
                        sp2_dt_start = date(sp_two_dt.year, sp_two_dt.month, sp_two_dt.day)

                        sp2_hours = sp_two_dt.hour
                        sp2_ampm = "am"

                        if sp2_hours > 12:
                            sp2_ampm = "pm"
                            sp2_hours -= 12

                        sp2_hours = str(sp2_hours)

                        sp2_mins = str(sp_two_dt.minute)

                        template_vars = {}
                        template_vars["cust_name"] = app_entry.customer_first_name + " " + app_entry.customer_last_name
                        days_map = {"1": "Monday", "2": "Tuesday", "3": "Wednesday", "4": "Thursday", "5": "Friday", "6": "Saturday", "7": "Sunday"}
                        months_map = {"1": "January", "2": "February", "3": "March", "4": "April", "5": "May", "6": "June", "7": "July", "8": "August", "9": "September", "10": "October", "11": "November", "12": "December"}
                        booking_dayyy = date(booking.booking_year, booking.booking_month, booking.booking_day)
                        template_vars["dayofweek"] = days_map[str(booking_dayyy.isoweekday())]
                        template_vars["month_name"] = months_map[str(booking.booking_month)]
                        template_vars["day"] = str(booking.booking_day)
                        template_vars["sp2_dayofweek"] = days_map[str(sp2_dt_start.isoweekday())]
                        template_vars["sp2_month_name"] = months_map[str(sp2_dt_start.month)]
                        template_vars["sp2_day"] = str(sp2_dt_start.day)
                        template_vars["sp2_hour"] = sp2_hours
                        if len(template_vars["sp2_hour"]) == 0:
                            template_vars["sp2_hour"] = "0" + template_vars["sp2_hour"]

                        template_vars["sp2_min"] = sp2_mins
                        if len(template_vars["sp2_min"]) == 0:
                            template_vars["sp2_min"] = "0" + template_vars["sp2_min"]

                        template_vars["sp2_ampm"] = sp2_ampm.upper()

                        # get the rep's name from the FieldApplicationUser store
                        template_vars["rep_name"] = "New Power"
                        the_reps = FieldApplicationUser.query(FieldApplicationUser.rep_id == booking.associated_rep_id)
                        for the_rep in the_reps:
                            template_vars["rep_name"] = the_rep.first_name + " " + the_rep.last_name

                        #template_vars["rep_name"] = str(self.session["user_name"])
                        template_vars["rep_phone"] = Helpers.format_phone_number(app_entry.rep_phone)

                        #Helpers.send_html_email(app_entry.customer_email, "Confirmation from New Power", "field_form_cust_notify", template_vars)

            else:

                if booking.has_associated_field_entry:

                    field_app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier)

                    for app_entry in field_app_entries:

                        template_vars = {}
                        template_vars["cust_name"] = app_entry.customer_first_name + " " + app_entry.customer_last_name

                        template_vars["rep_name"] = "New Power"
                        the_reps = FieldApplicationUser.query(FieldApplicationUser.rep_id == booking.associated_rep_id)
                        for the_rep in the_reps:
                            template_vars["rep_name"] = the_rep.first_name + " " + the_rep.last_name

                        #template_vars["rep_name"] = str(self.session["user_name"])
                        template_vars["rep_phone"] = Helpers.format_phone_number(app_entry.rep_phone)

                        Helpers.send_html_email(app_entry.customer_email, "Update from New Power", "cust_fails_credit", template_vars)

            self.response.out.write("")

    elif self.request.get("fn") == "set_trust_for_booking":
        bookings = SurveyBooking.query(SurveyBooking.identifier == self.request.get("identifier"))

        for booking in bookings:
            booking.trust_docs = self.request.get("trust")
            booking.put()

            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
            if not app_entry is None:
                usr = None
                try:
                    usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                except:
                    usr = usr

                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "trust_docs")

        self.response.out.write("")

    elif self.request.get("fn") == "qual_card_search":
        self.response.content_type = "application/json"

        fname = str(self.request.get("first"))
        lname = str(self.request.get("last"))
        postal = str(self.request.get("postal"))

        fnames = []
        has_first = len(fname) > 0

        if(has_first):

            fnames = [fname, fname.upper(), fname[0].upper() + fname[1:]]

        lnames = []
        has_last = len(lname) > 0

        if(has_last):

            lnames = [lname, lname.upper(), lname[0].upper() + lname[1:]]

        has_postal = len(postal) > 0

        entries = None

        if has_first and (not has_last and not has_postal):
            entries = FieldApplicationEntry.query(FieldApplicationEntry.customer_first_name.IN(fnames))

        elif has_last and (not has_first and not has_postal):
            entries = FieldApplicationEntry.query(FieldApplicationEntry.customer_last_name.IN(lnames))

        elif has_postal and (not has_first and not has_last):
            entries = FieldApplicationEntry.query(FieldApplicationEntry.customer_postal == postal)

        elif has_first and has_last and (not has_postal):
            entries = FieldApplicationEntry.query(
                ndb.AND(
                   FieldApplicationEntry.customer_first_name.IN(fnames),
                   FieldApplicationEntry.customer_last_name.IN(lnames)
                )
            )

        elif has_first and has_postal and (not has_last):
            entries = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.customer_first_name.IN(fnames),
                    FieldApplicationEntry.customer_postal == postal
                )
            )

        elif has_last and has_postal and (not has_first):
            entries = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.customer_last_name.IN(lnames),
                    FieldApplicationEntry.customer_postal == postal
                )
            )

        elif has_first and has_last and has_postal:
            entries = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.customer_first_name.IN(fnames),
                    FieldApplicationEntry.customer_last_name.IN(lnames),
                    FieldApplicationEntry.customer_postal == postal
                )
            )

        else:
            entries = None

        ret_json = {}
        ret_json["results"] = []

        if not entries is None:

            for entry in entries:

                result = {}
                result["identifier"] = entry.identifier
                result["image_extension"] = entry.image_extension
                ret_json["results"].append(result)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "nightly_backup":
        self.response.content_type = "application/json"
        ret_json = {}

        if str(self.request.get("step")) == "start_backup":
            item_names = []
            self.response.content_type = "application/json"
            g = globals().copy()

            for name, obj in g.iteritems():
                try:
                    if str(obj.__bases__[len(obj.__bases__) - 2]) == "Model<>":
                        item_names.append(name)
                except:
                    x = 22

            token = hashlib.md5(str(int(time.time() * 1000))).hexdigest()
            backup_info = {}
            backup_info["entities"] = item_names
            backup_info["entity_idx"] = 0
            backup_info["offset"] = 0
            backup_info["page"] = 1
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy=token + "_backup_info",
                val=json.dumps(backup_info),
                expiration=Helpers.pacific_now() + timedelta(days=1)
            )
            kv_item.put()

            ret_json["token"] = token

        elif str(self.request.get("step")) == "continue":
            finished = True
            backup_info = None
            token = self.request.get("token")
            kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy == token + "_backup_info")
            for kv_item in kv_items:
                backup_info = json.loads(kv_item.val)

            if not backup_info is None:
                entity = None
                try:
                    entity = backup_info["entities"][backup_info["entity_idx"]]
                except:
                    entity == None

                if not entity is None:
                    finished = False
                    oset = backup_info["offset"]
                    page = backup_info["page"]
                    atts = Helpers.list_ndb_attributes_for_class(entity)
                    no_data_left = True

                    items = {}
                    items["items"] = []

                    entities = eval(entity + ".query(" + entity + ".identifier != \"\").order(" + entity + ".identifier)")


                    for entitee in entities.fetch(100, offset=oset):
                        no_data_left = False
                        item = {}
                        item["values"] = []
                        for att in atts:

                            kls_name = eval("str(type(entitee." + att + ").__name__)")
                            bases_str = eval("str(" + kls_name + ".__bases__)")

                            if not bases_str == "(Model<>,)":
                                item_att = {}
                                item_att["value"] = eval("unicode(entitee." + att + ")")
                                item_att["type"] = str(type(eval("entitee." + att)))
                                item_att["name"] = att
                            else:
                                item_att = {}
                                item_att["type"] = "ndb.StructuredProperty<" + kls_name + ">"
                                item_att["name"] = att

                                sub_attrs = Helpers.list_ndb_attributes_for_class(kls_name)

                                sub_attributes = {}
                                for sub_attr in sub_attrs:
                                    sub_item = {}
                                    sub_item["value"] = eval("unicode(entitee." + att + "." + sub_attr + ")")
                                    sub_item["type"] = str(type(eval("entitee." + att + "." + sub_attr)))
                                    sub_item["name"] = sub_attr

                                    sub_attributes[sub_attr] = sub_item

                                item_att["value"] = sub_attributes

                            item["values"].append(item_att)

                        items["items"].append(item)

                    if no_data_left:
                        backup_info["entity_idx"] += 1
                        backup_info["page"] = 1
                        backup_info["offset"] = 0

                    else:
                        backup_info["offset"] += 100
                        backup_info["page"] += 1

                        bucket_name = os.environ.get('BUCKET_NAME',
                                                      app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        filename = bucket + '/TempBackups/' + token + "_" + entity + "_" + str(page) + '.json'

                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)

                        gcs_file.write(json.dumps(items))
                        gcs_file.close()

                    kv_items2 = KeyValueStoreItem.query(KeyValueStoreItem.keyy == self.request.get("token") + "_backup_info")
                    for kv_item2 in kv_items2:
                        kv_item2.val = json.dumps(backup_info)
                        kv_item2.put()


            if finished:
                kv_items3 = KeyValueStoreItem.query(KeyValueStoreItem.keyy == self.request.get("token") + "_backup_info")
                for kv_item3 in kv_items3:
                    kv_item3.key.delete()


            ret_json["finished"] = finished

        elif self.request.get("step") == "publicize_log_file":
            token = self.requbucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())

            bucket = '/' + bucket_name
            filename = bucket + '/TempBackups/job_' + token + '.txt'

            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

            gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
            log_txt = gcs_file.read()
            gcs_file.close()

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)

            gcs_file.write(log_txt)
            gcs_file.close()

            ret_json["success"] = True

        else:
            ret_json["error"] = True

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "drop_column":
        item_names = []

        try:
            if str(self.session["user_name"]) == "" or str(self.session["user_type"]) != "super":
                self.session.non_existent_method("foo", "bar")
        except:
            self.response.out.write("**")
            return

        if str(self.request.get("entity")) == "":
            g = globals().copy()
            for name, obj in g.iteritems():
                try:
                    if str(obj.__bases__[len(obj.__bases__) - 2]) == "Model<>":
                        item_names.append(name)

                except:
                    self.session = self.session

            template_values = {}
            template_values["entities"] = ",".join(item_names)
            template_values["include_field_name"] = "true"
            path = Helpers.get_html_path('select_entity.html')
            self.response.out.write(template.render(path, template_values))

        else:
            field_name = self.request.get("field_name")
            entity = self.request.get("entity")
            qry = eval(entity + ".query(" + entity + ".identifier != \"\")")

            items_to_put = []

            for entitee in qry:
                if field_name in entitee._properties:
                    del entitee._properties[field_name]

                try:
                    delattr(entitee, field_name)
                except:
                    field_name = field_name

                items_to_put.append(entitee)

            if len(items_to_put) == 1:
                items_to_put[0].put()
            elif len(items_to_put) > 1:
                ndb.put_multi(items_to_put)
            else:
                field_name = field_name

    elif self.request.get("fn") == "update_schema":
        item_names = []

        try:
            if str(self.session["user_name"]) == "" or str(self.session["user_type"]) != "super":
                self.session.non_existent_method("foo", "bar")
        except:
            self.response.out.write("**")
            return

        if str(self.request.get("entity")) == "":
            g = globals().copy()
            for name, obj in g.iteritems():
                try:
                    if str(obj.__bases__[len(obj.__bases__) - 2]) == "Model<>":
                        item_names.append(name)

                except:
                    self.session = self.session

            template_values = {}
            template_values["entities"] = ",".join(item_names)
            template_values["include_field_name"] = "false"
            path = Helpers.get_html_path('select_entity.html')
            self.response.out.write(template.render(path, template_values))
        else:
            #first request, generate the token
            if not len(str(self.request.get("token"))) == 32:
                template_values = {}
                template_values["entity"] = self.request.get("entity")
                template_values["token"] = hashlib.md5(str(int(time.time() * 1000))).hexdigest()
                path = Helpers.get_html_path('begin_backup.html')
                self.response.out.write(template.render(path, template_values))
                return

            #assume we have a token now
            token = self.request.get("token")


            #if there's no step, we're starting w/backup'
            step = ""
            if len(str(self.request.get("step"))) == 0:
                step = "backup"
            else:
                step = self.request.get("step")

            oset = 0
            if len(str(self.request.get("offset"))) > 0:
                oset = int(self.request.get("offset"))


            entity = self.request.get("entity")
            atts = Helpers.list_ndb_attributes_for_class(entity)

            if step == "backup":
                items = {}
                items["items"] = []
                page = 1
                if (not str(self.request.get("page")) == "") and (not str(self.request.get("page")).lower() == "none"):
                    page = int(self.request.get("page"))

                entities = eval(entity + ".query(" + entity + ".identifier != \"\").order(" + entity + ".identifier)")

                no_data_left = True
                for entitee in entities.fetch(100, offset=oset):
                    no_data_left = False
                    item = {}
                    item["values"] = []
                    for att in atts:
                        try:
                            kls_name = eval("str(type(entitee." + att + ").__name__)")
                            bases_str = eval("str(" + kls_name + ".__bases__)")
                        except:
                            logging.info(entitee.identifier)
                            logging.info(att)
                            hit_exception = True

                        if not bases_str == "(Model<>,)":
                            item_att = {}
                            item_att["value"] = eval("unicode(entitee." + att + ")")
                            item_att["type"] = str(type(eval("entitee." + att)))
                            item_att["name"] = att
                        else:
                            item_att = {}
                            item_att["type"] = "ndb.StructuredProperty<" + kls_name + ">"
                            item_att["name"] = att

                            sub_attrs = Helpers.list_ndb_attributes_for_class(kls_name)

                            sub_attributes = {}
                            for sub_attr in sub_attrs:
                                sub_item = {}
                                sub_item["value"] = eval("unicode(entitee." + att + "." + sub_attr + ")")
                                sub_item["type"] = str(type(eval("entitee." + att + "." + sub_attr)))
                                sub_item["name"] = sub_attr

                                sub_attributes[sub_attr] = sub_item

                            item_att["value"] = sub_attributes

                        item["values"].append(item_att)

                    items["items"].append(item)

                if no_data_left:
                    self.redirect("/data?fn=update_schema&entity=" + entity + "&token=" + token + "&step=show_confirm_cs")
                    return
                else:
                    bucket_name = os.environ.get('BUCKET_NAME',
                                                      app_identity.get_default_gcs_bucket_name())
                    bucket = '/' + bucket_name
                    filename = bucket + '/TempBackups/' + token + "_" + entity + "_" + str(page) + '.json'

                    write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                    gcs_file = gcs.open(
                        filename,
                        'w',
                        content_type="text/plain",
                        options={'x-goog-meta-foo': 'foo',
                                 'x-goog-meta-bar': 'bar',
                                 'x-goog-acl': 'public-read'},
                        retry_params=write_retry_params)

                    gcs_file.write(json.dumps(items))
                    gcs_file.close()
                    self.redirect("/data?fn=update_schema&token=" + token + "&entity=" + entity + "&step=backup&offset=" + str(oset + 100) + "&page=" + str(page + 1))
                    return

            elif step == "show_confirm_cs":
                template_values = {}
                template_values["token"] = token
                template_values["entity"] = entity

                path = Helpers.get_html_path('confirm_cs.html')
                self.response.out.write(template.render(path, template_values))
                return

            elif step == "truncate_entity":
                ndb.delete_multi(eval(entity + ".query().fetch(999999, keys_only=True)"))
                ndb.get_context().clear_cache()
                template_values = {}
                template_values["token"] = token
                template_values["entity"] = entity

                path = Helpers.get_html_path('confirm_empty.html')
                self.response.out.write(template.render(path, template_values))
                return

            elif step == "modify_schema":
                new_field = Helpers.update_ndb_schema_in_gcs(entity)
                self.redirect("/data?fn=update_schema&entity=" + entity + "&token=" + token + "&step=restore&new_field=" + new_field)
                return

            elif step == "restore":
                new_fields = self.request.get("new_field").split("|||")
                file_suffix = 1
                if len(str(self.request.get("page"))) > 0:
                    file_suffix = int(self.request.get("page"))

                bucket_name = os.environ.get('BUCKET_NAME',
                                              app_identity.get_default_gcs_bucket_name())
                bucket = '/' + bucket_name
                try:
                    klass_deph_str = "class " + entity + "(ndb.Model):\n"
                    klass_bod_linez = Helpers.get_ndb_class_definition_lines(entity)
                    for klass_bod_line in klass_bod_linez:
                        klass_deph_str += "\t" + klass_bod_line + "\n"

                    exec klass_deph_str in globals()

                    filename = bucket + '/TempBackups/' + token + "_" + entity + "_" + str(file_suffix) + '.json'
                    credsRetryParams = gcs.RetryParams(initial_delay=0.2,
                                       max_delay=5.0,
                                       backoff_factor=2,
                                       max_retry_period=15,
                                       urlfetch_timeout=30)

                    gcs_file = gcs.open(filename, 'r', retry_params=credsRetryParams)
                    items_from_backup = json.loads(gcs_file.read())
                    gcs_file.close()
                    items_from_backup = items_from_backup["items"]

                    atts = Helpers.list_ndb_attributes_for_class(entity)

                    items_to_restore = []

                    obj = {}
                    obj["type"] = new_fields[1]
                    obj["value"] = new_fields[2]
                    obj["name"] = new_fields[0]
                    for item_from_backup in items_from_backup:
                        item = eval(entity + "()")
                        for att in atts:
                            values_idx = -1
                            value_cnt = 0
                            while value_cnt < len(item_from_backup["values"]):
                                if item_from_backup["values"][value_cnt]["name"] == att:
                                    values_idx = value_cnt
                                    value_cnt = len(item_from_backup["values"])
                                value_cnt += 1

                            if values_idx >= 0:
                                Helpers.restore_ndb_property_from_string(item, att, item_from_backup["values"][values_idx])
                            else:
                                Helpers.restore_ndb_property_from_string(item, att, obj)

                        Helpers.restore_ndb_property_from_string(item, att, obj)
                        item.fund = "n/a"

                        items_to_restore.append(item)

                    #ndb.put_multi(items_to_restore)
                    for item_to_restore in items_to_restore:
                        item_to_restore.put()

                    template_values = {}
                    template_values["token"] = token
                    template_values["entity"] = entity
                    template_values["new_field"] = "|||".join(new_fields)
                    template_values["page"] = str(file_suffix + 1)

                    path = Helpers.get_html_path('cont_restore.html')
                    self.response.out.write(template.render(path, template_values))
                    return

                except gcs.NotFoundError:
                    self.response.out.write("Finished....(supposedly?)")
                    return

                #except:
                 #   self.response.out.write("error")
                  #  return

    elif self.request.get("fn") == "validate_password_reset_info":
        email = self.request.get("email")
        phone = self.request.get("rep_phone")
        rep_id = self.request.get("rep_id").upper()
        fname = self.request.get("rep_firstname").lower()
        lname = self.request.get("rep_lname").lower()
        users = FieldApplicationUser.query(
            ndb.AND(
                    FieldApplicationUser.rep_email == email,
                    FieldApplicationUser.rep_id == rep_id,
                    FieldApplicationUser.rep_phone == phone
                )
        )
        user_identifier = None
        success = False
        for user in users:
            try:
                if user.first_name.lower().index(fname) >= 0:
                    if user.last_name.lower().index(lname) >= 0:
                        success = True
                        user_identifier = user.identifier
                        keyy = "password_reset_token_out_for_" + user_identifier

                        val = memcache.get(keyy)
                        success = val is None
            except:
                success = False

        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["result"] = success
        if success:
            ret_json["identifier"] = user_identifier
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "send_password_reset_token":
        user_id = self.request.get("identifier")
        keyy = "password_reset_token_out_for_" + user_id
        val = memcache.get(keyy)

        if val is None:
            users = FieldApplicationUser.query(FieldApplicationUser.identifier == user_id)

            for user in users:
                memcache.set(key=keyy, value="foo", time=1200)
                token = hashlib.md5(str(int(time.time())) + "_" + user.identifier).hexdigest()
                keyy2 = "reset_token_for_" + user.identifier
                memcache.set(key=keyy2, value=token, time=1200)
                mail_body = user.first_name + " " + user.last_name + ",\n\n"
                mail_body += "You recently requested that your password be reset. If this was not initiated by you, please ignore the link below and inform management. To continue with the password reset process, please visit the following link within the next 20 minutes:\n\n"
                mail_body += "https://" + app_identity.get_application_id() + ".appspot.com/changepass" + "?token=" + token + "&identifier=" + user.identifier

                Helpers.send_email(user.rep_email, "Password Reset", mail_body)

    elif self.request.get("fn") == "check_password_reset_token":
        identifier = self.request.get("identifier")
        token = self.request.get("token")
        keyy = "reset_token_for_" + identifier
        val = memcache.get(keyy)
        ret_json = {}
        ret_json["success"] = False
        if not val is None:
            ret_json["success"] = (val == token)

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "get_apps_script_url":
        label = self.request.get("label")

        if label == "mailer":
            self.response.out.write(Helpers.get_apps_script_mailer_url())

        elif label == "docusign_forwarder":
            self.response.out.write(Helpers.get_apps_script_docusign_forwarder_url())

        elif label == "payscale_audit":
            self.response.out.write(Helpers.get_apps_script_payscale_audit_url())

        elif label == "rep_sp2_schedule":
            self.response.out.write(Helpers.get_apps_script_rep_sp2_schedule_url())

    elif self.request.get("fn") == "change_apps_script_url":
        label = self.request.get("label")
        new_url = self.request.get("value")
        if len(new_url) >= 35:

            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name

            filename = bucket + "/ApplicationSettings/apps_script_" + label + ".url"

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)

            gcs_file.write(str(new_url))
            gcs_file.close()
            memcache.delete("apps_script_url_for_" + label)

    elif self.request.get("fn") == "test_apps_script_template":
        template_vars = {}
        template_vars["cust_name"] = "CuStOmEr Name"
        template_vars["dayofweek"] = "Monday"
        template_vars["month_name"] = "Mahrch"
        template_vars["day"] = "13"
        template_vars["sp2_dayofweek"] = "Saturday"
        template_vars["sp2_month_name"] = "April"
        template_vars["sp2_day"] = "24"
        template_vars["sp2_hour"] = "5"
        template_vars["sp2_min"] = "30"
        template_vars["sp2_ampm"] = "PM"
        template_vars["rep_name"] = "Joe Schmoe"
        template_vars["rep_phone"] = "(831) 275-0754"

        Helpers.send_html_email("rnirnber@gmail.com", "Test Email", "field_form_cust_notify", template_vars)

    elif self.request.get("fn") == "validate_password_against_user_in_session":
        hashed_pass = Helpers.hash_pass(self.request.get("password"))
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        try:
            user_identifier = self.session["user_identifier"]

            users = FieldApplicationUser.query(FieldApplicationUser.identifier == user_identifier)
            for user in users:
                if user.password == hashed_pass:
                    ret_json["success"] = True

        except:
            ret_json = ret_json

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "set_password_for_user_in_session":
        hashed_pass = Helpers.hash_pass(self.request.get("password"))
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = True
        try:
            user_identifier = self.session["user_identifier"]

            users = FieldApplicationUser.query(FieldApplicationUser.identifier == user_identifier)
            for user in users:
                user.password = hashed_pass
                user.put()

        except:
            ret_json = ret_json

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "enumerate_surveys":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["surveys"] = []

        before_1970 = datetime(1969, 1, 1, 0, 0, 0)
        surveys = Survey.query(Survey.start_time > before_1970).order(Survey.start_time)
        for survey in surveys:
            item = {}
            item["identifier"] = survey.identifier
            item["name"] = survey.name

            #the start time

            sm = str(survey.start_time.month)
            if len(sm) == 1:
                sm = "0" + sm

            sd = str(survey.start_time.day)
            if len(sd) == 1:
                sd = "0" + sd

            sy = str(survey.start_time.year)

            smins = str(survey.start_time.minute)
            if len(smins) == 1:
                smins = "0" + smins

            shour = str(survey.start_time.hour)
            if len(shour) == 1:
                shour = "0" + shour

            start_time_str = sm + "-" + sd + "-" + sy + " " + shour + ":" + smins


            # the end time

            em = str(survey.end_time.month)
            if len(em) == 1:
                em = "0" + em

            ed = str(survey.end_time.day)
            if len(ed) == 1:
                ed = "0" + ed

            ey = str(survey.end_time.year)

            emins = str(survey.end_time.minute)
            if len(emins) == 1:
                emins = "0" + emins

            ehour = str(survey.end_time.hour)
            if len(ehour) == 1:
                ehour = "0" + ehour

            end_time_str = em + "-" + ed + "-" + ey + " " + ehour + ":" + emins


            item["start_time"] = start_time_str
            item["end_time"] = end_time_str

            if len(survey.question_identifiers) > 0:
                item["question_identifiers"] = survey.question_identifiers.split(",")
            else:
                item["question_identifiers"] = []

            item["activated"] = survey.activated
            item["is_trashed"] = survey.is_trashed
            item["anonymous"] = survey.anonymous


            ret_json["surveys"].append(item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_survey_triggers":
        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ActionManager.list_trigger_types()))

    elif self.request.get("fn") == "create_survey":
        start_time_vals = self.request.get("start_time").split("-")
        st = datetime(int(start_time_vals[2]), int(start_time_vals[0]), int(start_time_vals[1]), int(start_time_vals[3]), int(start_time_vals[4]), 0)

        end_time_vals = self.request.get("end_time").split("-")
        et = datetime(int(end_time_vals[2]), int(end_time_vals[0]), int(end_time_vals[1]), int(end_time_vals[3]), int(end_time_vals[4]), 0)

        survey = Survey(
            identifier=Helpers.guid(),
            name=self.request.get("name").strip(),
            start_time=st,
            end_time=et,
            question_identifiers="",
            activated=False,
            active_triggers=self.request.get("triggers"),
            is_trashed=False,
            anonymous =(self.request.get("anonymous") == "1")
        )

        survey.put()

    elif self.request.get("fn") == "update_survey_name":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.name = self.request.get("name")
            survey.put()


    elif self.request.get("fn") == "debug":
        b = SurveyBooking()
        b.foo = "bar"
        self.response.out.write(json.dumps(b.__dict__))

    elif self.request.get("fn") == "list_triggers_for_survey":
        self.response.content_type = "application/json"
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            triggers = json.loads(survey.active_triggers)
            self.response.out.write(json.dumps(triggers))

    elif self.request.get("fn") == "set_triggers_for_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.active_triggers = self.request.get("triggers")
            survey.put()

    elif self.request.get("fn") == "delete_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        with_content = (self.request.get("with_content") == "1")
        for survey in surveys:

            if with_content:
                with_content = with_content
                #survey_responses = SurveyResponse.query(SurveyResponse.survey_identifier == survey.identifier)
                #resp_ids_to_delete = []
                #for survey_response in survey_responses:
                    #resp_ids_to_delete.append(survey_response.identifier)

                #ndb.delete_multi(SurveyResponse.query(SurveyResponse.identifier.IN(resp_ids_to_delete)).fetch(999999, keys_only=True))

            survey.key.delete()

    elif self.request.get("fn") == "search_booking_for_survey_preview":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["result"] = None
        bookings = SurveyBooking.query(
            ndb.AND(
                SurveyBooking.name == self.request.get("cust_first") + " " + self.request.get("cust_last"),
                SurveyBooking.postal == self.request.get("cust_postal")
            )
        )
        for booking in bookings:
            ret_json["result"] = booking.identifier

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_questions_for_survey":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["questions"] = [];
        questions = SurveyQuestion.query(SurveyQuestion.survey_identifier == self.request.get("identifier")).order(SurveyQuestion.question_idx)
        for question in questions:
            item = {}
            item["identifier"] = question.identifier
            item["survey_identifier"] = question.survey_identifier
            item["question_text"] = question.question_text
            item["question_type"] = question.question_type
            item["question_layout"] = question.question_layout
            item["question_options"] = json.loads(question.question_options)
            item["question_idx"] = question.question_idx;
            item["dependency_identifier"] = question.dependency_identifier
            item["dependency_field"] = question.dependency_field
            item["dependent_value"] = question.dependent_value
            item["dependency_value_comp_mode"] = question.dependency_value_comp_mode

            item["dependency_value_type"] = question.dependency_value_type
            item["dependency_type"] = question.dependency_type

            ret_json["questions"].append(item);

        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))

        for survey in surveys:
            ret_json["survey_name"] = survey.name
            active_triggers = json.loads(survey.active_triggers)
            entity_trigger_count = 0

            for key in active_triggers.keys():

                for active_trigger in active_triggers[key]:

                    if active_trigger == "before_rep_completes_survey":
                        entity_trigger_count += 1

                    elif active_trigger == "after_rep_completes_survey":
                        entity_trigger_count += 1

                    elif active_trigger == "before_surveyor_updates_status_in_view":
                        entity_trigger_count += 1

                    elif active_trigger == "after_surveyor_updates_status_in_view":
                        entity_trigger_count += 1

                    elif active_trigger == "after_rep_completes_sp2":
                        entity_trigger_count += 1

                    else:
                        entity_trigger_count = entity_trigger_count


            ret_json["has_active_entity_triggers"] = (entity_trigger_count > 0)


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "deanonymize_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.anonymous = False
            survey.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "anonymize_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.anonymous = True
            survey.put()

    elif self.request.get("fn") == "set_question_text":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            question.question_text = self.request.get("text")
            question.put()

    elif self.request.get("fn") == "set_question_type":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            question.question_type = self.request.get("type")
            question.put()

    elif self.request.get("fn") == "create_blank_question":
        total = SurveyQuestion.query(SurveyQuestion.survey_identifier == self.request.get("survey_identifier")).count()

        question = SurveyQuestion(
            identifier=Helpers.guid(),
            survey_identifier=self.request.get("survey_identifier"),
            question_text="Untitled Question",
            question_type="n/a",
            question_layout="n/a",
            question_options=json.dumps({}),
            question_idx=total,
            dependency_identifier="n/a",
            dependency_field="n/a",
            dependent_value="n/a",
            dependency_value_type="n/a",
            dependency_value_comp_mode="n/a",
            dependency_type="n/a"
        )
        question.put()

    elif self.request.get("fn") == "delete_survey_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            idx = question.question_idx
            question.key.delete()

            questions_to_save = []
            next_questions = SurveyQuestion.query(SurveyQuestion.question_idx > idx)
            for next_question in next_questions:
                next_question.question_idx = next_question.question_idx - 1;
                questions_to_save.append(next_question)

            if len(questions_to_save) > 1:
                ndb.put_multi(questions_to_save)
            elif len(questions_to_save) > 0:
                questions_to_save[0].put()

    elif self.request.get("fn") == "set_format_for_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            question.question_layout = self.request.get("format")
            question.put()

    elif self.request.get("fn") == "get_question_type":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["type"] = None
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            ret_json["type"] = question.question_type

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "branch_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))

        for question in questions:
            question.dependency_identifier = self.request.get("parent_identifier")
            question.dependent_value = self.request.get("dependency_value")
            question.dependency_value_type = self.request.get("dependency_value_type")
            question.dependency_type = self.request.get("dependency_type")
            question.dependency_value_comp_mode = self.request.get("dependency_value_comp_mode")
            question.put()

    elif self.request.get("fn") == "proposal_designer_notes":
        self.response.content_type = "application/json"
        ret_json = {"notes": ""}

        prop_note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "notes_to_sales_rep"
            )
        )
        if not prop_note is None:
            ret_json["notes"] = json.loads(prop_note.content)["txt"][0]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "clear_branching":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            question.dependency_identifier = "n/a"
            question.dependency_field = "n/a"
            question.dependent_value = "n/a"
            question.dependency_value_type = "n/a"
            question.dependency_value_comp_mode = "n/a"
            question.dependency_type = "n/a"

            question.put()

    elif self.request.get("fn") == "adjust_dependent_values":
        new_vals = "|||||".join(json.loads(self.request.get("new_values")))
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            question.dependent_value = new_vals
            question.put()

        self.response.out.write(" ")


    elif self.request.get("fn") == "get_settings_for_question":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["settings"] = None
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            if question.dependent_value == "n/a":
                ret_json["dependent_values"] = None
            else:
                ret_json["dependent_values"] = question.dependent_value.split("|||||")

            if question.dependency_value_type == "n/a":
                ret_json["dependency_value_type"] = None
            else:
                ret_json["dependency_value_type"] = question.dependency_value_type

            if question.dependency_type == "n/a":
                ret_json["dependency_type"] = None
            else:
                ret_json["dependency_type"] = question.dependency_type

            if question.dependency_value_comp_mode == "n/a":
                ret_json["dependency_value_comp_mode"] = None
            else:
                ret_json["dependency_value_comp_mode"] = question.dependency_value_comp_mode

            ret_json["settings"] = json.loads(question.question_options)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_value_dependent_popup_to_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            opts = json.loads(question.question_options)

            if not ("popup_info" in opts.keys()):
                opts["popup_info"] = []

            popup_item = {}
            popup_item["dependent_value"] = self.request.get("dependent_value")
            popup_item["message"] = self.request.get("message")
            opts["popup_info"].append(popup_item)

            question.question_options = json.dumps(opts)
            question.put()

    elif self.request.get("fn") == "update_popup_text_for_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            opts = json.loads(question.question_options)

            try:
                opts["popup_info"][int(self.request.get("idx"))]["message"] = self.request.get("text")
                question.question_options = json.dumps(opts)
                question.put()
            except:
                questions = questions

    elif self.request.get("fn") == "remove_popup_for_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            opts = json.loads(question.question_options)

            try:
                del opts["popup_info"][int(self.request.get("idx"))]

                if len(opts["popup_info"]) == 0:
                    del opts["popup_info"]

                question.question_options = json.dumps(opts)
                question.put()
            except:
                opts = opts

    elif self.request.get("fn") == "publish_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.activated = True
            survey.put()

        self.response.out.write("")

    elif self.request.get("fn") == "unpublish_survey":
        surveys = Survey.query(Survey.identifier == self.request.get("identifier"))
        for survey in surveys:
            survey.activated = False
            survey.put()

        self.response.out.write("")

    elif self.request.get("fn") == "get_survey_booking_info":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["result"] = None
        bookings = SurveyBooking.query(SurveyBooking.identifier == self.request.get("identifier"))
        for booking in bookings:
            ret_json["result"] = {}
            ret_json["result"]["identifier"] = booking.identifier
            ret_json["result"]["postal"] = booking.postal
            ret_json["result"]["customer_postal"] = booking.postal
            ret_json["result"]["fund"] = booking.fund
            ret_json["result"]["trust_docs"] = booking.trust_docs
            ret_json["result"]["utility_provider"] = ""
            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier)
            for field_app in field_apps:
                ret_json["result"]["utility_provider"] = field_app.utility_provider
                ret_json["result"]["sp2_time"] = str(field_app.sp_two_time)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_choices_for_multi_choice_question":
        questions = SurveyQuestion.query(SurveyQuestion.identifier == self.request.get("identifier"))
        for question in questions:
            opts = json.loads(question.question_options)

            opts["multi_choices"] = []

            choices = self.request.get("choices").replace("\r", "").split("\n")
            for choice in choices:
                multi_choice_item = {}
                multi_choice_item["choice"] = choice
                opts["multi_choices"].append(multi_choice_item)

            question.question_options = json.dumps(opts)
            question.put()

    elif self.request.get("fn") == "record_survey_response":
        surveys = Survey.query(Survey.identifier == self.request.get("survey_identifier"))
        hidden_idents = []
        hidden_vals = []

        query_bookings = False
        query_field_apps = False
        sp2 = False
        anonymous = False

        q_ids = json.loads(self.request.get("identifiers"))
        q_vals = json.loads(self.request.get("vals"))

        if "textareahack" in q_ids:
            ta_idx = q_ids.index("textareahack")
            cancellation_reason = q_vals[ta_idx]
            cancelled_booking = SurveyBooking.first(SurveyBooking.identifier == self.request.get("booking_identifier"))

            notifications = Notification.query(Notification.action_name == "Customer Cancels Appointment")
            emails = []
            for notification in notifications:
                for notification_person in notification.notification_list:
                    emails.append(notification_person.email_address)

            for email in emails:
                Helpers.send_email(email, "Follow up on " + cancelled_booking.name + "'s Cancellation", "When asked why " + cancelled_booking.name + " cancelled, the surveyor provided the following response:\n\n" + cancellation_reason)


        for survey in surveys:
            anonymous = survey.anonymous
            active_triggers = json.loads(survey.active_triggers)
            keys = active_triggers.keys()

            for key in keys:
                if key == "survey":
                    for trigger in active_triggers[key]:
                        if trigger == "before_surveyor_updates_status_in_view":
                            query_bookings = True
                            query_field_apps = True

                        if trigger == "after_surveyor_updates_status_in_view":
                            query_bookings = True
                            query_field_apps = True
                if key == "field":
                    for trigger in active_triggers[key]:
                        if trigger == "after_rep_completes_sp2":
                            query_bookings = True
                            query_field_apps = True
                            sp2 = True

        booking_identifier_for_perfect_packet = ""
        field_app_identifier_for_perfect_packet = ""
        rep_identifier_for_perfect_packet = ""
        booking_state = None
        mosaic_id = None
        email_add = None
        if query_bookings:
            bookings = SurveyBooking.query(SurveyBooking.identifier == self.request.get("booking_identifier"))
            for booking in bookings:
                booking_identifier_for_perfect_packet = booking.identifier
                hidden_idents.append("SurveyBooking")
                hidden_vals.append(booking.identifier)
                booking_state = booking.state

                if query_field_apps:
                    if booking.has_associated_field_entry:
                        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier == booking.field_app_identifier)
                        for app_entry in app_entries:
                            hidden_idents.append("FieldApplicationEntry")
                            hidden_vals.append(app_entry.identifier)
                            field_app_identifier_for_perfect_packet = app_entry.identifier

                            email_add = app_entry.customer_email

                            mosaic_id = app_entry.customer_mosaic_id

                            users = FieldApplicationUser.query(FieldApplicationUser.rep_id == app_entry.rep_id)
                            for user in users:
                                rep_identifier_for_perfect_packet = user.identifier


        cancelled = (json.loads(self.request.get("vals"))[0] == "Cancel")

        response = SurveyResponse(
            identifier=Helpers.guid(),
            survey_identifier=self.request.get("survey_identifier"),
            user_identifier=self.session["user_identifier"],
            insert_time=Helpers.pacific_now(),
            question_identifiers=self.request.get("identifiers"),
            question_values=self.request.get("vals"),
            hidden_identifiers=json.dumps(hidden_idents),
            hidden_identifier_values=json.dumps(hidden_vals),
            anonymous_at_response_time=anonymous
        )
        response.put()

        if sp2:

            yesterday = Helpers.pacific_now()
            full_key = "sp2_follow_up_v2" + self.session["user_identifier"] + "_" + str(yesterday.year) + "_" + str(yesterday.month) + "_" + str(yesterday.day)
            saved_key = hashlib.md5(full_key).hexdigest()
            memcache.delete(saved_key)

        else:

            if query_bookings and query_field_apps and (not cancelled):
                outstandinggg_items = []
                q_vals = json.loads(self.request.get("vals"))
                q_identifiers = json.loads(self.request.get("identifiers"))
                if q_vals[2] == "0":
                    outstandinggg_items.append(q_identifiers[2])
                if q_vals[3] == "0":
                    outstandinggg_items.append(q_identifiers[3])

                #pp_entry = PerfectPacketEntry(
                    #identifier=Helpers.guid(),
                    #booking_identifier=booking_identifier_for_perfect_packet,
                    #field_application_identifier=field_app_identifier_for_perfect_packet,
                    #surveyor_identifier=self.session["user_identifier"],
                    #surveyor_completion_state=1,
                    #surveyor_completion_date=Helpers.pacific_now(),
                    #rep_identifier=rep_identifier_for_perfect_packet,
                    #rep_completion_state=0,
                    #rep_completion_date=datetime(1970, 1, 1),
                    #outstanding_items=json.dumps(outstandinggg_items),
                    #created=Helpers.pacific_now(),
                    #archived=False,
                    #save_me=False
                #)
                #pp_entry.put()

                if not mosaic_id == -1 and not mosaic_id is None and not email_add is None:
                    #ip = Helpers.get_mosaic_ip()
                    #urll = "http://" + ip + "/insert_job.php"

                    new_job = {}
                    new_job["token"] = Helpers.guid()
                    new_job["job_type"] = "switch_emails"
                    new_job["actual_email"] = email_add
                    new_job["identifier"] = new_job["token"]
                    new_job["min_time"] = 5
                    new_job["opportunity_id"] = mosaic_id

                    form_fields = {}
                    form_fields["json"] = json.dumps(new_job)

    #                try:
                        #resp6 = urlfetch.fetch(
                        #    url=urll,
                        #    method=urlfetch.POST,
                        #    payload=urllib.urlencode(form_fields),
                        #    deadline=20,
                        #    headers = {
                        #        'Content-Type': 'application/x-www-form-urlencoded'
                        #    }
                        #)
    #                except:
                        #logging.info("couldn't hit mosaic w/reset email stuff")


            if (not str(self.request.get("packet_identifier")) == "") and (not str(self.request.get("packet_identifier")).lower() == "none"):
                packet_entries = PerfectPacketEntry.query(PerfectPacketEntry.identifier == self.request.get("packet_identifier"))
                for packet_entry in packet_entries:
                    packet_entry.rep_completion_state = 1
                    packet_entry.rep_completion_date = Helpers.pacific_now()
                    packet_entry.put()

                    empty_rejection_reasons = {}
                    empty_rejection_reasons["reasons"] = []
                    empty_rejection_reasons["dates"] = []
                    empty_rejection_reasons["responses"] = []
                    empty_rejection_reasons["response_dates"] = []

                    pp_submission = PerfectPacketSubmission(
                        identifier=Helpers.guid(),
                        archived=False,
                        packet_entry_identifier=self.request.get("packet_identifier"),
                        booking_identifier=packet_entry.booking_identifier,
                        field_application_identifier=packet_entry.field_application_identifier,
                        surveyor_identifier=packet_entry.surveyor_identifier,
                        rep_identifier=packet_entry.rep_identifier,
                        rep_submission_date=Helpers.pacific_now(),
                        approved=False,
                        approval_date=datetime(1970, 1, 1, 0, 0),
                        rejected=False,
                        last_rejection_date=datetime(1970, 1, 1, 0, 0),
                        rejection_reasons=json.dumps(empty_rejection_reasons),
                        save_me=False
                    )
                    pp_submission.put()

                    try:
                        app_usr = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_submission.rep_identifier)
                        if not app_usr is None:
                            Helpers.increment_tally_for_user(app_usr.rep_id, "packets_submitted")

                    except:
                        logging.info("Couldn't record user submitting packet tally thingy")


    elif self.request.get("fn") == "set_friendly_name_for_office_su":
        o_locations = OfficeLocation.query(OfficeLocation.identifier == self.request.get("identifier"))
        for o in o_locations:
            o.name = self.request.get("new_name")
            o.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "count_held_customers_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["count"] = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.has_holds == True,
                FieldApplicationEntry.rep_id == self.session["user_rep_id"]
            )
        ).count()
        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "count_perfect_packets_for_user":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["count"] = PerfectPacketEntry.query(
            ndb.AND(
                PerfectPacketEntry.rep_identifier == self.session["user_identifier"],
                PerfectPacketEntry.rep_completion_state == 0,
                PerfectPacketEntry.archived == False,
                PerfectPacketSubmission.save_me == False
            )
        ).count()

        ret_json["rejection_count"] = PerfectPacketSubmission.query(
            ndb.AND(
                PerfectPacketSubmission.rep_identifier == self.session["user_identifier"],
                PerfectPacketSubmission.approved == False,
                PerfectPacketSubmission.rejected == True,
                PerfectPacketSubmission.archived == False,
                PerfectPacketSubmission.save_me == False
            )
        ).count()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_perfect_packets_for_user":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []

        packet_entries = PerfectPacketEntry.query(
            ndb.AND
            (
                PerfectPacketEntry.rep_identifier == self.session["user_identifier"],
                PerfectPacketEntry.rep_completion_state == 0,
                PerfectPacketEntry.archived == False
            )
        ).order(-PerfectPacketEntry.created)


        field_app_ids = []
        field_app_ids.append("-1")
        packet_identifier_field_app_identifier_dict = {}
        field_app_identifier_packet_identifier_dict = {}
        packet_identifier_outstanding_items_map = {}
        packet_identifier_created_map = {}

        for packet_entry in packet_entries:
            if not packet_entry.save_me:
                field_app_ids.append(packet_entry.field_application_identifier)
                packet_identifier_field_app_identifier_dict[packet_entry.identifier] = packet_entry.field_application_identifier
                field_app_identifier_packet_identifier_dict[packet_entry.field_application_identifier] = packet_entry.identifier
                outstanding_items = json.loads(packet_entry.outstanding_items)
                packet_identifier_outstanding_items_map[packet_entry.identifier] = (len(outstanding_items) > 0)
                packet_identifier_created_map[packet_entry.identifier] = date(packet_entry.created.year, packet_entry.created.month, packet_entry.created.day)



        packet_identifier_cust_name_dict = {}
        packet_identifier_booking_time_map = {}
        app_identifier_booking_time_map = {}
        app_identifier_booking_identifier_dict = {}

        booking_ids = []
        booking_ids.append("-1")
        booking_identifier_packet_identifier_map = {}
        packet_identifier_booking_identifier_map = {}
        field_app_identifier_cust_name_dict = {}
        field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids))
        for field_app in field_apps:
            field_app_identifier_cust_name_dict[field_app.identifier] = field_app.customer_first_name + " " + field_app.customer_last_name
            packet_identifier_cust_name_dict[field_app_identifier_packet_identifier_dict[field_app.identifier]] = field_app.customer_first_name + " " + field_app.customer_last_name
            booking_ids.append(field_app.booking_identifier)
            booking_identifier_packet_identifier_map[field_app.booking_identifier] = field_app_identifier_packet_identifier_dict[field_app.identifier]
            packet_identifier_booking_identifier_map[field_app_identifier_packet_identifier_dict[field_app.identifier]] = field_app.booking_identifier

        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids))
        for booking in bookings:
            packet_identifier_booking_time_map[booking_identifier_packet_identifier_map[booking.identifier]] = date(booking.booking_year, booking.booking_month, booking.booking_day)
            app_identifier_booking_time_map[booking.field_app_identifier] = date(booking.booking_year, booking.booking_month, booking.booking_day)
            app_identifier_booking_identifier_dict[booking.field_app_identifier] = booking.identifier

        for key in packet_identifier_field_app_identifier_dict.keys():
            item = {}
            item["identifier"] = key
            item["field_app_identifier"] = packet_identifier_field_app_identifier_dict[key]
            try:
                item["name"] = packet_identifier_cust_name_dict[key]
            except:
                item["name"] = field_app_identifier_cust_name_dict[item["field_app_identifier"]]
            try:
                item["survey_date"] = str(packet_identifier_booking_time_map[key])
            except:
                item["survey_date"] = str(app_identifier_booking_time_map[item["field_app_identifier"]])
            item["surveyor_date"] = str(packet_identifier_created_map[key])
            item["has_outstanding_items"] = packet_identifier_outstanding_items_map[key]
            try:
                item["booking_identifier"] = packet_identifier_booking_identifier_map[key]
            except:
                item["booking_identifier"] = app_identifier_booking_identifier_dict[item["field_app_identifier"]]

            ret_json["packets"].append(item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_rejected_packets_for_user":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []

        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.rep_identifier == self.session["user_identifier"],
                PerfectPacketSubmission.rejected == True,
                PerfectPacketSubmission.approved == False,
                PerfectPacketSubmission.archived == False
            )
        ).order(PerfectPacketSubmission.last_rejection_date)

        booking_ids_to_query = []
        booking_ids_to_query.append("-1")
        for pp_sub in pp_subs:
            packet_item = {}

            packet_item["booking_identifier"] = pp_sub.booking_identifier
            packet_item["identifier"] = pp_sub.identifier
            packet_item["packet_entry_identifier"] = pp_sub.packet_entry_identifier
            packet_item["name"] = ""
            packet_item["rep_submission_date"] = str(date(pp_sub.rep_submission_date.year, pp_sub.rep_submission_date.month, pp_sub.rep_submission_date.day))
            packet_item["last_rejection_date"] = str(date(pp_sub.last_rejection_date.year, pp_sub.last_rejection_date.month, pp_sub.last_rejection_date.day))
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)

            ret_json["packets"].append(packet_item)

            booking_ids_to_query.append(packet_item["booking_identifier"])

        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
        booking_identifier_cust_name_dict = {}

        for booking in bookings:
            booking_identifier_cust_name_dict[booking.identifier] = booking.name


        for packet in ret_json["packets"]:
            if packet["booking_identifier"] in booking_identifier_cust_name_dict.keys():
                packet["name"] = booking_identifier_cust_name_dict[packet["booking_identifier"]]

        self.response.out.write(json.dumps(ret_json))




    elif self.request.get("fn") == "archive_perfect_packet_item":
        packets = PerfectPacketEntry.query(PerfectPacketEntry.identifier == self.request.get("identifier"))
        is_entry = False
        for packet in packets:
            packet.archived = True
            packet.put()
            is_entry = True

        if not is_entry:
            subs = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == self.request.get("identifier"))
            for sub in subs:
                sub.archived = True
                sub.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "archive_customer":
        Helpers.archive_state(self.request.get("identifier"))
        

    elif self.request.get("fn") == "unarchive_customer":
        for entity_results in [FieldApplicationEntry.query(FieldApplicationEntry.identifier == self.request.get("identifier")),
                               SurveyBooking.query(SurveyBooking.field_app_identifier == self.request.get("identifier")),
                               PerfectPacketEntry.query(PerfectPacketEntry.field_application_identifier == self.request.get("identifier")),
                               PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier")),
                               PerfectPacketApproval.query(PerfectPacketApproval.field_application_identifier == self.request.get("identifier")),
                               CustomerProgressItem.query(CustomerProgressItem.field_app_identifier == self.request.get("identifier")),
                               PayrollCustomerState.query(PayrollCustomerState.field_app_identifier == self.request.get("identifier")),
                               Lead.query(Lead.field_app_identifier == self.request.get("identifier"))
                               ]:
            for entity in entity_results:
                entity.archived = False
                entity.has_holds = False
                entity.hold_items = "[]"
                entity.put()

    elif self.request.get("fn") == "set_holds_for_customer":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        app_entry.archived = False
        app_entry.has_holds = True
        app_entry.hold_items = self.request.get("holds")
        app_entry.put()



    elif self.request.get("fn") == "get_perfect_packet":
        self.response.content_type = "application/json"
        ret_json = {}
        packets = PerfectPacketEntry.query(PerfectPacketEntry.identifier == self.request.get("identifier"))
        for packet in packets:
            ret_json["identifier"] = packet.identifier
            outstanding_items = json.loads(packet.outstanding_items)
            ret_json["has_outstanding_items"] = (len(outstanding_items) > 0)
            if ret_json["has_outstanding_items"]:
                ret_json["outstanding_questions"] = []

                questions = SurveyQuestion.query(SurveyQuestion.identifier.IN(outstanding_items)).order(SurveyQuestion.question_idx)
                for question in questions:
                    q_item = {}
                    q_item["identifier"] = question.identifier
                    ret_json["survey_identifier"] = question.survey_identifier
                    q_item["text"] = question.question_text
                    q_item["layout"] = question.question_layout
                    q_item["idx"] = question.question_idx
                    q_item["options"] = json.loads(question.question_options)
                    q_item["type"] = question.question_type
                    ret_json["outstanding_questions"].append(q_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_outstanding_items_for_packet":
        packets = PerfectPacketEntry.query(PerfectPacketEntry.identifier == self.request.get("identifier"))
        for packet in packets:
            packet.outstanding_items = self.request.get("new_items")
            packet.put()

    elif self.request.get("fn") == "approve_perfect_packet":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        cust_name = "customer name"
        pp_submissions = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        pp_sub = None
        packet_entry = None
        for pp_submission in pp_submissions:
            pp_submission.rejected = False
            pp_submission.approved = True
            pp_submission.approval_date = Helpers.pacific_now()
            pp_sub = pp_submission

        booking_dt = None
        booking_fund = None
        bookingg = None
        bookings = SurveyBooking.query(SurveyBooking.identifier == pp_sub.booking_identifier)
        for booking in bookings:
            booking_dt = datetime(booking.booking_year, booking.booking_month, booking.booking_day)
            cust_name = booking.name
            booking_fund = booking.fund
            bookingg = booking

        proposal = None
        a_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
        if (not bookingg is None) and (not a_entry is None):
            proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == bookingg.field_app_identifier)



        if (not proposal is None) and (not pp_sub is None) and (not booking_dt is None) and (not booking_fund == "") and (not booking_fund == "n/a") and (PerfectPacketApproval.first(PerfectPacketApproval.packet_submission_identifier == pp_sub.identifier) is None):
            p_dict = json.loads(proposal.info)
            sys_size = float(p_dict["system_size"])

            panel_qty = None
            wattage = None
            panel_type = None
            if "panel_qty" in p_dict.keys():
                panel_qty = float(p_dict["panel_qty"])

            if "new_panel_qty" in p_dict.keys() and "panel_qty_override" in p_dict.keys():
                panel_qty = float(p_dict["new_panel_qty"])

            if "panel_type" in p_dict.keys():
                panel_type = p_dict["panel_type"]

            if not panel_type is None:
                if "[[[" in panel_type:
                    wattage = panel_type[panel_type.index("[[["):]
                    wattage = wattage.replace("[[[", "").replace("]]]", "")
                    wattage = float(wattage)
                else:
                    opts = Helpers.read_setting("system_options")
                    opts = opts["panels"]
                    for opt in opts:
                        if opt[0:opt.index("[[[")] == panel_type:
                            wattage = opt[opt.index("[[["):]
                            wattage = wattage.replace("[[[", "").replace("]]]", "")
                            wattage = float(wattage)

            if (not panel_qty is None) and (not wattage is None):
                sys_size = float(panel_qty * wattage)
                sys_size /= float(1000)

            if (not str(self.request.get("system_size")) == "") and (not str(self.request.get("system_size")).lower() == "none") and (not str(self.request.get("system_size")) == "abc"):
                sys_size = float(self.requset.get("system_size"))

            if not sys_size is None:

                d_vals = self.request.get("approval_date").split("-")
                pp_approval = PerfectPacketApproval(
                    identifier=Helpers.guid(),
                    packet_submission_identifier=pp_sub.identifier,
                    packet_entry_identifier=pp_sub.packet_entry_identifier,
                    booking_identifier=pp_sub.booking_identifier,
                    field_application_identifier=pp_sub.field_application_identifier,
                    rep_identifier=pp_sub.rep_identifier,
                    surveyor_identifier=pp_sub.surveyor_identifier,
                    approval_date=datetime(int(d_vals[2]), int(d_vals[0]), int(d_vals[1]), 0, 0, 1),
                    rep_submission_date=pp_sub.rep_submission_date,
                    survey_date=booking_dt,
                    system_size=str(sys_size),
                    progress_closed=False,
                    archived=False,
                    save_me=False
                )

                #get the payscale key to which the rep is tied
                payscale_key = None
                rep_name2 = ""
                reps = FieldApplicationUser.query(FieldApplicationUser.identifier == pp_approval.rep_identifier)
                the_rep = None
                for rep in reps:
                    payscale_key = rep.payscale_key
                    rep_name2 = rep.first_name.strip() + " " + rep.last_name.strip()
                    the_rep = rep

                if not payscale_key is None:
                    #get the friendly name of the fund

                    friendly_fund_name = ""
                    funds = Helpers.list_funds()
                    for fund in funds:
                        if fund["value"] == booking_fund:
                            friendly_fund_name = fund["value_friendly"]

                    #get the funding_group_info
                    fund_group_info = {}
                    fund_group_info["value"] = "unassigned"
                    fund_group_info["value_friendly"] = "Unassigned"

                    funding_groups = Helpers.list_funding_groups()
                    g_name_keys = funding_groups["group_items"].keys()

                    for g_name_key in g_name_keys:
                        items = funding_groups["group_items"][g_name_key]

                        for item in items:
                            if item == booking_fund:

                                fund_group_info["value"] = g_name_key
                                for name in funding_groups["group_names"]:
                                    if name["value"] == g_name_key:

                                        fund_group_info["value_friendly"] = name["value_friendly"]

                    if not fund_group_info["value"] == "unassigned":
                        payscales = Helpers.list_payscales()
                        friendly_name_of_payscale = None
                        commission_kwh_price = None
                        commission_tier_option = None

                        field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier == pp_approval.field_application_identifier)
                        for field_app in field_apps:
                            commission_kwh_price = field_app.customer_kwh_price
                            commission_tier_option = field_app.tier_option
                            if commission_tier_option == "n/a":
                                commission_tier_option = "A"

                        payscale_idx = -1
                        cnt = 0
                        for payscale in payscales:
                            if payscale["value"] == payscale_key:
                                friendly_name_of_payscale = payscale["value_friendly"]
                                payscale_idx = cnt

                            cnt += 1

                        if (not friendly_name_of_payscale is None) and (not commission_kwh_price is None) and (not commission_tier_option is None) and (not payscale_idx == -1):
                            price_per_kwh_at_sys_size = None
                            price_per_kwh_at_sys_size_str = None

                            for scale in payscales[payscale_idx]["scales"]:
                                if scale["tier"] == commission_tier_option:
                                    if scale["funding_group"] == fund_group_info["value"]:
                                        price_per_kwh_at_sys_size = float(scale["price"])
                                        price_per_kwh_at_sys_size_str = str(scale["price"])

                                        try:
                                            idx = price_per_kwh_at_sys_size_str.index(".")

                                            if idx == len(price_per_kwh_at_sys_size_str) - 2:
                                                price_per_kwh_at_sys_size_str += "0"

                                        except:
                                            price_per_kwh_at_sys_size_str += ".00"

                            if (not price_per_kwh_at_sys_size is None) and (not price_per_kwh_at_sys_size_str is None):
                                s_s = float(sys_size)
                                multiplier = float(price_per_kwh_at_sys_size)
                                total = s_s * multiplier

                                e_info = json.loads(pp_sub.extra_info)
                                e_description = ""
                                closer_mt = None
                                closer_obj = None
                                if "closer" in e_info.keys():
                                    closer = FieldApplicationUser.first(FieldApplicationUser.identifier == e_info["closer"])
                                    closer_obj = closer
                                    if not closer is None:
                                        total -= float(float(s_s) * float(100))
                                        e_description = " There was also an offset of $100/kw because " + closer.first_name.strip() + " " + closer.last_name.strip() + " was annotated as the deal's closer."

                                        closers_total = sys_size * float(100)
                                        closers_total *= 0.5
                                        closers_total_in_cents = int(closers_total * 100)
                                        closers_dollar_total = closers_total_in_cents / 100
                                        closers_cents_total = closers_total_in_cents % 100

                                        closer_mt = MonetaryTransaction(
                                            identifier=Helpers.guid(),
                                            recorded_by=self.session["user_identifier"],
                                            description="First closing bonus for " + cust_name + ". (You helped " + rep_name2 + " sell a " + str(sys_size) + " KW system).",
                                            description_key="closers_bonus_A",
                                            recorded_dt=Helpers.pacific_now(),
                                            paid=False,
                                            recipient=closer.identifier,
                                            dollars=closers_dollar_total,
                                            cents=closers_cents_total,
                                            tax_applicable=True,
                                            approved=True,
                                            denied=False,
                                            extra_info="{}"
                                        )
                                semi_final_total = total * 0.50
                                total_in_cents = int(semi_final_total * 100)
                                dollars_total = total_in_cents / 100
                                cents_total = total_in_cents % 100

                                descrip = "Part 1 Commission @ 50% for " + cust_name
                                descrip += ".\n\n"
                                descrip += "System size was "
                                descrip += str(sys_size)
                                descrip += ", total commission at Tier "
                                descrip += commission_tier_option
                                descrip += " was configured at $"
                                descrip += price_per_kwh_at_sys_size_str
                                descrip += "/kw. This configuration was based off of your membership in the payscale group called '"
                                descrip += friendly_name_of_payscale
                                descrip += "', and the customer's credit/funding source being marked as '"
                                descrip += friendly_fund_name
                                descrip += "'."
                                descrip += e_description

                                c_num = Helpers.get_check_number_for_transaction(pp_approval.rep_identifier, 1)

                                mt = MonetaryTransaction(
                                    identifier=Helpers.guid(),
                                    recorded_by=self.session["user_identifier"],
                                    description=descrip,
                                    description_key="rep_sales_commission_1A",
                                    recorded_dt=Helpers.pacific_now(),
                                    effective_dt=datetime(1970, 1, 1),
                                    paid=False,
                                    recipient=pp_approval.rep_identifier,
                                    dollars=dollars_total,
                                    cents=cents_total,
                                    tax_applicable=True,
                                    check_number=c_num,
                                    approved=True,
                                    denied=False,
                                    extra_info="{}"
                                )
                                pp_approval.put()
                                Helpers.set_commission_payout(mt)

                                if not closer_mt is None:
                                    closer_mt.check_number = Helpers.get_check_number_for_transaction(closer_obj.identifier, 1)
                                    Helpers.set_commission_payout(closer_mt)
                                    Helpers.send_sms(closer_obj.rep_phone, "Cha-Ching! A bonus of $" + str(closer_mt.dollars) + "." + str(closer_mt.cents) + " for closing a deal has been posted for next week's paycheck.")

                                n = datetime.now()
                                n_minus_1 = n + timedelta(hours=-1)

                                gcs_filez = [
                                    GCSLockedFile("/CustomerProgressCache/pp_pending_approval_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json"),
                                    GCSLockedFile("/CustomerProgressCache/pp_pending_approval_" + str(n_minus_1.year) + "_" + str(n_minus_1.month) + "_" + str(n_minus_1.day) + "_" + str(n_minus_1.hour) + ".json")
                                ]

                                for gcs_file in gcs_filez:
                                    data = gcs_file.read(True)
                                    if not data is None:
                                        entries = json.loads(data)
                                        idx_to_remove = -1
                                        cnt = -1
                                        for entry in entries:
                                            cnt += 1
                                            if entry["field_app_identifier"] == pp_approval.field_application_identifier:
                                                idx_to_remove = cnt
                                                break

                                        if not idx_to_remove == -1:
                                            del entries[idx_to_remove]
                                        gcs_file.unlock()
                                        gcs_file.write(json.dumps(entries), "text/plain", "public-read")
                                    else:
                                        gcs_file.unlock()

                                gcs_filez = [
                                    GCSLockedFile("/CustomerProgressCache/perm_sub_pending_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json"),
                                    GCSLockedFile("/CustomerProgressCache/perm_sub_pending_" + str(n_minus_1.year) + "_" + str(n_minus_1.month) + "_" + str(n_minus_1.day) + "_" + str(n_minus_1.hour) + ".json")
                                ]

                                for gcs_file in gcs_filez:
                                    data = gcs_file.read(True)
                                    if not data is None:
                                        entries = json.loads(data)

                                        item_dict = {}
                                        item_dict["identifier"] = pp_approval.identifier
                                        item_dict["date"] = {}
                                        item_dict["date"]["year"] = pp_approval.approval_date.year
                                        item_dict["date"]["month"] = pp_approval.approval_date.month
                                        item_dict["date"]["day"] = pp_approval.approval_date.day
                                        item_dict["name"] = cust_name
                                        item_dict["step_key"] = "perm_sub_pending"
                                        item_dict["booking_identifier"] = pp_approval.booking_identifier
                                        item_dict["field_app_identifier"] = pp_approval.field_application_identifier

                                        item_dict["rejected"] = False
                                        item_dict["submission_identifier"] = pp_approval.packet_submission_identifier

                                        entries.append(item)

                                        gcs_file.unlock()
                                        gcs_file.write(json.dumps(entries), "text/plain", "public-read")
                                    else:
                                        gcs_file.unlock()

                                ret_json["success"] = True
                                pp_sub.put()
                                repp = FieldApplicationUser.first(FieldApplicationUser.rep_id == a_entry.rep_id)
                                if not repp is None:
                                    CustomerTranscriber.transcribe(a_entry, repp, "approve_perfect_packet")

        if not ret_json["success"]:
            ret_json["reason"] = None
            if not (pp_sub is None) and (not bookingg is None):
                r_id = bookingg.associated_rep_id
                usrs = FieldApplicationUser.query(FieldApplicationUser.rep_id == r_id)
                for usr in usrs:
                    p_key = usr.payscale_key
                    if p_key.lower() == "n/a":
                        ret_json["reason"] = "missing_payscale"

                if ret_json["reason"] is None:
                    if bookingg.fund.lower() == "n/a":
                        ret_json["reason"] = "missing_fund"

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "test_pp_date_logic":
        if str(self.request.get("post")) == "1":
            log_str = ""
            pp_approval = PerfectPacketApproval()
            pp_approval.rep_submission_date = datetime(int(self.request.get("sub_year")), int(self.request.get("sub_month")), int(self.request.get("sub_day")), 1, 0, 0, 2)
            log_str += "Submission Date: " + str(pp_approval.rep_submission_date) + "\n"

            faked_rej_json = "{\"reasons\": [], \"response_dates\": [], \"dates\": [], \"responses\": []}"
            if self.request.get("included_rej_dt") == "1":
                log_str += "Included rejection date...\n"
                r_dt = datetime(int(self.request.get("rej_year")), int(self.request.get("rej_month")), int(self.request.get("rej_day")), 1, 0, 0, 2)
                log_str += "Rejection Date: " + str(r_dt) + "\n"
                faked_rej_json = "{\"reasons\": [], \"response_dates\": [\"" + str(r_dt) + "\"], \"dates\": [], \"responses\": []}"

            pp_sub = PerfectPacketSubmission()
            pp_sub.rejection_reasons = faked_rej_json

            log_str += "Rep Sub DT equaling pp approval's rep sub dt'\n"
            rep_sub_dt = pp_approval.rep_submission_date
            log_str += str(rep_sub_dt)
            rej_jistory = json.loads(pp_sub.rejection_reasons)
            log_str += str(rej_jistory)

            if len(rej_jistory["response_dates"]) > 0:
                log_str += "Response Date Found...\n"
                jistory_len = len(rej_jistory["response_dates"])
                last_rej_dt_str = rej_jistory["response_dates"][jistory_len - 1]
                rep_sub_dt = Helpers.string_to_datetime(last_rej_dt_str)
                log_str += "Changed rep sub dt to \n" + str(rep_sub_dt) + "\n"
            else:
                log_str += "No response dates...\n"


            n = Helpers.pacific_now()
            log_str += "Now Time: " + str(n) + "\n"

            if self.request.get("faked_today") == "1":
                n = datetime(int(self.request.get("today_year")), int(self.request.get("today_month")), int(self.request.get("today_day")), 1, 0, 0, 2)
                log_str += "'Now' was changed to " + str(n) + "\n"
            else:
                log_str += "Today was real, not faked...\n"

            log_str += "Friday count at 0\n"
            fri_count = 0
            while fri_count < 2:
                log_str += "Friday count is less than 2\n"
                wd = rep_sub_dt.isoweekday()
                log_str += "ISO weekday: " + str(wd) + "\n"
                if wd == 5:
                    log_str += "It's five, incrementing friday count\n"
                    fri_count += 1
                else:
                    "Not five yet...\n"

                if not fri_count == 2:
                    rep_sub_dt = rep_sub_dt + timedelta(days=1)
                    log_str += "Incrementing rep_sub_dt by 1, value is now: " + str(rep_sub_dt) + "\n"
                else:
                    log_str += "OK Friday count is at 2 now...\n"

            log_str += "Determing eff_d\n"
            eff_d = None
            if rep_sub_dt < n:
                log_str += "rep sub dt is less than now, setting eff_d to 'now'.\n"
                eff_d = Helpers.string_to_datetime(str(n))

                if eff_d.isoweekday() == 5:
                    log_str += "Eff d had an iso weekday of five right here, so bumping up by one day...\n"
                    eff_d = eff_d + timedelta(days=1)
                    log_str += "After bumping up, value is now: " + str(eff_d) + "\n"

                else:
                    log_str += "Eff d does NOT have an iso weekday of five right here\n"
            else:
                log_str += "Rep sub dt is NOT less than 'now', therefore the final rep_sub_dt is now equal to eff_d\n"
                log_str += "eff_d = " + str(rep_sub_dt) + "\n"
                eff_d = Helpers.string_to_datetime(str(rep_sub_dt))

            eff_d = eff_d + timedelta(days=-6)

            paycheck_date = Helpers.string_to_datetime(str(eff_d))
            fri_count = 0
            while fri_count < 2:
                wd = paycheck_date.isoweekday()
                if wd == 5:
                    fri_count += 1

                if not fri_count == 2:
                    paycheck_date = paycheck_date + timedelta(days=1)


            p_date = Helpers.string_to_datetime(str(eff_d))

            dub_d = p_date.isoweekday()
            while not dub_d == 5:
                p_date = p_date + timedelta(days=1)
                dub_d = p_date.isoweekday()

            self.response.content_type = "text/plain"
            self.response.out.write("Payout Date: " + str(p_date.date()) + "\n\n\n")#

        else:
            template_values = {}
            path = Helpers.get_html_path('test_pp_logic.html')
            self.response.out.write(template.render(path, template_values))



    elif self.request.get("fn") == "reject_perfect_packet":
        delimited = (str(self.request.get("delimited")) == "1")
        jaysawn = (str(self.request.get("json")) == "1")

        pp_submissions = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        for pp_submission in pp_submissions:
            rejection_reasons = json.loads(pp_submission.rejection_reasons)

            if delimited:
                delimiter = self.request.get("delimiter")
                reasons = self.request.get("reasons").split(delimiter)
                rejection_reasons["reasons"] = reasons

            elif jaysawn:
                rejection_reasons["reasons"].append(json.loads(self.request.get("reasons")))
                rejection_reasons["dates"].append(str(Helpers.pacific_now()))
            else:
                logging.info("something unexpected...kk")

            if len(rejection_reasons["reasons"]) > 0:
                pp_submission.rejected = True
                pp_submission.approved = False
                pp_submission.rejection_reasons = json.dumps(rejection_reasons)
                pp_submission.last_rejection_date = Helpers.pacific_now()
                pp_submission.put()

                a_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_submission.field_application_identifier)
                if not a_entry is None:
                    notification = Notification.first(Notification.action_name == "Packet Rejected")
                    if not notification is None:
                        for person in notification.notification_list:
                            Helpers.send_email(person.email_address, "Rejected Packet",
                                               "The packet for " + a_entry.customer_first_name.strip().title() + " " + a_entry.customer_last_name.strip().title() + " was rejected.")

                    usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == a_entry.rep_id)
                    if not usr is None:
                        CustomerTranscriber.transcribe(a_entry, usr, "pp_rejected_pending_resubmission")

                n = datetime.now()
                n_minus_1 = n + timedelta(hours=-1)

                gcs_filez = [
                    GCSLockedFile("/CustomerProgressCache/pp_pending_approval_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json"),
                    GCSLockedFile("/CustomerProgressCache/pp_pending_approval_" + str(n_minus_1.year) + "_" + str(n_minus_1.month) + "_" + str(n_minus_1.day) + "_" + str(n_minus_1.hour) + ".json")
                ]

                for gcs_file in gcs_filez:
                    data = gcs_file.read(True)
                    if not data is None:
                        entries = json.loads(data)
                        idx_to_remove = -1
                        cnt = -1
                        for entry in entries:
                            cnt += 1
                            if entry["field_app_identifier"] == pp_submission.field_application_identifier:
                                idx_to_remove = cnt
                                break

                        if not idx_to_remove == -1:
                            del entries[idx_to_remove]

                        gcs_file.unlock()
                        gcs_file.write(json.dumps(entries), "text/plain", "public-read")

                    else:
                        gcs_file.unlock()

                gcs_filez = [
                    GCSLockedFile("/CustomerProgressCache/pp_rejected_pending_resubmission" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json"),
                    GCSLockedFile("/CustomerProgressCache/pp_rejected_pending_resubmission" + str(n_minus_1.year) + "_" + str(n_minus_1.month) + "_" + str(n_minus_1.day) + "_" + str(n_minus_1.hour) + ".json")
                ]

                for gcs_file in gcs_filez:
                    data = gcs_file.read(True)
                    if not data is None:
                        entries = json.loads(data)

                        pp_entrees = PerfectPacketEntry.query(PerfectPacketEntry.packet_submission_identifier == pp_submission.identifier)

                        for pp_entree in pp_entrees:
                            item_dict = {}
                            item_dict["identifier"] = pp_entree.identifier
                            item_dict["date"] = {}
                            item_dict["date"]["year"] = pp_entree.rep_completion_date.year
                            item_dict["date"]["month"] = pp_entree.rep_completion_date.month
                            item_dict["date"]["day"] = pp_entree.rep_completion_date.day

                            bookies = SurveyBooking.query(SurveyBooking.identifier == pp_entree.booking_identifier)
                            for bookie in bookies:
                                item_dict["name"] = bookie.name

                            item_dict["step_key"] = "pp_rejected_pending_resubmission"
                            item_dict["booking_identifier"] = pp_submission.booking_identifier
                            item_dict["field_app_identifier"] = pp_submission.field_application_identifier

                            item_dict["rejected"] = True
                            item_dict["submission_identifier"] = pp_submission.identifier

                            entries.append(item)

                            gcs_file.unlock()
                            gcs_file.write(json.dumps(entries), "text/plain", "public-read")
                    else:
                        gcs_file.unlock()



    elif self.request.get("fn") == "contest_rejection":
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        for pp_sub in pp_subs:
            pp_sub.rejected = False
            rejection_reasons = json.loads(pp_sub.rejection_reasons)
            rejection_reasons["responses"].append(json.loads(self.request.get("responses")))
            rejection_reasons["response_dates"].append(str(Helpers.pacific_now()))

            pp_sub.rejection_reasons = json.dumps(rejection_reasons)

            pp_sub.rep_submission_date = Helpers.pacific_now()

            pp_sub.put()

            put = False
            cnt = 0

            while cnt < len(rejection_reasons["reasons"]):
                if not put:
                    cnt2 = 0
                    while cnt2 < len(rejection_reasons["reasons"][cnt]):
                        if "A new layout signature is required" in rejection_reasons["reasons"][cnt][cnt2]:
                            put = True
                        cnt2 += 1
                cnt += 1

            if put:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
                if not app_entry is None:
                    app_entry.new_survey_state = 4
                    app_entry.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "update_perfect_packet_rejection_reason":
        idx = int(self.request.get("index"))
        reason = self.request.get("reason")

        pp_submissions = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        for pp_submission in pp_submissions:
            rejection_reasons = json.loads(pp_submission.rejection_reasons)

            if idx < len(rejection_reasons["reasons"]):
                rejection_reasons["reasons"][idx] = reason
                pp_submission.rejection_reasons = json.dumps(rejection_reasons)
                pp_submission.put()

    elif self.request.get("fn") == "list_pending_perfect_packet_submissions":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []
        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.approved == False,
                PerfectPacketSubmission.rejected == False
            )
        ).order(PerfectPacketSubmission.rep_submission_date)
        booking_identifier_cust_name_dict = {}
        booking_identifier_cust_name_dict["-1"] = "-1"
        booking_identifier_rep_id_dict = {}

        packet_identifier_booking_identifier_dict = {}
        rep_ids_to_query = []
        rep_ids_to_query.append("-1")
        surveyor_ids_to_query = []
        surveyor_ids_to_query.append("-1")

        for pp_sub in pp_subs:
            if pp_sub.archived:
                continue

            booking_identifier_cust_name_dict[pp_sub.booking_identifier] = ""
            packet_identifier_booking_identifier_dict[pp_sub.rep_identifier] = pp_sub.identifier
            booking_identifier_rep_id_dict[pp_sub.booking_identifier] = ""


            packet_item = {}
            packet_item["booking_identifier"] = pp_sub.booking_identifier
            packet_item["field_application_identifier"] = pp_sub.field_application_identifier
            packet_item["identifier"] = pp_sub.identifier
            packet_item["rep_identifier"] = pp_sub.rep_identifier
            packet_item["surveyor_identifier"] = pp_sub.surveyor_identifier
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            surveyor_ids_to_query.append(pp_sub.surveyor_identifier)
            packet_item["rep_submission_date"] = str(date(pp_sub.rep_submission_date.year, pp_sub.rep_submission_date.month, pp_sub.rep_submission_date.day))
            packet_item["extra_info"] = json.loads(pp_sub.extra_info)

            ret_json["packets"].append(packet_item)

        booking_identifier_booking_date_map = {}
        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_identifier_cust_name_dict.keys()))
        for booking in bookings:
            booking_identifier_cust_name_dict[booking.identifier] = booking.name
            booking_identifier_rep_id_dict[booking.identifier] = booking.associated_rep_id
            booking_identifier_booking_date_map[booking.identifier] = date(booking.booking_year, booking.booking_month, booking.booking_day)
            rep_ids_to_query.append(booking.associated_rep_id)

        users = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for user in users:

            for pp_sub in ret_json["packets"]:

                pp_sub["survey_date"] = str(booking_identifier_booking_date_map[pp_sub["booking_identifier"]])
                rep_id = booking_identifier_rep_id_dict[pp_sub["booking_identifier"]]
                if user.rep_id == rep_id:

                    pp_sub["rep_name"] = user.first_name + " " + user.last_name
                    pp_sub["rep_id"] = user.rep_id
                    pp_sub["cust_name"] = booking_identifier_cust_name_dict[pp_sub["booking_identifier"]]

        users2 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(surveyor_ids_to_query))
        for user2 in users2:

            for pp_sub in ret_json["packets"]:

                if pp_sub["surveyor_identifier"] == user2.identifier:

                    pp_sub["surveyor_name"] = user2.first_name + " " + user2.last_name


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_approved_perfect_packets":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []
        rep_ids_to_query = []
        rep_ids_to_query.append("-1")
        booking_ids_to_query = []
        booking_ids_to_query.append("-1")
        pp_approvals = PerfectPacketApproval.query().order(-PerfectPacketApproval.approval_date)
        for pp_approval in pp_approvals:
            if pp_approval.archived:
                continue

            packet_item = {}
            packet_item["identifier"] = pp_approval.identifier
            packet_item["packet_submission_identifier"] = pp_approval.packet_submission_identifier
            packet_item["packet_entry_identifier"] = pp_approval.packet_entry_identifier
            packet_item["booking_identifier"] = pp_approval.booking_identifier
            packet_item["field_application_identifier"] = pp_approval.field_application_identifier
            packet_item["rep_identifier"] = pp_approval.rep_identifier
            packet_item["surveyor_identifier"] = pp_approval.surveyor_identifier
            packet_item["approval_date"] = str(pp_approval.approval_date).split(" ")[0]
            packet_item["rep_submission_date"] = str(pp_approval.rep_submission_date).split(" ")[0]
            packet_item["survey_date"] = ""
            packet_item["system_size"] = pp_approval.system_size
            packet_item["rep_name"] = ""
            packet_item["rep_id"] = ""
            packet_item["cust_name"] = ""

            rep_ids_to_query.append(packet_item["rep_identifier"])
            booking_ids_to_query.append(packet_item["booking_identifier"])

            ret_json["packets"].append(packet_item)

        rep_identifier_rep_info_dict = {}
        users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for user in users:
            info_item = {}
            info_item["rep_id"] = user.rep_id
            info_item["rep_name"] = user.first_name + " " + user.last_name
            rep_identifier_rep_info_dict[user.identifier] = info_item

        for packet in ret_json["packets"]:
            if packet["rep_identifier"] in rep_identifier_rep_info_dict.keys():
                packet["rep_name"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_name"]
                packet["rep_id"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_id"]

        booking_identifier_cust_name_dict = {}
        booking_identifier_booking_date_map = {}
        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
        for booking in bookings:
            booking_identifier_cust_name_dict[booking.identifier] = booking.name
            booking_identifier_booking_date_map[booking.identifier] = date(booking.booking_year, booking.booking_month, booking.booking_day)

        for packet in ret_json["packets"]:
            if packet["booking_identifier"] in booking_identifier_cust_name_dict.keys():
                packet["cust_name"] = booking_identifier_cust_name_dict[packet["booking_identifier"]]
                packet["survey_date"] = str(booking_identifier_booking_date_map[packet["booking_identifier"]])

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "list_rejected_perfect_packets_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []

        rep_ids_to_query = []
        rep_ids_to_query.append("-1")
        booking_ids_to_query = []
        booking_ids_to_query.append("-1")

        pp_subs = []

        try:
            pp_subs = PerfectPacketSubmission.query(
                ndb.AND(
                    PerfectPacketSubmission.approved == False,
                    PerfectPacketSubmission.rejected == True,
                    PerfectPacketSubmission.archived == False,
                    PerfectPacketSubmission.rep_identifier == self.session["user_identifier"]
                )
            ).order(-PerfectPacketSubmission.last_rejection_date)
        except:
            pp_subs = pp_subs

        for pp_sub in pp_subs:
            packet_item = {}

            packet_item["identifier"] = pp_sub.identifier
            packet_item["packet_entry_identifier"] = pp_sub.packet_entry_identifier
            packet_item["booking_identifier"] = pp_sub.booking_identifier
            packet_item["field_application_identifier"] = pp_sub.field_application_identifier
            packet_item["field_app_identifier"] = pp_sub.field_application_identifier
            packet_item["surveyor_identifier"] = pp_sub.surveyor_identifier
            packet_item["rep_identifier"] = pp_sub.rep_identifier
            packet_item["rep_submission_date"] = str(date(pp_sub.rep_submission_date.year, pp_sub.rep_submission_date.month, pp_sub.rep_submission_date.day))
            packet_item["approved"] = pp_sub.approved
            packet_item["approval_date"] = str(pp_sub.approval_date)
            packet_item["last_rejection_date"] = str(pp_sub.last_rejection_date)
            packet_item["rejected"] = str(pp_sub.rejected)
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            packet_item["survey_date"] = ""
            packet_item["rep_name"] = ""
            packet_item["rep_id"] = ""
            packet_item["cust_name"] = ""

            ret_json["packets"].append(packet_item)


            rep_ids_to_query.append(packet_item["rep_identifier"])
            booking_ids_to_query.append(packet_item["booking_identifier"])

        rep_identifier_rep_info_dict = {}
        users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))

        for user in users:
            info_item = {}
            info_item["rep_id"] = user.rep_id
            info_item["rep_name"] = user.first_name + " " + user.last_name
            rep_identifier_rep_info_dict[user.identifier] = info_item

        for packet in ret_json["packets"]:
            if packet["rep_identifier"] in rep_identifier_rep_info_dict.keys():
                packet["rep_name"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_name"]
                packet["rep_id"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_id"]

        booking_identifier_cust_name_dict = {}
        booking_identifier_booking_date_map = {}
        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))

        for booking in bookings:
            booking_identifier_cust_name_dict[booking.identifier] = booking.name
            booking_identifier_booking_date_map[booking.identifier] = date(booking.booking_year, booking.booking_month, booking.booking_day)

        for packet in ret_json["packets"]:
            if packet["booking_identifier"] in booking_identifier_cust_name_dict.keys():
                packet["cust_name"] = booking_identifier_cust_name_dict[packet["booking_identifier"]]
                packet["survey_date"] = str(booking_identifier_booking_date_map[packet["booking_identifier"]])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_rejected_perfect_packets":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["packets"] = []

        rep_ids_to_query = []
        rep_ids_to_query.append("-1")
        booking_ids_to_query = []
        booking_ids_to_query.append("-1")

        pp_subs = PerfectPacketSubmission.query(
            ndb.AND(
                PerfectPacketSubmission.approved == False,
                PerfectPacketSubmission.rejected == True,
                PerfectPacketSubmission.archived == False
            )
        ).order(-PerfectPacketSubmission.last_rejection_date)
        for pp_sub in pp_subs:
            packet_item = {}

            packet_item["identifier"] = pp_sub.identifier
            packet_item["packet_entry_identifier"] = pp_sub.packet_entry_identifier
            packet_item["booking_identifier"] = pp_sub.booking_identifier
            packet_item["field_application_identifier"] = pp_sub.field_application_identifier
            packet_item["surveyor_identifier"] = pp_sub.surveyor_identifier
            packet_item["rep_identifier"] = pp_sub.rep_identifier
            packet_item["rep_submission_date"] = str(date(pp_sub.rep_submission_date.year, pp_sub.rep_submission_date.month, pp_sub.rep_submission_date.day))
            packet_item["approved"] = pp_sub.approved
            packet_item["approval_date"] = str(pp_sub.approval_date)
            packet_item["last_rejection_date"] = str(pp_sub.last_rejection_date)
            packet_item["rejected"] = str(pp_sub.rejected)
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            packet_item["survey_date"] = ""
            packet_item["rep_name"] = ""
            packet_item["rep_id"] = ""
            packet_item["cust_name"] = ""

            ret_json["packets"].append(packet_item)


            rep_ids_to_query.append(packet_item["rep_identifier"])
            booking_ids_to_query.append(packet_item["booking_identifier"])

        rep_identifier_rep_info_dict = {}
        users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for user in users:
            info_item = {}
            info_item["rep_id"] = user.rep_id
            info_item["rep_name"] = user.first_name + " " + user.last_name
            rep_identifier_rep_info_dict[user.identifier] = info_item

        for packet in ret_json["packets"]:
            if packet["rep_identifier"] in rep_identifier_rep_info_dict.keys():
                packet["rep_name"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_name"]
                packet["rep_id"] = rep_identifier_rep_info_dict[packet["rep_identifier"]]["rep_id"]

        booking_identifier_cust_name_dict = {}
        booking_identifier_booking_date_map = {}
        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
        for booking in bookings:
            booking_identifier_cust_name_dict[booking.identifier] = booking.name
            booking_identifier_booking_date_map[booking.identifier] = date(booking.booking_year, booking.booking_month, booking.booking_day)

        for packet in ret_json["packets"]:
            if packet["booking_identifier"] in booking_identifier_cust_name_dict.keys():
                packet["cust_name"] = booking_identifier_cust_name_dict[packet["booking_identifier"]]
                packet["survey_date"] = str(booking_identifier_booking_date_map[packet["booking_identifier"]])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_rejection_history_for_packet_by_entry_identifier":
        self.response.content_type = "application/json"
        ret_json = None
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.packet_entry_identifier == self.request.get("identifier"))
        for pp_sub in pp_subs:
            logging.info("KK")
            packet_item = {}

            packet_item["identifier"] = pp_sub.identifier
            packet_item["packet_entry_identifier"] = pp_sub.packet_entry_identifier
            packet_item["booking_identifier"] = pp_sub.booking_identifier
            packet_item["field_application_identifier"] = pp_sub.field_application_identifier
            packet_item["surveyor_identifier"] = pp_sub.surveyor_identifier
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            packet_item["rep_identifier"] = pp_sub.rep_identifier
            packet_item["rep_submission_date"] = str(date(pp_sub.rep_submission_date.year, pp_sub.rep_submission_date.month, pp_sub.rep_submission_date.day))
            packet_item["approved"] = pp_sub.approved
            packet_item["approval_date"] = str(pp_sub.approval_date)
            packet_item["last_rejection_date"] = str(pp_sub.last_rejection_date)
            packet_item["rejected"] = str(pp_sub.rejected)
            packet_item["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            packet_item["survey_date"] = ""
            packet_item["rep_name"] = ""
            packet_item["rep_id"] = ""
            packet_item["cust_name"] = ""

            users = FieldApplicationUser.query(FieldApplicationUser.identifier == packet_item["rep_identifier"])
            for user in users:
                packet_item["rep_id"] = user.rep_id
                packet_item["rep_name"] = user.first_name + " " + user.last_name

            bookings = SurveyBooking.query(SurveyBooking.identifier == packet_item["booking_identifier"])
            for booking in bookings:
                packet_item["cust_name"] = booking.name
                packet_item["survey_date"] = str(date(booking.booking_year, booking.booking_month, booking.booking_day))

            ret_json = packet_item

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "solar_header_hash_check":
        self.response.content_type = "application/json"
        reader = SolarReader.first(SolarReader.hash == self.request.get("hash"))
        ret_json = {"success": (not reader is None)}
        if ret_json["success"]:
            if str(self.request.get("with_identifier")) == "1":
                ret_json["success"] = (reader.field_app_identifier == self.request.get("identifier"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_funding_sources":
        self.response.content_type = "application/json"
        if self.request.get("include_grouping_info") == "1":
            ret_json = {}
            ret_json["funding_list"] = Helpers.list_funds()
            ret_json["group_info"] = Helpers.list_funding_groups()

            for item in ret_json["funding_list"]:
                code_name = item["value"]

                combined_vals = []

                for group_key in ret_json["group_info"]["group_items"].keys():
                    combined_vals += ret_json["group_info"]["group_items"][group_key]

                found = False
                for item3 in combined_vals:

                    if item3 == code_name:
                        found = True

                if not found:
                    ret_json["group_info"]["group_items"]["unassigned"].append(code_name)

            self.response.out.write(json.dumps(ret_json))
        else:
            self.response.out.write(json.dumps(Helpers.list_funds()))

    elif self.request.get("fn") == "update_funding_credit_ceiling":
        self.response.content_type = "application/json"
        ret_json = {}
        sources = Helpers.list_funds()
        sources.pop(0)
        sources.pop(len(sources) - 1)

        for source in sources:
            if source["value"] == self.request.get("fund"):
                source["credit_floor_great"] = int(self.request.get("floor_great"))
                source["credit_ceiling_great"] = int(self.request.get("ceiling_great"))
                source["match_message_great"] = self.request.get("message_great")

                source["credit_floor_good"] = int(self.request.get("floor_good"))
                source["credit_ceiling_good"] = int(self.request.get("ceiling_good"))
                source["match_message_good"] = self.request.get("message_good")
                source["discount_percentage"] = self.request.get("discount_percentage")
                source["promo_period"] = int(self.request.get("promo_period"))
                source["promo_factor"] = self.request.get("promo_factor")
                source["after_promo_factor"] = self.request.get("after_promo_factor")
                source["downpayment_amount"] = self.request.get("downpayment_amount")
                source["milestone_1_percentage"] = self.request.get("milestone_1_percentage")
                source["milestone_2_percentage"] = self.request.get("milestone_2_percentage")
                source["tier_enabled"] = (self.request.get("tier_enabled") == "1")
                source["tier_data"] = json.loads(self.request.get("tier_data"))
                source["requires_proposal"] = (self.request.get("requires_proposal") == "1")
                source["lp"] = (self.request.get("lp") == "1")
                source["supplementary"] = (self.request.get("supplementary") == "1")
                source["dealer_fee_percentage"] = self.request.get("dealer_fee_percentage")
                source["apr"] = float(self.request.get("apr"))

        jaysawn = json.dumps(sources)

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type="text/plain",
            options={'x-goog-meta-foo': 'foo',
                     'x-goog-meta-bar': 'bar',
                     'x-goog-acl': 'public-read'},
            retry_params=write_retry_params
        )

        gcs_file.write(jaysawn)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

        ret_json["success"] = True
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_funding_source_type":
        self.response.content_type = "application/json"
        ret_json = {}
        sources = Helpers.list_funds()
        sources.pop(0)
        sources.pop(len(sources) - 1)
        new_source = {}
        new_source["value"] = self.request.get("value")
        new_source["value_friendly"] = self.request.get("value_friendly")
        new_source["active"] = False
        new_source["credit_floor_great"] = 2000
        new_source["credit_ceiling_great"] = 3000
        new_source["match_message_great"] = "The customer has a great chance of passing credit."
        new_source["credit_floor_good"] = 1500
        new_source["credit_ceiling_good"] = 1999
        new_source["match_message_good"] = "The customer has a good chance of passing credit."
        new_source["discount_percentage"] = "0%"
        new_source["promo_period"] = 0
        new_source["promo_factor"] = "0.001"
        new_source["after_promo_factor"] = "0.001"
        new_source["downpayment_amount"] = "0%"
        new_source["milestone_1_percentage"] = "0%"
        new_source["milestone_2_percentage"] = "0%"
        new_source["tier_enabled"] = False
        new_source["requires_proposal"] = False
        new_source["lp"] = False
        new_source["supplementary"] = False
        new_source["tier_data"] = []
        new_source["dealer_fee_percentage"] = "0%"
        new_source["apr"] = 0

        found = (self.request.get("value") == "fail") or (self.request.get("value") == "n/a")

        for source in sources:
            if source["value"] == new_source["value"] or source["value_friendly"] == new_source["value_friendly"]:
                found = True

        if not found:
            sources.append(new_source)

        jaysawn = json.dumps(sources)

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type="text/plain",
            options={'x-goog-meta-foo': 'foo',
                     'x-goog-meta-bar': 'bar',
                     'x-goog-acl': 'public-read'},
            retry_params=write_retry_params
        )

        gcs_file.write(jaysawn)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

        ret_json["success"] = not found
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_rep_data_logger_info":
        today = Helpers.pacific_today()
        self.response.content_type = "application/json"
        ret_json = []
        readers = SolarReader.query(SolarReader.rep_ownership == self.request.get("identifier"))
        app_ids_to_query = ["-2"]
        for reader in readers:
            obj = {"identifier": reader.identifier, "field_app_identifier": reader.field_app_identifier}
            if not obj["field_app_identifier"] == "-1":
                if reader.deployment_dt.year > 1970:
                    ret_json.append(obj)
                    app_ids_to_query.append(reader.field_app_identifier)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            for reader in ret_json:
                if reader["field_app_identifier"] == app_entry.identifier:
                    reader["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                    reader["address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
                    reader["sp2"] = str(app_entry.sp_two_time).split(".")[0]
                    reader["old"] = app_entry.sp_two_time.date() < today

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_friendly_name_for_fund":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = True
        sources = Helpers.list_funds()
        sources.pop(0)
        sources.pop(len(sources) - 1)

        try:
            found = False

            for source in sources:
                if source["value_friendly"].lower() == self.request.get("name").lower():
                    found = True

            if not found:
                target_source = sources[int(self.request.get("index")) - 1]
                curr_name = target_source["value_friendly"]

                value_name_to_edit_in_groups = None
                if not curr_name.lower() == self.request.get("name").lower():
                    target_source["value_friendly"] = self.request.get("name")
                    value_name_to_edit_in_groups = target_source["value"]

                jaysawn = json.dumps(sources)

                bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                bucket = '/' + bucket_name
                filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

                write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
                )

                gcs_file.write(jaysawn)
                gcs_file.close()

                if not value_name_to_edit_in_groups is None:
                    filename2 = bucket + '/ApplicationSettings/funding_groups_' + app_identity.get_application_id() + '.json'
                    retryParameters = gcs.RetryParams(initial_delay=0.2,
                                           max_delay=5.0,
                                           backoff_factor=2,
                                           max_retry_period=15,
                                           urlfetch_timeout=30)
                    gcs_file = gcs.open(filename2, 'r', retry_params=retryParameters)
                    jaysawn2 = gcs_file.read()
                    curr_groups = json.loads(jaysawn2)
                    gcs_file.close()

                    count = 0
                    while count < len(curr_groups["group_names"]):
                        item  = curr_groups["group_names"][count]
                        if item["value_friendly"] == value_name_to_edit_in_groups:
                            item["value"] = self.request.get("name")

                        count += 1

                    jaysawn3 = json.dumps(curr_groups)
                    gcs_file = gcs.open(
                        filename2,
                        'w',
                        content_type="text/plain",
                        options={'x-goog-meta-foo': 'foo',
                                 'x-goog-meta-bar': 'bar',
                                 'x-goog-acl': 'public-read'},
                        retry_params=write_retry_params
                    )
                    gcs_file.write(jaysawn3)
                    gcs_file.close()



                keyy = "list_of_funding_source_names"
                keyy2 = "list_of_funding_groups"
                memcache.delete(keyy)
                memcache.delete(keyy2)


            else:
                ret_json["success"] = False

        except:
            ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_funding_groups":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["groups"] = Helpers.list_funding_groups()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_funding_group":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = True

        try:
            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            filename = bucket + '/ApplicationSettings/funding_groups_' + app_identity.get_application_id() + '.json'

            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

            gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
            jaysawn = gcs_file.read()
            gcs_file.close()
            group_info = json.loads(jaysawn)
            new_item = {"value": self.request.get("value"), "value_friendly": self.request.get("value_friendly")}

            exists_already = False
            if self.request.get("value") == "unassigned":
                exists_already = True

            count = 0
            while count < len(group_info["group_names"]):

                if group_info["group_names"][count]["value"] == self.request.get("value"):
                    exists_already = True

                count += 1
            if not exists_already:
                group_info["group_names"].append(new_item)
                group_info["group_items"][self.request.get("value")] = []

                jaysawn2 = json.dumps(group_info)
                write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params
                )

                gcs_file.write(jaysawn2)
                gcs_file.close()

                keyy = "list_of_funding_source_names"
                keyy2 = "list_of_funding_groups"
                memcache.delete(keyy)
                memcache.delete(keyy2)

            else:
                ret_json["success"] = False

        except:
            ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_fund_group_name":
        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_groups_' + app_identity.get_application_id() + '.json'

        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
        jaysawn = gcs_file.read()
        gcs_file.close()
        group_info = json.loads(jaysawn)

        count = 0
        while count < len(group_info["group_names"]):

            if group_info["group_names"][count]["value"] == self.request.get("value"):
                group_info["group_names"][count]["value_friendly"] = self.request.get("value_friendly")
                count += len(group_info["group_names"])

                jaysawn2 = json.dumps(group_info)
                write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params
                )
                gcs_file.write(jaysawn2)
                gcs_file.close()

                keyy = "list_of_funding_source_names"
                keyy2 = "list_of_funding_groups"
                memcache.delete(keyy)
                memcache.delete(keyy2)

            count += 1

        self.response.out.write(" ")

    elif self.request.get("fn") == "adjust_funding_group_info":
        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_groups_' + app_identity.get_application_id() + '.json'

        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
        jaysawn = gcs_file.read()
        gcs_file.close()
        group_info = json.loads(jaysawn)

        group_info["group_items"] = json.loads(self.request.get("info"))

        jaysawn2 = json.dumps(group_info)
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
        )
        gcs_file.write(jaysawn2)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

    elif self.request.get("fn") == "drop_fund_group":
        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_groups_' + app_identity.get_application_id() + '.json'

        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
        jaysawn = gcs_file.read()
        gcs_file.close()
        group_info = json.loads(jaysawn)

        count = 0
        del_idx = -1
        while count < len(group_info["group_names"]):
            if group_info["group_names"][count]["value"] == self.request.get("value"):
                del_idx = count
                count += len(group_info["group_names"])


            count += 1

        if not del_idx == -1:
            try:
                del group_info["group_names"][del_idx]
            except:
                count = count

        try:
            del group_info["group_items"][self.request.get("value")]
        except:
            count = count

        jaysawn2 = json.dumps(group_info)
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
        )
        gcs_file.write(jaysawn2)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

        self.response.out.write(" ")


    elif self.request.get("fn") == "read_setting":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["data"] = Helpers.read_setting(self.request.get("value"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "write_setting":
        try:
            Helpers.write_setting(self.request.get("value"), json.loads(self.request.get("data")))
        except:
            Helpers.write_setting(self.request.get("value"), self.request.get("data"))
        self.response.out.write(" ")

    elif self.request.get("fn") == "list_payscales":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["scales"] = Helpers.list_payscales()
        if self.request.get("include_naming_map") == "1":
            ret_json["fund_names"] = Helpers.list_funds()
        if self.request.get("include_override_data") == "1":
            ret_json["overrides"] = Helpers.list_automatic_overrides()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_payscale":
        item = {}
        item["value"] = self.request.get("value")
        item["value_friendly"] = self.request.get("value_friendly")
        item["scales"] = []

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/payscales_' + app_identity.get_application_id() + '.json'

        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                               max_delay=5.0,
                                               backoff_factor=2,
                                               max_retry_period=15,
                                               urlfetch_timeout=30)

        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
        jaysawn = gcs_file.read()
        gcs_file.close()
        scales = json.loads(jaysawn)
        scales.append(item)

        jaysawn2 = json.dumps(scales)
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
        )
        gcs_file.write(jaysawn2)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        keyy3 = "list_of_payscales"
        memcache.delete(keyy)
        memcache.delete(keyy2)
        memcache.delete(keyy3)

        self.response.out.write(" ")

    elif self.request.get("fn") == "get_user_info_for_payscales":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        #users = FieldApplicationUser.query(
        #    ndb.AND
        #    (
        #        FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr"]),
        #        FieldApplicationUser.current_status == 0
        #    )
        #).order(FieldApplicationUser.first_name, FieldApplicationUser.last_name)
        users = FieldApplicationUser.query(FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"])).order(FieldApplicationUser.first_name).order(FieldApplicationUser.last_name)

        for user in users:
            user_item = {}
            user_item["identifier"] = user.identifier
            user_item["first_name"] = user.first_name
            user_item["last_name"] = user.last_name
            user_item["rep_id"] = user.rep_id
            user_item["payscale_key"] = user.payscale_key
            ret_json["users"].append(user_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "check_for_missing_payscale_keys":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.payscale_key == "n/a",
                FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"]),
                FieldApplicationUser.current_status == 0
            )
        ).order(FieldApplicationUser.first_name, FieldApplicationUser.last_name)

        for user in users:
            user_item = {}
            user_item["name"] = user.first_name + " " + user.last_name
            user_item["rep_id"] = user.rep_id
            ret_json["users"].append(user_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_payscale_key_for_user":
        users = FieldApplicationUser.query(FieldApplicationUser.identifier == self.request.get("user_id"))
        for user in users:
            user.payscale_key = self.request.get("key")
            user.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "payscale_audit":
        self.response.content_type = "text/plain"
        ret_json = {}
        ret_json["users"] = []

        payscales = Helpers.list_payscales()
        payscale_map = {}
        for payscale in payscales:
            payscale_map[payscale["value"]] = payscale["value_friendly"]

        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"]),
                FieldApplicationUser.current_status == 0
            )
        ).order(FieldApplicationUser.first_name, FieldApplicationUser.last_name)
        for user in users:
            user_item = {}
            user_item["identifier"] = user.identifier
            user_item["first_name"] = user.first_name
            user_item["last_name"] = user.last_name
            user_item["rep_id"] = user.rep_id
            user_item["payscale"] = None
            if (not user.payscale_key == "n/a") and (user.payscale_key in payscale_map.keys()):
                user_item["payscale"] = payscale_map[user.payscale_key]

            ret_json["users"].append(user_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_price_for_scale_at_group":
        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/payscales_' + app_identity.get_application_id() + '.json'

        scales = Helpers.list_payscales()

        for scale in scales:
            if scale["value"] == self.request.get("scale"):
                idx = -1
                count = 0
                for item in scale["scales"]:
                    if item["funding_group"] == self.request.get("group"):
                        if item["tier"] == self.request.get("tier") and idx == -1:
                            idx = count

                    count += 1

                if idx < 0:
                    item = {}
                    item["tier"] = self.request.get("tier")
                    item["price"] = round(float(self.request.get("price")), 2)
                    item["funding_group"] = self.request.get("group")
                    scale["scales"].append(item)
                else:
                    scale["scales"][idx]["price"] = self.request.get("price")

        jaysawn = json.dumps(scales)
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
        )
        gcs_file.write(jaysawn)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        keyy3 = "list_of_payscales"
        memcache.delete(keyy)
        memcache.delete(keyy2)
        memcache.delete(keyy3)

    elif self.request.get("fn") == "rename_payscale":
        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/payscales_' + app_identity.get_application_id() + '.json'
        scales = Helpers.list_payscales()
        for scale in scales:
            if scale["value"] == self.request.get("value"):
                scale["value_friendly"] = self.request.get("new_name")

        jaysawn = json.dumps(scales)
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="text/plain",
                    options={'x-goog-meta-foo': 'foo',
                             'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                    retry_params=write_retry_params
        )
        gcs_file.write(jaysawn)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        keyy3 = "list_of_payscales"
        memcache.delete(keyy)
        memcache.delete(keyy2)
        memcache.delete(keyy3)

    elif self.request.get("fn") == "calculate_upcoming_paycheck_for_rep":
        custom_date = (str(self.request.get("custom_date")) == "1")
        self.response.content_type = "application/json"
        ret_json = {}
        dt = None
        if custom_date:
            split_vals = self.request.get("date").split("-")
            dt = datetime(int(split_vals[0]), int(split_vals[1]), int(split_vals[2]))
        ret_json["paycheck_data"] = Helpers.calculate_upcoming_paycheck_for_rep(self.session["user_identifier"], custom_date, dt)

        t_cpy = []
        for t in ret_json["paycheck_data"]["transactions"]:
            if t["amount"] >= -500 and t["amount"] <= 25:
                t["amount"] = 0
            t_cpy.append(t)
            #abs_total = abs(t["amount"])
            #if abs_total >= 1 and abs_total <= 25:
            #    t["amount"] = 0
            #t_cpy.append(t)

        ret_json["paycheck_data"]["transactions"] = t_cpy

        app_entries = FieldApplicationEntry.query(
            ndb.AND(
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.lead_generator == self.session["user_identifier"]
            )
        )

        ret_json["paycheck_data"]["potential_bonuses"] = []

        app_ids_to_query = [""]
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)

        if len(app_ids_to_query) > 0:
            already_paid_out = []
            transactions = MonetaryTransactionV2.query(
                ndb.AND(
                    MonetaryTransactionV2.field_app_identifier.IN(app_ids_to_query),
                    MonetaryTransactionV2.description_key == "solar_pro_sales_commission"
                )
            )
            for t in transactions:
                already_paid_out.append(t.field_app_identifier)

        for app_id in app_ids_to_query:
            if not app_id in already_paid_out:
                ret_json["paycheck_data"]["potential_bonuses"].append({"identifier": app_id})
        

        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "calculate_upcoming_paycheck_for_reps":
        self.response.content_type = "application/json"
        ret_json = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"])).order(FieldApplicationUser.first_name).order(FieldApplicationUser.last_name)

        user_ids_to_query = []

        for rep in reps:
            user_ids_to_query.append(rep.identifier)

        ret_json["data"] = Helpers.calculate_upcoming_paycheck_for_reps(user_ids_to_query)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "campaign_jobs_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/campaign_jobs", params={})

    elif self.request.get("fn") == "update_lead_notes":
        note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "rep_lead_notes"
            )
        )
        if note is None:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                rep_id = app_entry.rep_id
                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == rep_id)
                if not rep is None:
                    note = CustomerNote(
                        identifier=Helpers.guid(),
                        field_app_identifier=self.request.get("identifier"),
                        inserted_pacific=Helpers.pacific_now(),
                        inserted_utc=datetime.now(),
                        author=rep.identifier,
                        perms="public",
                        content="{\"txt\": [\"\"]}",
                        blob_count=0,
                        note_key="rep_lead_notes",
                        read=True
                    )            
            
        content = json.loads(note.content)
        content["txt"][0] = self.request.get("notes")
        note.content = json.dumps(content)
        note.put()

    elif self.request.get("fn") == "month_assigned_backfill2":
        kv_keys_to_query = []
        quadrants = RepQuadrant.query()
        for quadrant in quadrants:
            kv_keys_to_query.append("quad_time_assigned_" + quadrant.identifier)

        data_to_put = []
        kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kv_keys_to_query))
        for kv in kvs:
            date_vals = kv.val.split(" ")[0].split("-")
            time_vals = kv.val.split(" ")[1].split(":")

            year = int(date_vals[0])
            month = int(date_vals[1])
            day = int(date_vals[2])

            hour = int(time_vals[0])
            minute = int(time_vals[1])
            second = int(time_vals[2])

            d = datetime(year, month, day, hour, minute, second)
            
            quad_identifier = kv.keyy.replace("quad_time_assigned_", "")

            to_save = QuadrantAssignmentDetails(
                identifier=Helpers.guid(),
                quadrant_identifier=quad_identifier,
                dt=d
            )

            data_to_put.append(to_save)

        ndb.put_multi(data_to_put)

        

    elif self.request.get("fn") == "month_assigned_backfill":
        kvs_to_save = []
        quadrants = RepQuadrant.query()
        for quadrant in quadrants:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="quad_time_assigned_" + quadrant.identifier,
                val=str(quadrant.created).split(".")[0],
                expiration=datetime(1970, 1, 1)
            )
            kvs_to_save.append(kv)

        if len(kvs_to_save) == 1:
            kvs_to_save[0].put()
        elif len(kvs_to_save) > 1:
            ndb.put_multi(kvs_to_save)

    elif self.request.get("fn") == "claim_lead":
        lead = Lead.first(Lead.identifier == self.request.get("identifier"))
        if not lead is None:
            lead.status = "default"
            lead.dt_accepted = Helpers.pacific_now()
            lead.put()

    elif self.request.get("fn") == "get_leads_by_type":
        typ = self.request.get("type")
        ret_json = {"leads": []}
        types = ["-1"]
        if typ == "unclaimed":
            types = (types + ["unclaimed"])
        else:
            types = (types + ["no_contact_but_further_followup", "going_to_keep_following_up", "default", "rescheduled"])

        leads = Lead.query(
            ndb.AND(
                Lead.rep_identifier == self.request.get("identifier"),
                Lead.archived == False,
                Lead.status.IN(types)
            )
        )

        field_app_identifier_idx_dict = {}
        app_ids_to_query = ["-1"]
        for lead in leads:
            obj = {"identifier": lead.identifier, "field_app_identifier": lead.field_app_identifier, "status": lead.status, "admin_checklist": [], "admin_notes": ""}

            field_app_identifier_idx_dict[lead.field_app_identifier] = len(ret_json["leads"])
            app_ids_to_query.append(lead.field_app_identifier)

            ret_json["leads"].append(obj)

        solar_pro_ids = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        phone_call_kv_keys_to_query = ["-1"]
        for app_entry in app_entries:
            obj = ret_json["leads"][field_app_identifier_idx_dict[app_entry.identifier]]
            obj["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            obj["phone_call"] = None
            obj["address"] = app_entry.customer_address
            obj["city"] = app_entry.customer_city
            obj["state"] = app_entry.customer_state
            obj["postal"] = app_entry.customer_postal
            obj["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            obj["email"] = app_entry.customer_email
            obj["sp2"] = str(app_entry.sp_two_time).split(".")[0]
            obj["solar_pro"] = app_entry.lead_generator
            obj["solar_pro_phone"] = "(111) 111-1111"
            obj["notes"] = "No notes were recorded"
            obj["deal_closed"] = app_entry.deal_closed
            solar_pro_ids.append(app_entry.lead_generator)
            #phone_call_kv_keys_to_query.append("ab_call_recording_" + app_entry.identifier)

        #phone_kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(phone_call_kv_keys_to_query))
        #for kv in phone_kvs:
            #identifier = kv.keyy.replace("ab_call_recording_", "")
            #idx = field_app_identifier_idx_dict[identifier]
            #ret_json["leads"][idx]["phone_call"] = kv.val

        solar_pro_identifier_name_dict = {}
        solar_pro_identifier_phone_dict = {}

        solar_pros = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(solar_pro_ids))
        for s in solar_pros:
            solar_pro_identifier_name_dict[s.identifier] = s.first_name.strip().title() + " " + s.last_name.strip().title()
            solar_pro_identifier_phone_dict[s.identifier] = Helpers.format_phone_number(s.rep_phone)

        for l in ret_json["leads"]:            
            identifier = l["solar_pro"]
            l["solar_pro_identifier"] = identifier
            try:
                l["solar_pro"] = solar_pro_identifier_name_dict[identifier]
                l["solar_pro_phone"] = solar_pro_identifier_phone_dict[identifier]
            except:
                l["solar_pro"] = "n/a"
                l["solar_pro_phone"] = "n/a"

        #ret_json["leads"] = Helpers.bubble_sort(ret_json["leads"], "sp2")

        cpy = []
        for item in ret_json["leads"]:
            if "solar_pro" in item.keys():
                cpy.append(item)
        ret_json["leads"] = cpy

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "adam_hill_fix":
        now = Helpers.pacific_now()
        ninety_days_ago = now + timedelta(hours=24 * 180 * -1)
        ninety_days_ago = datetime(ninety_days_ago.year, ninety_days_ago.month, ninety_days_ago.day, 0, 0, 0)
        stats = LeaderBoardStat.query(
            LeaderBoardStat.metric_key == "packets_submitted",
            LeaderBoardStat.dt >= ninety_days_ago
        )

        app_ids_to_query = ["-1"]
        for stat in stats:
            if stat.rep_id == "HILL0807":
                app_ids_to_query.append(stat.field_app_identifier)

        lst = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            lst.append({"name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()})
        self.response.out.write(json.dumps(lst))

    elif self.request.get("fn") == "cancel_lead_status_from_rep_portal_calendar":
        Helpers.archive_state(self.request.get("identifier"))
        lead = Lead.first(Lead.field_app_identifier == self.request.get("identifier"))
        if not lead is None:
            lead.status = "lead_cancelled"
            lead.put()

            ev = CalendarEvent.first(
                ndb.AND(
                    CalendarEvent.event_key == "sp2",
                    CalendarEvent.field_app_identifier == self.request.get("identifier")
                )
            )
            if not ev is None:
                ev.start_dt = datetime(1970, 1, 1)
                ev.end_dt = datetime(1970, 1, 1, 1)
                ev.put()

    elif self.request.get("fn") == "update_lead_status":
        app_entry = None
        lead = Lead.first(Lead.identifier == self.request.get("identifier"))
        if not lead is None:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == lead.field_app_identifier)
        if not lead is None:
            lead.status = self.request.get("status")
            if self.request.get("status") in ["lead_cancelled", "no_contact_no_followup"]:
                Helpers.archive_state(lead.field_app_identifier)
                ev = CalendarEvent.first(
                    ndb.AND(
                        CalendarEvent.event_key == "sp2",
                        CalendarEvent.field_app_identifier == lead.field_app_identifier
                    )
                )
                if not ev is None:
                    ev.start_dt = datetime(1970, 1, 1)
                    ev.end_dt = datetime(1970, 1, 1, 1)
                    ev.put()

            lead.put()

            if str(self.request.get("from_sp2_annoy")) == "1":
                kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="sp2_annoy_" + lead.field_app_identifier,
                    val="1",
                    expiration=Helpers.pacific_now() + timedelta(days=180)
                )
                kv.put()

                if not app_entry is None:
                    kv2 = KeyValueStoreItem(
                            identifier=Helpers.guid(),
                            keyy="sp2_annoy_" + app_entry.identifier + "_" + str(app_entry.sp_two_time.year) + "-" + str(app_entry.sp_two_time.month) + "-" + str(app_entry.sp_two_time.day) + "-" + str(app_entry.sp_two_time.hour) + "-" + str(app_entry.sp_two_time.minute),
                            val="1",
                            expiration=Helpers.pacific_now() + timedelta(days=90)
                        )
                    kv2.put()

            if len(self.request.get("note_txt").strip()) > 0:
                note = CustomerNote.first(
                    ndb.AND(
                        CustomerNote.field_app_identifier == lead.field_app_identifier,
                        CustomerNote.note_key == "rep_lead_notes"
                    )
                )
                if note is None:
                    content_dict = {}
                    content_dict["txt"] = [self.request.get("note_txt")]            
                    CustomerTranscriber.transcribe_object(lead.field_app_identifier,
                                                            self.request.get("user_identifier"),
                                                            content_dict,
                                                            0,
                                                            "rep_lead_notes")
                else:
                    content_dict = json.loads(note.content)
                    content_dict["txt"][0] = self.request.get("notes_txt")
                    note.content = json.dumps(content_dict)
                    note.put()

    elif self.request.get("fn") == "ak_cd_research":
        cd_stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.metric_key.IN(["packets_submitted", "packets_submitted_dnq"]),
                LeaderBoardStat.dt >= Helpers.pacific_now() + timedelta(days=-90)
            )
        )

        ak_stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.metric_key == "appointments_kept",
                LeaderBoardStat.dt >= Helpers.pacific_now() + timedelta(days=-90)
            )
        )

        cds_found = []
        aks_found = []
        for cd_stat in cd_stats:
            cds_found.append(cd_stat.field_app_identifier)
        for ak_stat in ak_stats:
            aks_found.append(ak_stat.field_app_identifier)

        missing = []
        for item in cds_found:
            if not item in aks_found:
                missing.append(item)

        Helpers.send_email("rnirnber@gmail.com", "results", json.dumps(missing))

    elif self.request.get("fn") == "save_rep_lead_notes":
        note = CustomerNote.first(
                ndb.AND(
                    CustomerNote.field_app_identifier == self.request.get("identifier"),
                    CustomerNote.note_key == "rep_lead_notes"
                )
            )
        if note is None:
            content_dict = {}
            content_dict["txt"] = [self.request.get("notes")]            
            CustomerTranscriber.transcribe_object(self.request.get("identifier"),
                                                    self.request.get("user_identifier"),
                                                    content_dict,
                                                    0,
                                                    "rep_lead_notes")
        else:
            content_dict = json.loads(note.content)
            content_dict["txt"][0] = self.request.get("notes")
            note.content = json.dumps(content_dict)
            note.put()

    elif self.request.get("fn") == "complete_sp2_dialog":
        kv = KeyValueStoreItem(
            identifier=Helpers.guid(),
            keyy="sp2_annoy_" + self.request.get("identifier"),
            val="1",
            expiration=Helpers.pacific_now() + timedelta(days=180)
        )
        kv.put()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            kv2 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="sp2_annoy_" + app_entry.identifier + "_" + str(app_entry.sp_two_time.year) + "-" + str(app_entry.sp_two_time.month) + "-" + str(app_entry.sp_two_time.day) + "-" + str(app_entry.sp_two_time.hour) + "-" + str(app_entry.sp_two_time.minute),
                val="1",
                expiration=Helpers.pacific_now() + timedelta(days=90)
            )
            kv2.put()

        if len(self.request.get("notes").strip()) > 0:
            note = CustomerNote.first(
                ndb.AND(
                    CustomerNote.field_app_identifier == self.request.get("identifier"),
                    CustomerNote.note_key == "rep_lead_notes"
                )
            )
            if note is None:
                content_dict = {}
                content_dict["txt"] = [self.request.get("notes")]            
                CustomerTranscriber.transcribe_object(self.request.get("identifier"),
                                                        self.request.get("user_identifier"),
                                                        content_dict,
                                                        0,
                                                        "rep_lead_notes")
            else:
                content_dict = json.loads(note.content)
                content_dict["txt"][0] = self.request.get("notes")
                note.content = json.dumps(content_dict)
                note.put()

    elif self.request.get("fn") ==  "past_customers_for_rep":
        self.response.content_type = "application/json"
        ret_json = []
        app_identifier_idx_dict = {}
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.rep_id == self.request.get("rep_id"),
                FieldApplicationEntry.sp_two_time >= Helpers.pacific_now() + timedelta(days=-730),
                FieldApplicationEntry.sp_two_time <= Helpers.pacific_now() + timedelta(days=-61)
            )
        )
        app_ids_to_query = ["-1"]
        for app_entry in app_entries:
            app_identifier_idx_dict[app_entry.identifier] = len(ret_json)
            name = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            ret_json.append({"name": name, "name_lowered": name.lower(), "phone": Helpers.format_phone_number(app_entry.customer_phone), "email": app_entry.customer_email, "address": app_entry.customer_address, "city": app_entry.customer_city, "state": app_entry.customer_state, "postal": app_entry.customer_postal, "deal_closed": app_entry.deal_closed, "status": "missing"})
            app_ids_to_query.append(app_entry.identifier)

        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))

        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            item = ret_json[app_identifier_idx_dict[pp_sub.field_application_identifier]]
            if item["deal_closed"] == False:
                item["status"] = "not_closed"
            else:
                item["status2"] = "deal_closed"
                item["status"] = "not_installed"
                if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "checked" in info["project_management_checkoffs"]["install"].keys():
                            if info["project_management_checkoffs"]["install"]["checked"]:
                                item["status"] = "installed"

            ret_json[app_identifier_idx_dict[pp_sub.field_application_identifier]] = item

        cpy = []
        for item in ret_json:
            if not item["status"] == "missing":
                cpy.append(item)

        ret_json = cpy
        ret_json = Helpers.bubble_sort(ret_json, "name_lowered")
        for item in ret_json:
            del item["name_lowered"]
        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "proposal_preparation_for_rep_portal":
        self.response.content_type = "application/json"
        ret_json = {"notes": "", "proposal": None}
        ret_json["proposal"] = None
        ret_json["income_verification_required"] = False
        ret_json["usage_type"] = "real"

        note = CustomerNote.first(
            ndb.AND(
                CustomerNote.note_key == "credit_screen_notes",
                CustomerNote.field_app_identifier == self.request.get("identifier")
            )
        )
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            ret_json["proposal"] = {"info": proposal.info, "version": proposal.version, "identifier": proposal.identifier}

        if not note is None:
            ret_json["notes"] = json.loads(note.content)["txt"][0]

        keys_to_query = ["-1"]
        keys_to_query.append("income_verification_required_" + self.request.get("identifier"))
        keys_to_query.append("real_or_estimated_" + self.request.get("identifier"))

        kv_vals = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_val in kv_vals:
            if "income_verification" in kv_val.keyy:
                ret_json["income_verification_required"] = (kv_val.val == "1")
            elif "real_or_estimated_" in kv_val.keyy:
                ret_json["usage_type"] = kv_val.val

        incentive_kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "titan_incentive_" + self.request.get("identifier"))            

        if incentive_kv2 is None:
            incentive_kv2 = "n/a"
        else:
            incentive_kv2 = incentive_kv2.val
        

        ret_json["titan_incentive"] = incentive_kv2

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_sp2_details_for_customer":
        self.response.content_type = "application/json"
        ret_json = {"notes": "", "proposal": None}
        ret_json["proposal"] = None        
        note = CustomerNote.first(
            ndb.AND(
                CustomerNote.note_key == "credit_screen_notes",
                CustomerNote.field_app_identifier == self.request.get("identifier")
            )
        )
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            ret_json["proposal"] = {"info": proposal.info, "version": proposal.version, "identifier": proposal.identifier}

        if not note is None:
            ret_json["notes"] = json.loads(note.content)["txt"][0]        

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["is_lead"] = not (app_entry.lead_generator == "-1")
            if ret_json["is_lead"]:
                ret_json["solar_pro"] = {}
                user = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                if not user is None:
                    ret_json["solar_pro"]["name"] = user.first_name.strip().title() + " " + user.last_name.strip().title()
                    ret_json["solar_pro"]["phone_formatted"] = Helpers.format_phone_number(user.rep_phone)
                    ret_json["solar_pro"]["phone"] = user.rep_phone
                    ret_json["solar_pro"]["ab_call"] = None
                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ab_call_recording_" + self.request.get("identifier"))
                    if not kv is None:
                        ret_json["solar_pro"]["ab_call"] = kv.val

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "upload_ab_call_v2":
        from google.appengine.api import urlfetch
        import time
        import base64

        identifier = self.request.get("identifier")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        if not app_entry is None:
            f = GCSLockedFile("/AudioRecordings/ABs/" + identifier + ".mp3")
            file_content = self.request.POST.multi['mp3'].file.read()
            f.write(file_content, "audio/mpeg", "public-read")
            f.unlock()

            root_folder = ThirdPartyFolder.first(
                ndb.AND(
                    ThirdPartyFolder.field_app_identifier == identifier,
                    ThirdPartyFolder.folder_key == "root_folder"
                )
            )
            if not root_folder is None:
                audio_folder = ThirdPartyFolder.first(
                    ndb.AND(
                        ThirdPartyFolder.field_app_identifier == identifier,
                        ThirdPartyFolder.folder_key == "audio_recordings"
                    )
                )
                parent_id = "-1"
                if audio_folder is None:
                    parent_id = Helpers.create_customer_folder_in_google_drive(app_entry, root_folder.foreign_id, "Audio Recordings", "audio_recordings")
                else:
                    parent_id = audio_folder.foreign_id

                file_id = Helpers.create_file_in_google_drive(parent_id, "AB.mp3", base64.b64encode(file_content), "audio/mpeg")

                time.sleep(1)
                resp = urlfetch.fetch(url="https://script.google.com/macros/s/AKfycbx5qjSkvfPesmdL5pOUnofY0dxikB9G0MgqIXdJlZdq6vkv-7zy/exec?id=" + file_id,
                    deadline=60,
                    method=urlfetch.GET)
                mp3_url = resp.content

                kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ab_call_recording_" + app_entry.identifier)
                if kv is None:
                    kv = KeyValueStoreItem(
                        identifier=Helpers.guid(),
                        keyy="ab_call_recording_" + app_entry.identifier,                    
                        expiration=datetime(1970, 1, 1)
                    )
                kv.val = mp3_url
                kv.put()

    elif self.request.get("fn") == "set_value_for_roof_work_choice_1":
        item = RoofWorkItem.first(RoofWorkItem.identifier == self.request.get("identifier"))
        if not item is None:
            info = json.loads(item.info)
            info["rep_selection_one"] = self.request.get("value")
            item.info = json.dumps(info)
            item.put()

    elif self.request.get("fn") == "set_secondary_fund_for_roof_work_item":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "secondary_fund_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="secondary_fund_" + self.request.get("identifier"),
                expiration=datetime(1970, 1, 1)
            )
        kv.val = self.request.get("value")
        kv.put()

    elif self.request.get("fn") == "pull_roof_work_specific_details":
        self.response.content_type = "application/json"
        ret_json = {}
        item = RoofWorkItem.first(RoofWorkItem.identifier == self.request.get("identifier"))
        if not item is None:
            ret_json["data"] = json.loads(item.info)
            ret_json["secondary_fund"] = None
            kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "secondary_fund_" + self.request.get("field_app_identifier"))
            if not kv is None:
                ret_json["secondary_fund"] = kv.val            

            booking = SurveyBooking.first(SurveyBooking.field_app_identifier == item.field_app_identifier)
            if not booking is None:
                ret_json["fund"] = booking.fund

            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
            if not app_entry is None:
                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == app_entry.identifier)
                if not proposal is None:
                    proposal.fix_additional_amount()
                    proposal.fix_system_size()
                    proposal_dict = json.loads(proposal.info)
                    pricing_structures = Helpers.get_pricing_structures()
                    funds = Helpers.list_funds()

                    office = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                    if not office is None:
                        ret_json["total_system_cost"] = Helpers.crunch("fx_Total_System_Cost", office.parent_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        ret_json["total_system_cost"] = round(ret_json["total_system_cost"], 2)
                        ret_json["total_system_cost"] = str(ret_json["total_system_cost"])
                        ret_json["system_size"] = proposal_dict["system_size"]
                        ret_json["formula_1"] = Helpers.crunch("fx_Bill_With_Credits_And_Rebates_Applied", office.parent_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        ret_json["formula_2"] = Helpers.crunch("fx_Solar_Bill_W_No_Tax_Credit", office.parent_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "rep_sp2_schedule_inhouse_v2":
        ret_json = {}
        ret_json["appointments"] = []
        self.response.content_type = "application/json"

        funds = Helpers.list_funds()
        fund_value_prop_required_dict = {}
        for fund in funds:
            if "requires_proposal" in fund.keys():
                fund_value_prop_required_dict[fund["value"]] = fund["requires_proposal"]
            else:
                fund_value_prop_required_dict[fund["value"]] = False
        
        events = CalendarEvent.query(ndb.AND(
            CalendarEvent.start_dt >= Helpers.pacific_now() + timedelta(days=-60),
            CalendarEvent.calendar_key == self.request.get("identifier")
        ))
        app_ids_to_query_negative_one = ["-1"]
        for ev in events:
            if not ev.repeated and ev.event_key == "sp2":
                app_ids_to_query_negative_one.append(ev.field_app_identifier)

        app_identifier_booking_dict = {}

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query_negative_one))

        booking_ids_to_query = ["-1"]
        for booking in bookings:
            if (not booking.archived) and (not booking.save_me) and (booking.has_associated_field_entry) and (booking.associated_rep_id == self.request.get("rep_id")) and (booking.completion_state != 3):
                booking_ids_to_query.append(booking.identifier)
                app_identifier_booking_dict[booking.field_app_identifier] = booking

        field_apps = FieldApplicationEntry.query(FieldApplicationEntry.booking_identifier.IN(booking_ids_to_query))
        
        booking_ids_to_query = ["-1"]
        booking_identifier_idx_dict = {}
        app_cnt = 0
        field_app_identifier_idx_dict = {}
        app_ids_to_query = ["-1"]
        for field_app in field_apps:
            field_app_identifier_idx_dict[field_app.identifier] = len(ret_json["appointments"])
            app_ids_to_query.append(field_app.identifier)
            appt = {}
            appt["identifier"] = field_app.identifier
            appt["booking_identifier"] = field_app.booking_identifier

            appt["phone_number"] = Helpers.format_phone_number(field_app.customer_phone)
            appt["email"] = field_app.customer_email
            appt["name"] = ''.join([field_app.customer_first_name, " ", field_app.customer_last_name])
            appt["address"] = field_app.customer_address
            appt["city"] = field_app.customer_city
            appt["state"] = field_app.customer_state
            appt["hour"] = field_app.sp_two_time.hour
            appt["total_dollars"] = field_app.total_dollars
            appt["total_kwhs"] = field_app.total_kwhs
            appt["locked"] = field_app.deal_locked
            appt["highest_amount"] = field_app.highest_amount
            appt["usage_months"] = field_app.usage_months
            appt["fund"] = None
            appt["credit_notes"] = ""
            appt["tier_option"] = field_app.tier_option
            if appt["tier_option"] == "n/a":
                appt["tier_option"] = "A"

            booking = app_identifier_booking_dict[field_app.identifier]
            appt["fund"] = booking.fund
            appt["requires_proposal"] = False
            if appt["fund"] in fund_value_prop_required_dict.keys():
                appt["requires_proposal"] = fund_value_prop_required_dict[appt["fund"]]
            appt["funding_tier"] = booking.funding_tier
            appt["survey_month"] = booking.booking_month
            appt["survey_day"] = booking.booking_day
            appt["survey_year"] = booking.booking_year
            appt["notes"] = field_app.opt_rep_notes
            appt["total_kwhs"] = field_app.total_kwhs

            appt["ampm"] = "AM"

            if appt["hour"] > 12:
                appt["hour"] = appt["hour"] - 12
                appt["ampm"] = "PM"

            appt["minute"] = field_app.sp_two_time.minute
            appt["month"] = field_app.sp_two_time.month
            appt["day"] = field_app.sp_two_time.day
            appt["year"] = field_app.sp_two_time.year
            appt["closed"] = field_app.deal_closed
            appt["proposal"] = None
            appt["usage_type"] = "estimated"
            appt["sp2_string"] = str(field_app.sp_two_time).split(".")[0]

            booking_identifier = field_app.booking_identifier
            booking_identifier_idx_dict[booking_identifier] = app_cnt
            booking_ids_to_query.append(booking_identifier)            

            ret_json["appointments"].append(appt)
            app_cnt += 1


        #notes = CustomerNote.query(
        #    ndb.AND(
        #        CustomerNote.note_key == "credit_screen_notes",
        #        CustomerNote.field_app_identifier.IN(app_ids_to_query)
        #    )
        #)

        #for note in notes:
        #    ret_json["appointments"][field_app_identifier_idx_dict[note.field_app_identifier]]["credit_notes"] = json.loads(note.content)["txt"][0]

        leads = Lead.query(
            ndb.AND(
                Lead.archived == False,
                Lead.save_me == False,
                Lead.status == "unclaimed",
                Lead.field_app_identifier.IN(app_ids_to_query)
            )
        )

        identifiers_to_remove = []
        for lead in leads:
            identifiers_to_remove.append(lead.field_app_identifier)

        cpy = []
        for item in ret_json["appointments"]:
            if not item["identifier"] in identifiers_to_remove:
                cpy.append(item)

        ret_json["appointments"] = cpy
        #done = False
        #while not done:
        #    count = 0
        #    found_out_of_order_items = False
#
#            while count < len(ret_json["appointments"]):
#                item_a = ret_json["appointments"][count]
#                item_b = None
#                if not (count == len(ret_json["appointments"]) - 1):
#                    item_b = ret_json["appointments"][count + 1]
#
#                if not item_b is None:
#                    y_a = item_a["year"]
#                    y_b = item_b["year"]
#                    m_a = item_a["month"]
#                    m_b = item_b["month"]
#                    d_a = item_a["day"]
#                    d_b = item_b["day"]
#
#                    h_a = item_a["hour"]
#                    h_b = item_b["hour"]

 #                   mm_a = item_a["minute"]
 #                   mm_b = item_b["minute"]

 #                   time_a = datetime(y_a, m_a, d_a, h_a, mm_a, 0)
 #                   time_b = datetime(y_b, m_b, d_b, h_b, mm_b, 0)

  #                  if time_b < time_a:
  #                      lst = []
  #                      lst.append(item_a)
  #                      lst.append(item_b)

#                        ret_json["appointments"][count] = lst[1]
#                        ret_json["appointments"][count + 1] = lst[0]

 #                       found_out_of_order_items = True
 #                       count = len(ret_json["appointments"])

  #              count += 1

  #          done = (not found_out_of_order_items)

        identifier_idx_map = {}
        app_ids_to_query = ["-1"]
        cnt = 0
        for item in ret_json["appointments"]:
            identifier_idx_map[item["identifier"]] = cnt
            app_ids_to_query.append(item["identifier"])
            cnt += 1

        #proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        #for proposal in proposals:
        #    idx = identifier_idx_map[proposal.field_app_identifier]
        #    ret_json["appointments"][idx]["proposal"] = {"info": proposal.info, "version": proposal.version, "identifier": proposal.identifier}

        #keys_to_query = ["-1"]
        #for item in app_ids_to_query:
        #    keys_to_query.append("income_verification_required_" + item)
        #    keys_to_query.append("real_or_estimated_" + item)

        #kv_vals = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        #for kv_val in kv_vals:
        #    if "income_verification" in kv_val.keyy:
        #        app_identifier = kv_val.keyy.replace("income_verification_required_", "")
        #        idx = identifier_idx_map[app_identifier]
        #        ret_json["appointments"][idx]["income_verification_required"] = (kv_val.val == "1")
        #    elif "real_or_estimated_" in kv_val.keyy:
        #        app_identifier = kv_val.keyy.replace("real_or_estimated_", "")
        #        idx = identifier_idx_map[app_identifier]
        #        ret_json["appointments"][idx]["usage_type"] = kv_val.val

        #ret_json["appointments"].reverse()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "rep_sp2_schedule_inhouse":
        ret_json = {}
        ret_json["appointments"] = []
        self.response.content_type = "application/json"

        funds = Helpers.list_funds()
        fund_value_prop_required_dict = {}
        for fund in funds:
            if "requires_proposal" in fund.keys():
                fund_value_prop_required_dict[fund["value"]] = fund["requires_proposal"]
            else:
                fund_value_prop_required_dict[fund["value"]] = False
        
        events = CalendarEvent.query(ndb.AND(
            CalendarEvent.start_dt >= Helpers.pacific_now() + timedelta(days=-60),
            CalendarEvent.calendar_key == self.request.get("identifier")
        ))
        app_ids_to_query_negative_one = ["-1"]
        for ev in events:
            if not ev.repeated and ev.event_key == "sp2":
                app_ids_to_query_negative_one.append(ev.field_app_identifier)

        app_identifier_booking_dict = {}

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query_negative_one))

        #bookings = SurveyBooking.query(
        #    ndb.AND
        #    (
        #        SurveyBooking.has_associated_field_entry == True,
        #        SurveyBooking.associated_rep_id == str(self.session["user_rep_id"]).upper(),
        #        SurveyBooking.completion_state != 3,
        #        SurveyBooking.archived == False,
        #        SurveyBooking.save_me == False
        #    )
        #)

        booking_ids_to_query = ["-1"]
        for booking in bookings:
            if (not booking.archived) and (not booking.save_me) and (booking.has_associated_field_entry) and (booking.associated_rep_id == self.request.get("rep_id")) and (booking.completion_state != 3):
                booking_ids_to_query.append(booking.identifier)
                app_identifier_booking_dict[booking.field_app_identifier] = booking

        now = Helpers.pacific_now()
        #field_apps = FieldApplicationEntry.query(
        #    ndb.AND
        #    (
        #        FieldApplicationEntry.booking_identifier.IN(booking_ids_to_query),
        #        FieldApplicationEntry.sp_two_time > now + timedelta(days=-60)
        #    )
        #)
        field_apps = FieldApplicationEntry.query(FieldApplicationEntry.booking_identifier.IN(booking_ids_to_query))
        
        booking_ids_to_query = ["-1"]
        booking_identifier_idx_dict = {}
        app_cnt = 0
        field_app_identifier_idx_dict = {}
        app_ids_to_query = ["-1"]
        for field_app in field_apps:
            field_app_identifier_idx_dict[field_app.identifier] = len(ret_json["appointments"])
            app_ids_to_query.append(field_app.identifier)
            appt = {}
            appt["identifier"] = field_app.identifier
            appt["booking_identifier"] = field_app.booking_identifier

            appt["phone_number"] = Helpers.format_phone_number(field_app.customer_phone)
            appt["email"] = field_app.customer_email
            appt["name"] = ''.join([field_app.customer_first_name, " ", field_app.customer_last_name])
            appt["address"] = field_app.customer_address
            appt["city"] = field_app.customer_city
            appt["state"] = field_app.customer_state
            appt["hour"] = field_app.sp_two_time.hour
            appt["total_dollars"] = field_app.total_dollars
            appt["total_kwhs"] = field_app.total_kwhs
            appt["locked"] = field_app.deal_locked
            appt["highest_amount"] = field_app.highest_amount
            appt["usage_months"] = field_app.usage_months
            appt["fund"] = None
            appt["credit_notes"] = ""
            appt["tier_option"] = field_app.tier_option
            if appt["tier_option"] == "n/a":
                appt["tier_option"] = "A"

            booking = app_identifier_booking_dict[field_app.identifier]
            appt["fund"] = booking.fund
            appt["requires_proposal"] = False
            if appt["fund"] in fund_value_prop_required_dict.keys():
                appt["requires_proposal"] = fund_value_prop_required_dict[appt["fund"]]
            appt["funding_tier"] = booking.funding_tier
            appt["survey_month"] = booking.booking_month
            appt["survey_day"] = booking.booking_day
            appt["survey_year"] = booking.booking_year
            appt["notes"] = field_app.opt_rep_notes

            appt["ampm"] = "AM"

            if appt["hour"] > 12:
                appt["hour"] = appt["hour"] - 12
                appt["ampm"] = "PM"

            appt["minute"] = field_app.sp_two_time.minute
            appt["month"] = field_app.sp_two_time.month
            appt["day"] = field_app.sp_two_time.day
            appt["year"] = field_app.sp_two_time.year
            appt["closed"] = field_app.deal_closed
            appt["proposal"] = None
            appt["usage_type"] = "estimated"

            booking_identifier = field_app.booking_identifier
            booking_identifier_idx_dict[booking_identifier] = app_cnt
            booking_ids_to_query.append(booking_identifier)            

            ret_json["appointments"].append(appt)
            app_cnt += 1

        notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.note_key == "credit_screen_notes",
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )

        for note in notes:
            ret_json["appointments"][field_app_identifier_idx_dict[note.field_app_identifier]]["credit_notes"] = json.loads(note.content)["txt"][0]

        leads = Lead.query(
            ndb.AND(
                Lead.archived == False,
                Lead.save_me == False,
                Lead.status == "unclaimed",
                Lead.field_app_identifier.IN(app_ids_to_query)
            )
        )

        identifiers_to_remove = []
        for lead in leads:
            identifiers_to_remove.append(lead.field_app_identifier)

        cpy = []
        for item in ret_json["appointments"]:
            if not item["identifier"] in identifiers_to_remove:
                cpy.append(item)

        ret_json["appointments"] = cpy
        done = False
        while not done:
            count = 0
            found_out_of_order_items = False

            while count < len(ret_json["appointments"]):
                item_a = ret_json["appointments"][count]
                item_b = None
                if not (count == len(ret_json["appointments"]) - 1):
                    item_b = ret_json["appointments"][count + 1]

                if not item_b is None:
                    y_a = item_a["year"]
                    y_b = item_b["year"]
                    m_a = item_a["month"]
                    m_b = item_b["month"]
                    d_a = item_a["day"]
                    d_b = item_b["day"]

                    h_a = item_a["hour"]
                    h_b = item_b["hour"]

                    mm_a = item_a["minute"]
                    mm_b = item_b["minute"]

                    time_a = datetime(y_a, m_a, d_a, h_a, mm_a, 0)
                    time_b = datetime(y_b, m_b, d_b, h_b, mm_b, 0)

                    if time_b < time_a:
                        lst = []
                        lst.append(item_a)
                        lst.append(item_b)

                        ret_json["appointments"][count] = lst[1]
                        ret_json["appointments"][count + 1] = lst[0]

                        found_out_of_order_items = True
                        count = len(ret_json["appointments"])

                count += 1

            done = (not found_out_of_order_items)

        identifier_idx_map = {}
        app_ids_to_query = ["-1"]
        cnt = 0
        for item in ret_json["appointments"]:
            identifier_idx_map[item["identifier"]] = cnt
            app_ids_to_query.append(item["identifier"])
            cnt += 1

        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        for proposal in proposals:
            idx = identifier_idx_map[proposal.field_app_identifier]
            ret_json["appointments"][idx]["proposal"] = {"info": proposal.info, "version": proposal.version, "identifier": proposal.identifier}

        keys_to_query = ["-1"]
        for item in app_ids_to_query:
            keys_to_query.append("income_verification_required_" + item)
            keys_to_query.append("real_or_estimated_" + item)

        kv_vals = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_val in kv_vals:
            if "income_verification" in kv_val.keyy:
                app_identifier = kv_val.keyy.replace("income_verification_required_", "")
                idx = identifier_idx_map[app_identifier]
                ret_json["appointments"][idx]["income_verification_required"] = (kv_val.val == "1")
            elif "real_or_estimated_" in kv_val.keyy:
                app_identifier = kv_val.keyy.replace("real_or_estimated_", "")
                idx = identifier_idx_map[app_identifier]
                ret_json["appointments"][idx]["usage_type"] = kv_val.val

        ret_json["appointments"].reverse()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pull_sp2_times_for_rep":
        ret_json = {}
        ret_json["appointments"] = []

        pw = Helpers.hash_pass(self.request.get("password"))
        users = FieldApplicationUser.query(
            ndb.OR
            (
                ndb.AND
                (
                    FieldApplicationUser.rep_email == self.request.get("email_rep_id"),
                    FieldApplicationUser.password == pw,
                    FieldApplicationUser.current_status == 0
                ),
                ndb.AND
                (
                    FieldApplicationUser.rep_id == self.request.get("email_rep_id"),
                    FieldApplicationUser.password == pw,
                    FieldApplicationUser.current_status == 0
                )
            )
        )
        r_id = "-1"
        login_correct = False
        for user in users:
            login_correct = True
            r_id = user.rep_id
            bookings = SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.has_associated_field_entry == True,
                    SurveyBooking.associated_rep_id == r_id,
                )
            )

            booking_ids_to_query = ["-1"]
            for booking in bookings:
                if booking.archived:
                    continue

                booking_ids_to_query.append(booking.identifier)

            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.booking_identifier.IN(booking_ids_to_query))
            now = Helpers.pacific_now()
            for field_app in field_apps:
                if field_app.sp_two_time > now:
                    appt = {}
                    appt["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                    appt["address"] = field_app.customer_address
                    appt["city"] = field_app.customer_city
                    appt["state"] = field_app.customer_state
                    appt["hour"] = field_app.sp_two_time.hour
                    appt["ampm"] = "AM"

                    if appt["hour"] > 12:
                        appt["hour"] = appt["hour"] - 12
                        appt["ampm"] = "PM"

                    appt["minute"] = field_app.sp_two_time.minute
                    appt["month"] = field_app.sp_two_time.month
                    appt["day"] = field_app.sp_two_time.day
                    appt["year"] = field_app.sp_two_time.year

                    ret_json["appointments"].append(appt)

            done = False
            while not done:
                count = 0
                found_out_of_order_items = False

                while count < len(ret_json["appointments"]):
                    item_a = ret_json["appointments"][count]
                    item_b = None
                    if not (count == len(ret_json["appointments"]) - 1):
                        item_b = ret_json["appointments"][count + 1]

                    if not item_b is None:
                        y_a = item_a["year"]
                        y_b = item_b["year"]
                        m_a = item_a["month"]
                        m_b = item_b["month"]
                        d_a = item_a["day"]
                        d_b = item_b["day"]

                        h_a = item_a["hour"]
                        h_b = item_b["hour"]

                        mm_a = item_a["minute"]
                        mm_b = item_b["minute"]

                        time_a = datetime(y_a, m_a, d_a, h_a, mm_a, 0)
                        time_b = datetime(y_b, m_b, d_b, h_b, mm_b, 0)

                        if time_b < time_a:
                            lst = []
                            lst.append(item_a)
                            lst.append(item_b)

                            ret_json["appointments"][count] = lst[1]
                            ret_json["appointments"][count + 1] = lst[0]

                            found_out_of_order_items = True
                            count = len(ret_json["appointments"])

                    count += 1

                done = (not found_out_of_order_items)


            self.response.out.write(json.dumps(ret_json))

        if not login_correct:
            self.response.out.write("error")

    elif self.request.get("fn") == "list_offices":
        if not (str(self.request.get("plain_txt")) == "1"):
            self.response.content_type = "application/json"

        ret_json = {}
        ret_json["offices"] = []
        office_locations = OfficeLocation.query(OfficeLocation.parent_identifier != "n/a")
        for office_location in office_locations:
            office = {}
            office["identifier"] = office_location.identifier
            office["name"] = office_location.name
            ret_json["offices"].append(office)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sp2_schedule_admin":
        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sp2_schedule_admin_weekly_export":
        st = datetime(int(self.request.get("year")), int(self.request.get("month")), int(self.request.get("day")))
        et = st + timedelta(days=1)
        et = et + timedelta(minutes=-1)
        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"), st, et)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sp2_schedule_admin_weekly_export_by_office":
        st = datetime(int(self.request.get("year")), int(self.request.get("month")), int(self.request.get("day")))
        et = st + timedelta(days=1)
        et = et + timedelta(minutes=-1)
        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"), st, et, self.request.get("office_identifier"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sp2_schedule_admin_monthly_export":
        st = datetime(int(self.request.get("year")), int(self.request.get("month")), 1)
        #we're at the first of the month'
        et = Helpers.string_to_datetime(str(st))

        m = et.month
        tm = m + 1

        while m < tm:
            et = et + timedelta(days=1)
            m = et.month

        et = et + timedelta(days=-1)
        et = et + timedelta(hours=23)
        et = et + timedelta(minutes=59)

        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"), st, et)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sp2_schedule_admin_annual_export_by_office":
        st = datetime(int(self.request.get("year")), 1, 1)

        et = datetime(int(self.request.get("year")), 12, 31, 11, 59, 0)
        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"), st, et, self.request.get("office_identifier"))
        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "sp2_schedule_admin_monthly_export_by_office":
        st = datetime(int(self.request.get("year")), int(self.request.get("month")), 1)
        #we're at the first of the month'
        et = Helpers.string_to_datetime(str(st))

        m = et.month
        tm = m + 1

        while m < tm:
            et = et + timedelta(days=1)
            m = et.month

        et = et + timedelta(days=-1)
        et = et + timedelta(hours=23)
        et = et + timedelta(minutes=59)

        ret_json = Helpers.get_admin_sp2_items(self.request.get("email_rep_id"), self.request.get("password"), st, et, self.request.get("office_identifier"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_ledger_search_users":
        self.response.content_type = "application/json"
        vals = json.loads(self.request.get("vals"))
        ret_json = {}
        ret_json["users"] = []

        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"]),
                FieldApplicationUser.current_status == 0
            )
        )
        for user in users:
            include = True
            fname = user.first_name.lower()
            if not vals["fname_val"] is None:
                fname2 = vals["fname_val"].lower()
                try:
                    idx = fname.index(fname2)
                    include = (idx == 0)

                except:
                    include = False

            if include:
                lname = user.last_name.lower()
                if not vals["lname_val"] is None:
                    lname2 = vals["lname_val"].lower()
                    try:
                        idx2 = lname.index(lname2)
                        include = (idx2 == 0)

                    except:
                        include = False

            if include:
                rid = user.rep_id.upper()
                if not vals["rid_val"] is None:
                    rid2 = vals["rid_val"].upper()
                    try:
                        idx3 = rid.index(rid2)
                        include = (idx3 == 0)

                    except:
                        include = False

            if include:
                user_item = {}
                user_item["identifier"] = user.identifier
                user_item["rep_id"] = user.rep_id
                user_item["name"] = user.first_name + " " + user.last_name
                ret_json["users"].append(user_item)


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_monetary_transactions":
        transactions = json.loads(self.request.get("transactions"))
        trans_entities = []

        for transaction in transactions:
            e_d = datetime(transaction["date"]["year"], transaction["date"]["month"], transaction["date"]["day"], 0, 0, 0) + timedelta(days=-7)
            e_d = e_d + timedelta(minutes=-2)
            amt = float(transaction["amount"])
            dollars = int(amt)
            cents = int((amt * 100) % 100)

            if transaction["polarity"] == "-":
                dollars *= -1
                cents *= -1

            c_num = "-1"
            this_upcoming_friday = Helpers.pacific_today()
            weekday = this_upcoming_friday.isoweekday()

            while (not weekday == 5):
                this_upcoming_friday = this_upcoming_friday + timedelta(days=1)
                weekday = this_upcoming_friday.isoweekday()

            kkkey = "check_number_for_" + transaction["user_identifier"] + "_" + str(this_upcoming_friday).split(" ")[0]

            kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy == kkkey)
            for kv_item in kv_items:
                c_num = kv_item.val

            t_entity = MonetaryTransaction(
                identifier=Helpers.guid(),
                recorded_by=self.session["user_identifier"],
                description=transaction["description"],
                description_key="generic",
                recorded_dt=Helpers.pacific_now(),
                effective_dt=e_d,
                paid=False,
                recipient=transaction["user_identifier"],
                dollars=dollars,
                cents=cents,
                tax_applicable=transaction["taxable"],
                check_number=c_num,
                approved=True,
                denied=False,
                extra_info="{}"
            )

            trans_entities.append(t_entity)

        if len(trans_entities) == 1:
            trans_entities[0].put()
        else:
            ndb.put_multi(trans_entities)

    elif self.request.get("fn") == "list_users_for_paycheck_preview_admin":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        reps = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.user_type.IN(["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "sales_manager", "energy_expert"]),
                FieldApplicationUser.current_status == 0
            )
        ).order(FieldApplicationUser.first_name).order(FieldApplicationUser.last_name)

        for rep in reps:
            rep_item = {}
            rep_item["first_name"] = rep.first_name
            rep_item["last_name"] = rep.last_name
            rep_item["office_identifier"] = rep.main_office
            rep_item["identifier"] = rep.identifier
            rep_item["rep_id"] = rep.rep_id

            ret_json["users"].append(rep_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "admin_upcoming_paycheck_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["paycheck_data"] = Helpers.calculate_upcoming_paycheck_for_rep(self.request.get("identifier"))
        ret_json["has_check_number"] = False

        this_upcoming_friday = Helpers.pacific_today()
        weekday = this_upcoming_friday.isoweekday()

        while (not weekday == 5):
            this_upcoming_friday = this_upcoming_friday + timedelta(days=1)
            weekday = this_upcoming_friday.isoweekday()

        key = "check_number_for_" + self.request.get("identifier") + "_" + str(this_upcoming_friday).split(" ")[0]
        kvi_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy == key)
        for kvi_item in kvi_items:
            ret_json["has_check_number"] = True
            ret_json["check_number"] = kvi_item.val

        ret_json["paid"] = False
        key2 = "check_paid_for_" + self.request.get("identifier") + "_" + str(this_upcoming_friday).split(" ")[0]

        kvi_items2 = KeyValueStoreItem.query(KeyValueStoreItem.keyy == key2)
        for kvi_item2 in kvi_items2:
            ret_json["paid"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "check_number_exists":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["exists"] = False
        check_num = self.request.get("check_no")
        transactions = MonetaryTransaction.query(
        ndb.AND
            (
                MonetaryTransaction.check_number == check_num,
                MonetaryTransaction.approved == True,
                MonetaryTransaction.denied == False
            )
        )

        for transaction in transactions:
            ret_json["exists"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_check_number":
        identifiers = json.loads(self.request.get("identifiers"))
        identifiers.append("-1")
        transactions = MonetaryTransaction.query(
            ndb.AND
            (
                MonetaryTransaction.identifier.IN(identifiers),
                MonetaryTransaction.approved == True,
                MonetaryTransaction.denied == False
            )
        )
        transactions_to_save = []
        user = ""
        for transaction in transactions:
            transaction.check_number = self.request.get("check_no")
            if user == "":
                user = transaction.recipient
            transactions_to_save.append(transaction)


        saved = False
        if len(transactions_to_save) > 1:
            ndb.put_multi(transactions_to_save)
            saved = True

        elif len(transactions_to_save) == 1:
            transactions_to_save[0].put()
            saved = True

        else:
            transactions_to_save = transactions_to_save

        if saved:
            this_upcoming_friday = Helpers.pacific_today()
            weekday = this_upcoming_friday.isoweekday()

            while (not weekday == 5):
                this_upcoming_friday = this_upcoming_friday + timedelta(days=1)
                weekday = this_upcoming_friday.isoweekday()

            key = "check_number_for_" + user + "_" + str(this_upcoming_friday).split(" ")[0]
            value = self.request.get("check_no")

            kvi = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy=key,
                val=value,
                expiration=datetime(1970, 1, 1)
            )
            kvi.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "change_check_number":
        identifiers = json.loads(self.request.get("identifiers"))
        identifiers.append("-1")
        transactions = MonetaryTransaction.query(
            ndb.AND
            (
                MonetaryTransaction.identifier.IN(identifiers),
                MonetaryTransaction.approved == True,
                MonetaryTransaction.denied == False
            )
        )
        transactions_to_save = []
        user = ""
        for transaction in transactions:
            transaction.check_number = self.request.get("check_no")
            if user == "":
                user = transaction.recipient
            transactions_to_save.append(transaction)

        saved = False
        if len(transactions_to_save) > 1:
            ndb.put_multi(transactions_to_save)
            saved = True

        elif len(transactions_to_save) == 1:
            transactions_to_save[0].put()
            saved = True

        else:
            transactions_to_save = transactions_to_save

        if saved:
            this_upcoming_friday = Helpers.pacific_today()
            weekday = this_upcoming_friday.isoweekday()

            while (not weekday == 5):
                this_upcoming_friday = this_upcoming_friday + timedelta(days=1)
                weekday = this_upcoming_friday.isoweekday()

            key = "check_number_for_" + user + "_" + str(this_upcoming_friday).split(" ")[0]
            value = self.request.get("check_no")

            kvi_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy == key)
            for kvi_item in kvi_items:
                kvi_item.val = value
                kvi_item.put()

    elif self.request.get("fn") == "mark_transactions_paid":
        this_upcoming_friday = datetime(int(self.request.get("friday").split("-")[2]), int(self.request.get("friday").split("-")[0]), int(self.request.get("friday").split("-")[1]))

        mts = MonetaryTransaction.query(
            ndb.AND
            (
                MonetaryTransaction.check_number == self.request.get("check_no"),
                MonetaryTransaction.approved == True,
                MonetaryTransaction.denied == False
            )
        )
        mts_to_put = []
        for mt in mts:
            mt.paid = True
            mts_to_put.append(mt)

        create_kvi = False

        if len(mts_to_put) == 1:
            mts_to_put[0].put()
            create_kvi = True

        elif len(mts_to_put) > 1:
            ndb.put_multi(mts_to_put)
            create_kvi = True

        else:
            mts_to_put = mts_to_put

        key = "check_paid_for_" + self.request.get("user_identifier") + "_" + str(this_upcoming_friday).split(" ")[0]

        if create_kvi:
            kvi = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy = key,
                val = "1",
                expiration=datetime(1970, 1, 1)
            )
            kvi.put()

    elif self.request.get("fn") == "ensure_checks_are_open":
        self.response.content_type = "application/json"
        payday = datetime(int(self.request.get("friday").split("-")[2]), int(self.request.get("friday").split("-")[0]), int(self.request.get("friday").split("-")[1]))

        keys = ["-1"]
        user_identifiers = json.loads(self.request.get("user_identifiers"))

        ret_json = {}
        ret_json["answers"] = []

        identifier_idx_map = {}
        for user_identifier in user_identifiers:
            obj = {}
            obj["result"] = True
            obj["identifier"] = user_identifier

            identifier_idx_map[user_identifier] = len(ret_json["answers"])

            ret_json["answers"].append(obj)

            keys.append("check_paid_for_" + user_identifier + "_" + str(payday).split(" ")[0])

        kvi_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys))
        for kvi_item in kvi_items:
            key = kvi_item.keyy
            u_id = key.replace("check_paid_for_", "").split("_")[0]
            idx = identifier_idx_map[u_id]
            ret_json["answers"][idx]["result"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_mosaic_credentials":
        self.response.content_type = "application/json"
        dct = Helpers.get_mosaic_credentials()
        dct["ip"] = Helpers.get_mosaic_ip()
        self.response.out.write(json.dumps(Helpers.get_mosaic_credentials()))

    elif self.request.get("fn") == "reg_mgr_confirm":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["result"] = Helpers.check_registration_keycode(self.request.get("keycode"), self.request.get("mgr_key"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "test_mosaic_credentials":
        self.response.content_type = "application/json"
        ip = Helpers.get_mosaic_ip()
        token = Helpers.guid()
        json_to_pass = {}
        json_to_pass["username"] = self.request.get("email")
        json_to_pass["password"] = self.request.get("password")
        json_to_pass["job_type"] = "verify_credentials"
        json_to_pass["token"] = token

        form_fields = {}
        form_fields["json"] = json.dumps(json_to_pass)

        resp = urlfetch.fetch(
            url="http://" + ip + "/insert_job.php",
            method=urlfetch.POST,
            payload=urllib.urlencode(form_fields),
            deadline=10,
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        )
        ret_json = {}
        ret_json["success"] = False
        form_fields =  {}
        form_fields["identifier"] = token
        count = 0
        while count < 15 and (not ret_json["success"]):

            try:
                resp2 = urlfetch.fetch(
                    url="http://" + ip + "/job_status.php",
                    method=urlfetch.POST,
                    payload=urllib.urlencode(form_fields),
                    deadline=10,
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                )
                json_response = json.loads(resp2.content)
                if json_response["finished"]:
                    count += 15;
                    ret_json["success"] = json_response["message"]["passed"]

                time.sleep(3)
                count += 1

            except:
                count += 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "store_mosaic_credentials":
        ip = Helpers.get_mosaic_ip()
        dct = {}
        dct["username"] = self.request.get("email")
        dct["password"] = self.request.get("password")
        jaysawn = json.dumps(dct)
        encrypted_txt = Helpers.encrypt(jaysawn)

        form_fields = {}
        form_fields["json"] = jaysawn
        resp = urlfetch.fetch(
            url="http://" + ip + "/update_credentials.php",
            method=urlfetch.POST,
            payload=urllib.urlencode(form_fields),
            deadline=20,
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        )

        json_response = json.loads(resp.content)

        if json_response["success"]:
            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            filename = bucket + '/ApplicationSettings/mosaic_info_' + app_identity.get_application_id() + '.txt'

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)

            gcs_file = gcs.open(
                            filename,
                            'w',
                            content_type="text/plain",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params
            )
            gcs_file.write(encrypted_txt)
            gcs_file.close()

            keyy = "mosaic_login_credentials"
            memcache.delete(keyy)

    elif self.request.get("fn") == "poll_mosaic":
        self.response.content_type = "application/json"

        ip = Helpers.get_mosaic_ip()

        form_fields = {}
        form_fields["identifier"] = self.request.get("token")
        resp = urlfetch.fetch(
            url="http://" + ip + "/job_status.php",
            method=urlfetch.POST,
            payload=urllib.urlencode(form_fields),
            deadline=20,
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        )
        time.sleep(1)
        json_response = json.loads(resp.content)
        ret_json = {}
        ret_json["finished"] = json_response["finished"]
        if ret_json["finished"]:
            ret_json["mosaic_id"] = json_response["message"]["opportunity_id"]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sr_test":
        email = "chuckee@peperoni.com"
        first_name = "Chuckee"
        last_name = "Cheeses"
        form_office = "Murrieta"

        sales_rabbit_id = Helpers.grant_sales_rabbit_access(email,first_name,last_name,form_office)

        logging.info(sales_rabbit_id)

        self.response.out.write(" ")

    elif self.request.get("fn") == "box_test":
        email = unicode("samuelhames@gmail.com")
        user_type = "survey"

        box_resp = Helpers.grant_box_collaboration(email,user_type)

        logging.info(box_resp)

        self.response.out.write(" ")

    elif self.request.get("fn") == "manual_box_auth":
        state = None
        code = None
        server = self.request.environ["SERVER_NAME"]

        auth_url, csrf_token = Helpers.get_box_auth(server,state,code)
        memcache.set("box_csrf_token", csrf_token, 3600)
        self.response.write('<html><body><div><a href="'+auth_url+'">Authorize Box</a></div></body></html>')

    elif self.request.get("fn") == "box_oauth":
        state = self.request.get("state")
        code = self.request.get("code")
        server = self.request.environ["SERVER_NAME"]

        Helpers.get_box_auth(server,state,code)

        self.response.out.write("<html><body><div>Success!!!</div></body></html>")

    elif self.request.get("fn") == "box_refresh":
        refresh = Helpers.refresh_box_auth()

        self.response.out.write(refresh)

    elif self.request.get("fn") == "init_surveyor_perms":
        users_to_save = []
        users = FieldApplicationUser.query(FieldApplicationUser.user_type == "survey")
        for user in users:
            offices = json.loads(user.allowed_offices)
            if not user.main_office in offices:
                offices.append(user.main_office)
                user.allowed_offices = json.dumps(offices)
                users_to_save.append(user)

        if len(users_to_save) == 1:
            users_to_save[0].put()

        elif len(users_to_save) > 1:
            ndb.put_multi(users_to_save)

        else:
            users_to_save = users_to_save

        self.response.out.write(" ")

    elif self.request.get("fn") == "list_surveyor_access_permission":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["surveyors"] = []
        users = FieldApplicationUser.query(FieldApplicationUser.user_type == "survey").order(FieldApplicationUser.first_name).order(FieldApplicationUser.last_name)
        for user in users:
            surveyor_item = {}
            surveyor_item["name"] = user.first_name + " " + user.last_name
            surveyor_item["identifier"] = user.identifier;
            surveyor_item["allowed_offices"] = json.loads(user.allowed_offices)
            ret_json["surveyors"].append(surveyor_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_surveyor_perm":
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.user_type == "survey",
                FieldApplicationUser.identifier == self.request.get("user_identifier")
            )
        )
        for user in users:
            allowed_offices = json.loads(user.allowed_offices)
            if self.request.get("perm") == "allow":
                if not self.request.get("office_identifier") in allowed_offices:
                    allowed_offices.append(self.request.get("office_identifier"))

            if self.request.get("perm") == "disallow":
                if self.request.get("office_identifier") in allowed_offices:
                    cpy = []
                    for allowed_office in allowed_offices:
                        if not allowed_office == self.request.get("office_identifier"):
                            cpy.append(allowed_office)

                    allowed_offices = json.loads(json.dumps(cpy))

            user.allowed_offices = json.dumps(allowed_offices)
            user.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "get_customer_progress_info_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["items"] = []
        step = self.request.get("step")
        go_by_original_submission_date = (step == "pending_perm_approved")
        ri = str(self.session["user_identifier"])

        if step == "pp_sub":
            items = PerfectPacketEntry.query(
                ndb.AND
                (
                    PerfectPacketEntry.rep_completion_state == 0,
                    PerfectPacketEntry.archived == False,
                    PerfectPacketEntry.rep_identifier == ri,
                    PerfectPacketEntry.save_me == False
                )
            )

            packet_entry_identifier_idx_dict = {}
            field_app_identifier_packet_entry_identifier_dict = {}

            field_app_ids_to_query = ["-1"]
            booking_ids_to_query = ["-1"]
            count = 0
            for item in items:
                item_dict = {}
                item_dict["identifier"] = item.identifier
                item_dict["date"] = {}
                item_dict["date"]["year"] = 1970
                item_dict["date"]["month"] = 1
                item_dict["date"]["day"] = 1
                item_dict["name"] = None
                item_dict["step_key"] = step
                item_dict["booking_identifier"] = item.booking_identifier
                item_dict["field_app_identifier"] = item.field_application_identifier

                ret_json["items"].append(item_dict)

                packet_entry_identifier_idx_dict[item.identifier] = count

                field_app_identifier_packet_entry_identifier_dict[item.field_application_identifier] = item.identifier
                field_app_ids_to_query.append(item_dict["field_app_identifier"])
                booking_ids_to_query.append(item.booking_identifier)
                count += 1

            booking_identifier_idx_dict = {}
            count = 0
            for item in ret_json["items"]:
                booking_identifier_idx_dict[item["booking_identifier"]] = count
                count += 1

            new_items = []
            bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query)).order(SurveyBooking.booking_year).order(SurveyBooking.booking_month).order(SurveyBooking.booking_day)
            for booking in bookings:
                new_item = ret_json["items"][booking_identifier_idx_dict[booking.identifier]]
                new_item["date"]["year"] = booking.booking_year
                new_item["date"]["month"] = booking.booking_month
                new_item["date"]["day"] = booking.booking_day
                new_item["name"] = booking.name
                new_items.append(new_item)

            apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
            app_ids_to_delete = []

            for app in apps:
                if app.has_holds:
                    app_ids_to_delete.append(app.identifier)

            ret_json["items"] = new_items
            new_items2 = []

            for item in ret_json["items"]:
                if not item["field_app_identifier"] in app_ids_to_delete:
                    new_items2.append(item)

            ret_json["items"] = new_items2

        elif step == "pp_pending_approval" or step == "pp_rejected_pending_resubmission":
            packet_entry_identifier_idx_dict = {}
            field_app_identifier_idx_dict = {}
            field_app_ids_to_query = ["-1"]
            field_app_ids_to_delete = ["-1"]
            packet_entry_ids_to_query = ["-1"]
            packet_submission_ids_to_query = ["-1"]
            count = 0

            pp_entries = PerfectPacketEntry.query(
                ndb.AND
                (
                    PerfectPacketEntry.rep_completion_state == 1,
                    PerfectPacketEntry.archived == False,
                    PerfectPacketEntry.rep_identifier == ri
                )
            ).order(PerfectPacketEntry.rep_completion_date)

            for item in pp_entries:
                if not item.save_me:
                    item_dict = {}
                    item_dict["identifier"] = item.identifier
                    item_dict["date"] = {}
                    item_dict["date"]["year"] = item.rep_completion_date.year
                    item_dict["date"]["month"] = item.rep_completion_date.month
                    item_dict["date"]["day"] = item.rep_completion_date.day
                    item_dict["name"] = None
                    item_dict["step_key"] = step
                    item_dict["booking_identifier"] = item.booking_identifier
                    item_dict["field_app_identifier"] = item.field_application_identifier

                    ret_json["items"].append(item_dict)

                    packet_entry_identifier_idx_dict[item.identifier] = count

                    packet_entry_ids_to_query.append(item.identifier)

                    count += 1


            pp_subs = PerfectPacketSubmission.query(
                ndb.AND
                (
                    PerfectPacketSubmission.archived == False,
                    PerfectPacketSubmission.save_me == False,
                    PerfectPacketSubmission.packet_entry_identifier.IN(packet_entry_ids_to_query),
                    PerfectPacketSubmission.rejected == (step == "pp_rejected_pending_resubmission")
                )
            )

            for pp_sub in pp_subs:
                packet_submission_ids_to_query.append(pp_sub.identifier)
                ret_json["items"][packet_entry_identifier_idx_dict[pp_sub.packet_entry_identifier]]["rejected"] = (pp_sub.rejected) and (not pp_sub.approved)
                ret_json["items"][packet_entry_identifier_idx_dict[pp_sub.packet_entry_identifier]]["submission_identifier"] = pp_sub.identifier

            packet_entry_identifiers_to_exclude = []
            pp_approvals = PerfectPacketApproval.query(PerfectPacketApproval.packet_submission_identifier.IN(packet_submission_ids_to_query))
            for pp_approval in pp_approvals:
                packet_entry_identifiers_to_exclude.append(pp_approval.packet_entry_identifier)

            for item in ret_json["items"]:
                if not "rejected" in item.keys() and not item["identifier"] in packet_entry_identifiers_to_exclude:
                    packet_entry_identifiers_to_exclude.append(item["identifier"])

            count = 0
            new_items_list = []
            for item in ret_json["items"]:
                if not item["identifier"] in packet_entry_identifiers_to_exclude:
                    new_items_list.append(item)
                    field_app_ids_to_query.append(item["field_app_identifier"])
                    field_app_identifier_idx_dict[item["field_app_identifier"]] = count
                    count += 1

            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))

            for field_app in field_apps:
                new_items_list[field_app_identifier_idx_dict[field_app.identifier]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                if field_app.has_holds:
                    field_app_ids_to_delete.append(field_app.identifier)

            ret_json["items"] = new_items_list

            new_items_list2 = []
            for item in ret_json["items"]:
                if not item["field_app_identifier"] in field_app_ids_to_delete:
                    new_items_list2.append(item)

            ret_json["items"] = new_items_list2

        elif step == "perm_sub_pending":
            packet_approval_identifier_idx_dict = {}
            field_app_identifier_idx_dict = {}
            field_app_ids_to_query = ["-1"]
            packet_approval_ids_to_query = ["-1"]
            count = 0

            pp_approvals = PerfectPacketApproval.query(
                ndb.AND
                (
                    PerfectPacketApproval.progress_closed == False,
                    PerfectPacketApproval.rep_identifier == ri
                )
            ).order(PerfectPacketApproval.approval_date)

            for item in pp_approvals:
                if item.archived or item.save_me:
                    continue

                item_dict = {}
                item_dict["identifier"] = item.identifier
                item_dict["date"] = {}
                item_dict["date"]["year"] = item.approval_date.year
                item_dict["date"]["month"] = item.approval_date.month
                item_dict["date"]["day"] = item.approval_date.day
                item_dict["name"] = None
                item_dict["step_key"] = step
                item_dict["booking_identifier"] = item.booking_identifier
                item_dict["field_app_identifier"] = item.field_application_identifier

                ret_json["items"].append(item_dict)

                packet_approval_identifier_idx_dict[item.identifier] = count
                packet_approval_ids_to_query.append(item.identifier)

                count += 1

            identifiers_to_exclude = []
            prog_items = CustomerProgressItem.query(CustomerProgressItem.entity_identifier.IN(packet_approval_ids_to_query))

            for prog_item in prog_items:
                identifiers_to_exclude.append(prog_item.entity_identifier)

            cnt = 0
            for identifier_to_exclude in identifiers_to_exclude:
                idx = packet_approval_identifier_idx_dict[identifier_to_exclude]
                del ret_json["items"][idx - cnt]
                cnt += 1

            cnt = 0
            for item in ret_json["items"]:
                field_app_ids_to_query.append(item["field_app_identifier"])
                field_app_identifier_idx_dict[item["field_app_identifier"]] = cnt
                cnt += 1

            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
            field_app_ids_to_delete = []

            for field_app in field_apps:
                ret_json["items"][field_app_identifier_idx_dict[field_app.identifier]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name

                if field_app.has_holds:
                    field_app_ids_to_delete.append(field_app.identifier)

            items2 = []
            for item in ret_json["items"]:
                if not item["field_app_identifier"] in field_app_ids_to_delete:
                    items2.append(item)

            ret_json["items"] = items2
        else:
            util_providers = Helpers.list_utility_providers()
            util_value_value_friendly_dict = {}
            for provider in util_providers:
                util_value_value_friendly_dict[provider["value"]] = provider["value_friendly"]

            b_ids_to_query = ["-1"]
            p_approvels = PerfectPacketApproval.query(PerfectPacketApproval.rep_identifier == ri)
            for p_approval in p_approvels:
                if (not p_approval.archived) and (not p_approval.save_me):
                    b_ids_to_query.append(p_approval.booking_identifier)

            items = CustomerProgressItem.query(
                ndb.AND
                (
                    CustomerProgressItem.step_state == step,
                    CustomerProgressItem.booking_identifier.IN(b_ids_to_query),
                    CustomerProgressItem.closed == (step == "operation_perm"),
                    CustomerProgressItem.archived == False
                )
            ).order(CustomerProgressItem.updated)

            include_rej_count = (step == "perm_rejected_pending_resubmission")

            entity_identifier_idx_dict = {}
            entity_identifiers_to_query = ["-1"]
            field_app_ids_to_query = ["-1"]
            field_app_identifier_entity_identifier_dict = {}

            count = 0
            for item in items:
                item_dict = {}
                item_dict["identifier"] = item.entity_identifier
                item_dict["date"] = {}
                item_dict["date"]["year"] = item.updated.year
                item_dict["date"]["month"] = item.updated.month
                item_dict["date"]["day"] = item.updated.day
                item_dict["name"] = None
                item_dict["step_key"] = step
                item_dict["utility_provider"] = "Missing"
                item_dict["extras"] = json.loads(item.extra_info)

                item_dict["booking_identifier"] = item.booking_identifier
                item_dict["f_app_identifier"] = item.field_app_identifier

                if include_rej_count:
                    item_dict["rejection_count"] = 0
                    dct = json.loads(item.extra_info)
                    if "rejection_dates" in dct.keys():
                        item_dict["rejection_count"] += len(dct["rejection_dates"])

                ret_json["items"].append(item_dict)

                field_app_identifier_entity_identifier_dict[item.field_app_identifier] = item.entity_identifier
                field_app_ids_to_query.append(item.field_app_identifier)
                entity_identifier_idx_dict[item.entity_identifier] = count
                entity_identifiers_to_query.append(item.entity_identifier)

                count += 1

            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
            field_app_ids_to_delete = []

            for field_app in field_apps:
                ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["field_app_identifier"] = field_app.identifier

                if field_app.utility_provider in util_value_value_friendly_dict.keys():
                    ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["utility_provider"] = util_value_value_friendly_dict[field_app.utility_provider]

                if field_app.has_holds:
                    field_app_ids_to_delete.append(field_app.identifier)

                items2 = []
                for item in ret_json["items"]:
                    if not item["f_app_identifier"] in field_app_ids_to_delete:
                        items2.append(item)

                ret_json["items"] = items2

            #some extra tweaks.....

        if go_by_original_submission_date:
            entity_identifiers_to_query = ["-1"]
            for item in ret_json["items"]:
                entity_identifiers_to_query.append(item["identifier"])

            archives = CustomerProgressArchive.query(
                ndb.AND
                (
                    CustomerProgressArchive.step_state == "pending_perm_approved",
                    CustomerProgressArchive.entity_identifier.IN(entity_identifiers_to_query)
                )
            ).order(CustomerProgressArchive.updated)

            updated_lst = []

            for archive in archives:
                entity_identifier = archive.entity_identifier
                if not entity_identifier in updated_lst:
                    logging.info(entity_identifier_idx_dict)
                    idx = entity_identifier_idx_dict[entity_identifier]
                    ret_json["items"][idx]["date"]["year"] = archive.updated.year
                    ret_json["items"][idx]["date"]["month"] = archive.updated.month
                    ret_json["items"][idx]["date"]["day"] = archive.updated.day
                    updated_lst.append(entity_identifier)

            for item in ret_json["items"]:
                item["dt"] = datetime(item["date"]["year"], item["date"]["month"], item["date"]["day"], 1, 30)

            Helpers.bubble_sort(ret_json["items"], "dt")

            for item in ret_json["items"]:
                del item["dt"]

        idxs_to_delete = []
        cnt = 0
        for item in ret_json["items"]:
            if item["name"] is None:
                idxs_to_delete.append(cnt)
            cnt += 1

        del_cnt = 0
        for idx in idxs_to_delete:
            del ret_json["items"][idx - del_cnt]
            del_cnt += 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_customer_progress_info_admin":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["items"] = []
        step = self.request.get("step")
        go_by_original_submission_date = (step == "pending_perm_approved")

        if step == "pp_sub":
            n = datetime.now()

            gcs_file = GCSLockedFile("/CustomerProgressCache/pp_sub_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json")
            result = gcs_file.read()
            if not result is None:
                ret_json["items"] = json.loads(result)
            else:
                items = PerfectPacketEntry.query(
                    ndb.AND
                    (
                        PerfectPacketEntry.rep_completion_state == 0,
                        PerfectPacketEntry.archived == False,
                        PerfectPacketEntry.save_me == False
                    )
                )

                packet_entry_identifier_idx_dict = {}
                field_app_identifier_packet_entry_identifier_dict = {}
                field_app_identifier_idx_dict = {}

                field_app_ids_to_query = ["-1"]
                booking_ids_to_query = ["-1"]
                count = 0
                for item in items:
                    item_dict = {}
                    item_dict["identifier"] = item.identifier
                    item_dict["date"] = {}
                    item_dict["date"]["year"] = 1970
                    item_dict["date"]["month"] = 1
                    item_dict["date"]["day"] = 1
                    item_dict["name"] = None
                    item_dict["step_key"] = step
                    item_dict["booking_identifier"] = item.booking_identifier
                    item_dict["field_app_identifier"] = item.field_application_identifier
                    field_app_ids_to_query.append(item.field_application_identifier)

                    ret_json["items"].append(item_dict)

                    packet_entry_identifier_idx_dict[item.identifier] = count

                    field_app_identifier_packet_entry_identifier_dict[item.field_application_identifier] = item.identifier
                    field_app_identifier_idx_dict[item_dict["field_app_identifier"]] = count
                    booking_ids_to_query.append(item.booking_identifier)
                    count += 1

                booking_identifier_idx_dict = {}
                count = 0
                for item in ret_json["items"]:
                    booking_identifier_idx_dict[item["booking_identifier"]] = count
                    count += 1

                new_items = []
                bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query)).order(SurveyBooking.booking_year).order(SurveyBooking.booking_month).order(SurveyBooking.booking_day)
                for booking in bookings:
                    new_item = ret_json["items"][booking_identifier_idx_dict[booking.identifier]]
                    new_item["date"]["year"] = booking.booking_year
                    new_item["date"]["month"] = booking.booking_month
                    new_item["date"]["day"] = booking.booking_day
                    new_item["name"] = booking.name
                    new_items.append(new_item)

                ret_json["items"] = new_items
                new_items2 = []
                apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))

                for app in apps:
                    if not app.has_holds:
                        new_items2.append(ret_json["items"][field_app_identifier_idx_dict[app.identifier]])

                ret_json["items"] = new_items2
                gcs_file.write(json.dumps(ret_json["items"]), "text/plain", "public-read")

        elif step == "pp_pending_approval" or step == "pp_rejected_pending_resubmission":
            n = datetime.now()

            gcs_file = GCSLockedFile("/CustomerProgressCache/" + step + "_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json")
            result = gcs_file.read()
            if not result is None:
                ret_json["items"] = json.loads(result)
            else:

                packet_entry_identifier_idx_dict = {}
                field_app_identifier_idx_dict = {}
                field_app_ids_to_query = ["-1"]
                packet_entry_ids_to_query = ["-1"]
                packet_submission_ids_to_query = ["-1"]
                count = 0

                pp_entries = PerfectPacketEntry.query(
                    ndb.AND
                    (
                        PerfectPacketEntry.rep_completion_state == 1,
                        PerfectPacketEntry.archived == False
                    )
                ).order(PerfectPacketEntry.rep_completion_date)

                for item in pp_entries:
                    item_dict = {}
                    item_dict["identifier"] = item.identifier
                    item_dict["date"] = {}
                    item_dict["date"]["year"] = item.rep_completion_date.year
                    item_dict["date"]["month"] = item.rep_completion_date.month
                    item_dict["date"]["day"] = item.rep_completion_date.day
                    item_dict["name"] = None
                    item_dict["step_key"] = step
                    item_dict["booking_identifier"] = item.booking_identifier
                    item_dict["field_app_identifier"] = item.field_application_identifier

                    ret_json["items"].append(item_dict)

                    packet_entry_identifier_idx_dict[item.identifier] = count
                    #field_app_identifier_packet_entry_identifier_dict[item.field_application_identifier] = item.identifier

                    #field_app_ids_to_query.append(item.field_application_identifier)
                    packet_entry_ids_to_query.append(item.identifier)

                    count += 1


                pp_subs = PerfectPacketSubmission.query(
                    ndb.AND
                    (
                        PerfectPacketSubmission.archived == False,
                        PerfectPacketSubmission.packet_entry_identifier.IN(packet_entry_ids_to_query),
                        PerfectPacketSubmission.rejected == (step == "pp_rejected_pending_resubmission")
                    )
                )

                for pp_sub in pp_subs:
                    packet_submission_ids_to_query.append(pp_sub.identifier)
                    ret_json["items"][packet_entry_identifier_idx_dict[pp_sub.packet_entry_identifier]]["rejected"] = (pp_sub.rejected) and (not pp_sub.approved)
                    ret_json["items"][packet_entry_identifier_idx_dict[pp_sub.packet_entry_identifier]]["submission_identifier"] = pp_sub.identifier
                    ret_json["items"][packet_entry_identifier_idx_dict[pp_sub.packet_entry_identifier]]["extra_info"] = json.loads(pp_sub.extra_info)


                packet_entry_identifiers_to_exclude = []
                pp_approvals = PerfectPacketApproval.query(PerfectPacketApproval.packet_submission_identifier.IN(packet_submission_ids_to_query))
                for pp_approval in pp_approvals:
                    packet_entry_identifiers_to_exclude.append(pp_approval.packet_entry_identifier)

                for item in ret_json["items"]:
                    if not "rejected" in item.keys() and not item["identifier"] in packet_entry_identifiers_to_exclude:
                        packet_entry_identifiers_to_exclude.append(item["identifier"])

                count = 0
                new_items_list = []
                for item in ret_json["items"]:
                    if not item["identifier"] in packet_entry_identifiers_to_exclude:
                        new_items_list.append(item)
                        field_app_ids_to_query.append(item["field_app_identifier"])
                        field_app_identifier_idx_dict[item["field_app_identifier"]] = count
                        count += 1

                field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))

                field_app_id_items_to_delete = []
                for field_app in field_apps:
                    new_items_list[field_app_identifier_idx_dict[field_app.identifier]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                    if field_app.has_holds or field_app.save_me:
                        field_app_id_items_to_delete.append(field_app.identifier)

                ret_json["items"] = new_items_list
                items_to_retain = []

                for item in ret_json["items"]:
                    if not item["field_app_identifier"] in field_app_id_items_to_delete:
                        items_to_retain.append(item)

                ret_json["items"] = items_to_retain
                gcs_file.write(json.dumps(ret_json["items"]), "text/plain", "public-read")

        elif step == "perm_sub_pending":
            n = datetime.now()
            gcs_file = GCSLockedFile("/CustomerProgressCache/perm_sub_pending_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json")
            result = gcs_file.read()
            if not result is None:
                ret_json["items"] = json.loads(result)
            else:
                packet_approval_identifier_idx_dict = {}
                field_app_identifier_idx_dict = {}
                field_app_ids_to_query = ["-1"]
                packet_approval_ids_to_query = ["-1"]
                count = 0

                pp_approvals = PerfectPacketApproval.query(PerfectPacketApproval.progress_closed == False).order(PerfectPacketApproval.approval_date)

                for item in pp_approvals:
                    if item.archived:
                        continue

                    item_dict = {}
                    item_dict["identifier"] = item.identifier
                    item_dict["date"] = {}
                    item_dict["date"]["year"] = item.approval_date.year
                    item_dict["date"]["month"] = item.approval_date.month
                    item_dict["date"]["day"] = item.approval_date.day
                    item_dict["name"] = None
                    item_dict["step_key"] = step
                    item_dict["booking_identifier"] = item.booking_identifier
                    item_dict["field_app_identifier"] = item.field_application_identifier

                    ret_json["items"].append(item_dict)

                    packet_approval_identifier_idx_dict[item.identifier] = count
                    packet_approval_ids_to_query.append(item.identifier)

                    count += 1

                identifiers_to_exclude = []
                prog_items = CustomerProgressItem.query(CustomerProgressItem.entity_identifier.IN(packet_approval_ids_to_query))
                for prog_item in prog_items:
                    identifiers_to_exclude.append(prog_item.entity_identifier)

                cnt = 0
                for identifier_to_exclude in identifiers_to_exclude:
                    idx = packet_approval_identifier_idx_dict[identifier_to_exclude]
                    del ret_json["items"][idx - cnt]
                    cnt += 1

                cnt = 0
                for item in ret_json["items"]:
                    field_app_ids_to_query.append(item["field_app_identifier"])
                    field_app_identifier_idx_dict[item["field_app_identifier"]] = cnt
                    cnt += 1

                field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
                field_app_ids_to_delete = []

                for field_app in field_apps:
                    ret_json["items"][field_app_identifier_idx_dict[field_app.identifier]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                    if field_app.has_holds or field_app.save_me:
                        field_app_ids_to_delete.append(field_app.identifier)

                new_items = []
                for item in ret_json["items"]:
                    if not item["field_app_identifier"] in field_app_ids_to_delete:
                        new_items.append(item)

                ret_json["items"] = new_items
                gcs_file.write(json.dumps(ret_json["items"]), "text/plain", "public-read")

        else:
            util_providers = Helpers.list_utility_providers()
            util_value_value_friendly_dict = {}
            for provider in util_providers:
                util_value_value_friendly_dict[provider["value"]] = provider["value_friendly"]

            items = CustomerProgressItem.query(
                ndb.AND
                (
                    CustomerProgressItem.step_state == step,
                    CustomerProgressItem.closed == (step == "operation_perm")
                )
            ).order(CustomerProgressItem.updated)

            include_rej_count = (step == "perm_rejected_pending_resubmission")

            entity_identifier_idx_dict = {}
            entity_identifiers_to_query = ["-1"]
            field_app_ids_to_query = ["-1"]
            field_app_identifier_entity_identifier_dict = {}

            count = 0
            for item in items:
                if item.archived:
                    continue

                item_dict = {}
                item_dict["f_app_identifier"] = item.field_app_identifier
                item_dict["identifier"] = item.entity_identifier
                item_dict["date"] = {}
                item_dict["date"]["year"] = item.updated.year
                item_dict["date"]["month"] = item.updated.month
                item_dict["date"]["day"] = item.updated.day
                item_dict["name"] = None
                item_dict["step_key"] = step
                item_dict["utility_provider"] = "Missing"
                item_dict["extras"] = json.loads(item.extra_info)

                item_dict["booking_identifier"] = item.booking_identifier

                if include_rej_count:
                    item_dict["rejection_count"] = 0
                    dct = json.loads(item.extra_info)
                    if "rejection_dates" in dct.keys():
                        item_dict["rejection_count"] += len(dct["rejection_dates"])

                ret_json["items"].append(item_dict)

                field_app_identifier_entity_identifier_dict[item.field_app_identifier] = item.entity_identifier
                field_app_ids_to_query.append(item.field_app_identifier)
                entity_identifier_idx_dict[item.entity_identifier] = count
                entity_identifiers_to_query.append(item.entity_identifier)

                count += 1

            field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
            field_app_ids_to_delete = []

            for field_app in field_apps:
                ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["name"] = field_app.customer_first_name + " " + field_app.customer_last_name
                ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["field_app_identifier"] = field_app.identifier

                if field_app.utility_provider in util_value_value_friendly_dict.keys():
                    ret_json["items"][entity_identifier_idx_dict[field_app_identifier_entity_identifier_dict[field_app.identifier]]]["utility_provider"] = util_value_value_friendly_dict[field_app.utility_provider]

                if field_app.has_holds or field_app.save_me:
                    field_app_ids_to_delete.append(field_app.identifier)


            final_items = []
            for item in ret_json["items"]:
                if not item["f_app_identifier"] in field_app_ids_to_delete:
                    final_items.append(item)

            ret_json["items"] = final_items

            #some extra tweaks.....

        logging.info(go_by_original_submission_date)
        if go_by_original_submission_date:
            entity_identifiers_to_query = ["-1"]
            for item in ret_json["items"]:
                entity_identifiers_to_query.append(item["identifier"])

            logging.info(entity_identifiers_to_query)
            archives = CustomerProgressArchive.query(
                ndb.AND
                (
                    CustomerProgressArchive.step_state == "pending_perm_approved",
                    CustomerProgressArchive.entity_identifier.IN(entity_identifiers_to_query)
                )
            ).order(CustomerProgressArchive.updated)

            updated_lst = []

            for archive in archives:
                entity_identifier = archive.entity_identifier
                if not entity_identifier in updated_lst:
                    idx = entity_identifier_idx_dict[entity_identifier]
                    if idx <= (len(ret_json["items"]) - 1):
                        ret_json["items"][idx]["date"]["year"] = archive.updated.year
                        ret_json["items"][idx]["date"]["month"] = archive.updated.month
                        ret_json["items"][idx]["date"]["day"] = archive.updated.day
                        updated_lst.append(entity_identifier)

            for item in ret_json["items"]:
                item["dt"] = datetime(item["date"]["year"], item["date"]["month"], item["date"]["day"], 1, 30)

            Helpers.bubble_sort(ret_json["items"], "dt")

            for item in ret_json["items"]:
                del item["dt"]

        idxs_to_delete = []
        cnt = 0
        for item in ret_json["items"]:
            if item == "mosaic":
                idxs_to_delete.append(cnt)
            elif item["name"] is None:
                idxs_to_delete.append(cnt)
            cnt += 1

        del_cnt = 0
        for idx in idxs_to_delete:
            del ret_json["items"][idx - del_cnt]
            del_cnt += 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_utility_providers":
        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(Helpers.list_utility_providers()))

    elif self.request.get("fn") == "record_customer_progress":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        step_key = self.request.get("step")
        date_items = self.request.get("date").split("-")
        d = date(int(date_items[2]), int(date_items[0]), int(date_items[1]))
        mt = None
        mt2 = None
        override_mts = []
        rep_identifier = ""
        rep_office_identifier = ""

        updated = False
        pg_items = CustomerProgressItem.query(CustomerProgressItem.entity_identifier == self.request.get("entity_identifier"))
        for pg_item in pg_items:
            pg_item.updated = d
            pg_item.step_state = step_key
            pg_item.closed = (step_key == "operation_perm")

            if step_key == "perm_rejected_pending_resubmission":
                extra_info_dict = json.loads(pg_item.extra_info)
                if not "rejection_dates" in extra_info_dict.keys():
                    extra_info_dict["rejection_dates"] = []
                extra_info_dict["rejection_dates"].append(str(datetime(d.year, d.month, d.day, 0, 1, 30)))
                pg_item.extra_info = json.dumps(extra_info_dict)
                ret_json["success"] = True

            if str(self.request.get("rec_panel_work_suggestion")) == "1":
                extra_info_dict = json.loads(pg_item.extra_info)
                extra_info_dict["panel_work_suggestion"] = self.request.get("panel_work_suggestion")
                pg_item.extra_info = json.dumps(extra_info_dict)
                ret_json["success"] = True

            if step_key == "construction_completed":

                pp_approvals = PerfectPacketApproval.query(PerfectPacketApproval.field_application_identifier == pg_item.field_app_identifier)

                for pp_approval in pp_approvals:

                    pp_submissions = PerfectPacketSubmission.query(PerfectPacketSubmission.identifier == pp_approval.packet_submission_identifier)

                    pp_sub = None
                    for pp_submission in pp_submissions:
                        pp_sub = pp_submission

                bookings = SurveyBooking.query(SurveyBooking.identifier == pg_item.booking_identifier)

                for booking in bookings:
                    booking_dt = datetime(booking.booking_year, booking.booking_month, booking.booking_day)
                    cust_name = booking.name
                    booking_fund = booking.fund
                    bookingg = booking
                    rep_office_identifier = booking.office_identifier


                    if (not pp_sub is None) and (not booking_dt is None) and (not booking_fund == "") and (not booking_fund == "n/a"):

                        payscale_key = None


                        rep_nayme = "{ Rep Name }"
                        rep_automatic_override_amount = 0.0
                        generate_automatic_override = False
                        rep_override_designee = None
                        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id == booking.associated_rep_id)
                        for rep in reps:
                            payscale_key = rep.payscale_key
                            rep_nayme = rep.first_name + " " + rep.last_name
                            rep_autmoatic_override_amount = rep.automatic_override_amount
                            generate_automatic_override = rep.automatic_override_enabled
                            rep_override_designee = rep.automatic_override_designee
                            rep_identifier = rep.identifier

                        if not payscale_key is None:
                            #get the friendly name of the fund

                            friendly_fund_name = ""
                            funds = Helpers.list_funds()
                            for fund in funds:
                                if fund["value"] == booking_fund:
                                    friendly_fund_name = fund["value_friendly"]

                            #get the funding_group_info
                            fund_group_info = {}
                            fund_group_info["value"] = "unassigned"
                            fund_group_info["value_friendly"] = "Unassigned"

                            funding_groups = Helpers.list_funding_groups()
                            g_name_keys = funding_groups["group_items"].keys()

                            for g_name_key in g_name_keys:
                                items = funding_groups["group_items"][g_name_key]

                                for item in items:
                                    if item == booking_fund:

                                        fund_group_info["value"] = g_name_key
                                        for name in funding_groups["group_names"]:
                                            if name["value"] == g_name_key:

                                                fund_group_info["value_friendly"] = name["value_friendly"]


                            if not fund_group_info["value"] == "unassigned":
                                payscales = Helpers.list_payscales()
                                friendly_name_of_payscale = None
                                commission_kwh_price = None
                                commission_tier_option = None

                                field_apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier == pg_item.field_app_identifier)
                                for field_app in field_apps:
                                    commission_kwh_price = field_app.customer_kwh_price
                                    commission_tier_option = field_app.tier_option
                                    if commission_tier_option == "n/a":
                                        commission_tier_option = "A"

                                payscale_idx = -1
                                cnt = 0
                                for payscale in payscales:
                                    if payscale["value"] == payscale_key:
                                        friendly_name_of_payscale = payscale["value_friendly"]
                                        payscale_idx = cnt

                                    cnt += 1

                                if (not friendly_name_of_payscale is None) and (not commission_kwh_price is None) and (not payscale_idx == -1):
                                    price_per_kwh_at_sys_size = None
                                    price_per_kwh_at_sys_size_str = None

                                    for scale in payscales[payscale_idx]["scales"]:
                                        if scale["tier"] == commission_tier_option:
                                            if scale["funding_group"] == fund_group_info["value"]:
                                                price_per_kwh_at_sys_size = float(scale["price"])
                                                price_per_kwh_at_sys_size_str = str(scale["price"])

                                                try:
                                                    idx = price_per_kwh_at_sys_size_str.index(".")

                                                    if idx == len(price_per_kwh_at_sys_size_str) - 2:
                                                        price_per_kwh_at_sys_size_str += "0"

                                                except:
                                                    price_per_kwh_at_sys_size_str += ".00"

                                    if (not price_per_kwh_at_sys_size is None) and (not price_per_kwh_at_sys_size_str is None):
                                        s_s = float(pp_approval.system_size)
                                        multiplier = float(price_per_kwh_at_sys_size)
                                        total = s_s * multiplier

                                        e_info = json.loads(pp_sub.extra_info)
                                        e_description = ""
                                        closer_mt = None
                                        closer_obj = None
                                        if "closer" in e_info.keys():
                                            closer = FieldApplicationUser.first(FieldApplicationUser.identifier == e_info["closer"])
                                            closer_obj = closer
                                            if not closer is None:
                                                total -= float(float(s_s) * float(100))
                                                e_description = " There was also an offset of $100/kw because " + closer.first_name.strip() + " " + closer.last_name.strip() + " was annotated as the deal's closer."

                                                closers_total = s_s * float(100)
                                                closers_total *= 0.5
                                                closers_total_in_cents = int(closers_total * 100)
                                                closers_dollar_total = closers_total_in_cents / 100
                                                closers_cents_total = closers_total_in_cents % 100

                                                closer_mt = MonetaryTransaction(
                                                    identifier=Helpers.guid(),
                                                    recorded_by=self.session["user_identifier"],
                                                    description="Second closing bonus for " + cust_name + ". (You helped " + rep_nayme + " sell a " + str(s_s) + "KW system).",
                                                    description_key="closers_bonus_B",
                                                    recorded_dt=Helpers.pacific_now(),
                                                    paid=False,
                                                    recipient=closer.identifier,
                                                    dollars=closers_dollar_total,
                                                    cents=closers_cents_total,
                                                    tax_applicable=True,
                                                    approved=True,
                                                    denied=False,
                                                    extra_info="{}"
                                                )

                                                closer_mt.check_number = Helpers.get_check_number_for_transaction(closer_obj.identifier, 1)
                                                Helpers.set_commission_payout(closer_mt)
                                                Helpers.send_sms(closer_obj.rep_phone, "Cha-Ching! A bonus of $" + str(closer_mt.dollars) + "." + str(closer_mt.cents) + " for closing a deal has been posted for next week's paycheck.")

                                        semi_final_total = total * 0.50
                                        total_in_cents = int(semi_final_total * 100)
                                        dollars_total = total_in_cents / 100
                                        cents_total = total_in_cents % 100

                                        descrip = "Part 2 Commission @ 50% for " + cust_name
                                        descrip += ".\n\n"
                                        descrip += "System size was "
                                        descrip += str(s_s)
                                        descrip += ", total commission in Tier "
                                        descrip += commission_tier_option
                                        descrip += "kwh was configured at $"
                                        descrip += price_per_kwh_at_sys_size_str
                                        descrip += ". This configuration was based off of your membership in the payscale group called '"
                                        descrip += friendly_name_of_payscale
                                        descrip += "', and the customer's credit/funding source being marked as '"
                                        descrip += friendly_fund_name
                                        descrip += "'."
                                        descrip += e_description



                                        mt = MonetaryTransaction(
                                            identifier=Helpers.guid(),
                                            recorded_by=self.session["user_identifier"],
                                            description=descrip,
                                            description_key="rep_sales_commission_1B",
                                            recorded_dt=Helpers.pacific_now(),
                                            paid=False,
                                            recipient=pp_approval.rep_identifier,
                                            dollars=dollars_total,
                                            cents=cents_total,
                                            tax_applicable=True,
                                            approved=True,
                                            denied=False,
                                            extra_info="{}"
                                        )
                                        mt.check_number = Helpers.get_check_number_for_transaction(pp_approval.rep_identifier, 1)
                                        Helpers.set_commission_payout(mt)

                                        if generate_automatic_override:
                                            override_recipient = None
                                            if not (rep_override_designee is None) and (not rep_override_designee == "AZ0230"):

                                                designee = FieldApplicationUser.first(
                                                    ndb.AND
                                                    (
                                                        FieldApplicationUser.current_status == 0,
                                                        FieldApplicationUser.rep_id == rep_override_designee
                                                    )

                                                )
                                                if not designee is None:
                                                    override_recipient = designee.identifier

                                                if not override_recipient is None:

                                                    str_amount = str(rep_autmoatic_override_amount)
                                                    if not "." in str_amount:
                                                        str_amount = str_amount + ".00"

                                                    dollas = int(str_amount.split(".")[0])
                                                    sents = int(str_amount.split(".")[1])



                                                    mt2 = MonetaryTransaction(
                                                        identifier=Helpers.guid(),
                                                        recorded_by=self.session["user_identifier"],
                                                        description="Recruitment Override Bonus for " + cust_name + " (customer of " + rep_nayme + ").",
                                                        description_key="automatic_override",
                                                        recorded_dt=Helpers.pacific_now(),
                                                        paid=False,
                                                        recipient=override_recipient,
                                                        dollars=dollas,
                                                        cents=sents,
                                                        tax_applicable=True,
                                                        approved=True,
                                                        denied=False,
                                                        extra_info="{}"
                                                    )
                                                    mt2.check_number = Helpers.get_check_number_for_transaction(override_recipient, 1)
                                                    Helpers.set_commission_payout(mt2)
                                                    usrr2 = FieldApplicationUser.first(FieldApplicationUser.identifier == override_recipient)
                                                    if not usrr2 is None:
                                                        Helpers.send_sms(usrr2.rep_phone, "Cha-Ching! A recruitment override bonus of $" + str(mt2.dollars) + "." + str(mt2.cents) + " has been posted for next week's paycheck.")

                                        transaction_data = json.loads(self.request.get("transaction_data"))
                                        for transaction_item in transaction_data:

                                            override_dollars = int(transaction_item["amount"].split(".")[0])
                                            override_cents = int(transaction_item["amount"].split(".")[1])

                                            override_descrip = "Override from " + cust_name + "(" + rep_nayme + "'s customer) reaching Construction Complete."
                                            override_mt = MonetaryTransaction(
                                                identifier=Helpers.guid(),
                                                recorded_by=self.session["user_identifier"],
                                                description=override_descrip,
                                                description_key="construction_complete_mgr_override",
                                                recorded_dt=Helpers.pacific_now(),
                                                paid=False,
                                                recipient=transaction_item["identifier"],
                                                dollars=override_dollars,
                                                cents=override_cents,
                                                tax_applicable=True,
                                                approved=True,
                                                denied=False,
                                                extra_info="{}"
                                            )

                                            override_mt.check_number = Helpers.get_check_number_for_transaction(transaction_item["identifier"], 1)
                                            Helpers.set_commission_payout(override_mt)
                                            usrr3 = FieldApplicationUser.first(FieldApplicationUser.identifier == transaction_item["identifier"])
                                            if not usrr3 is None:
                                                Helpers.send_sms(usrr3.rep_phone, "Cha-Ching! An override bonus of $" + str(override_mt.dollars) + "." + str(override_mt.cents) + " has been posted for next week's paycheck.")



                                        ret_json["success"] = True


                    if not ret_json["success"]:
                        ret_json["reason"] = None
                        if not (pp_sub is None) and (not bookingg is None):
                            r_id = bookingg.associated_rep_id
                            usrs = FieldApplicationUser.query(FieldApplicationUser.rep_id == r_id)
                            for usr in usrs:
                                p_key = usr.payscale_key
                                if p_key.lower() == "n/a":
                                    ret_json["reason"] = "missing_payscale"

                            if ret_json["reason"] is None:
                                if bookingg.fund.lower() == "n/a":
                                    ret_json["reason"] = "missing_fund"

            else:
                ret_json["success"] = True

            updated = True

            if ret_json["success"]:

                pg_item.put()

                progress_archive = CustomerProgressArchive(
                    identifier=pg_item.identifier,
                    entity_identifier=pg_item.entity_identifier,
                    field_app_identifier=pg_item.field_app_identifier,
                    booking_identifier=pg_item.booking_identifier,
                    step_state=step_key,
                    updated=d,
                    extra_info=pg_item.extra_info
                )
                progress_archive.put()

                if pg_item.closed:
                    pp_approvals = PerfectPacketApproval.query(PerfectPacketApproval.booking_identifier == pg_item.booking_identifier)
                    for pp_approval in pp_approvals:
                        pp_approval.progress_closed = True
                        pp_approval.put()

                if not mt is None:
                    mt.put()

                if not mt2 is None:
                    mt2.put()

                if len(override_mts) > 0:
                    kv_eyetem_a = KeyValueStoreItem.first(KeyValueStoreItem.keyy == rep_identifier + "_" + rep_office_identifier + "_payout_json")
                    if not kv_eyetem_a is None:
                        kv_eyetem_a.val = self.request.get("transaction_data")
                        kv_eyetem_a.expiration = Helpers.pacific_now() + timedelta(days=365)
                        kv_eyetem_a.put()
                    else:
                        kv_eyetem_b = KeyValueStoreItem(
                            identifier=Helpers.guid(),
                            keyy=rep_identifier + "_" + rep_office_identifier + "_payout_json",
                            val=self.request.get("transaction_data"),
                            expiration=Helpers.pacific_now() + timedelta(days=365)
                        )
                        kv_eyetem_b.put()

                    if len(override_mts) == 1:
                        override_mts[0].put()
                    else:
                        ndb.put_multi(override_mts)

        progress_id = Helpers.guid()
        if not updated:
            progress_item = CustomerProgressItem(
                identifier=progress_id,
                entity_identifier=self.request.get("entity_identifier"),
                field_app_identifier=self.request.get("field_app_identifier"),
                booking_identifier=self.request.get("booking_identifier"),
                step_state=step_key,
                updated=d,
                extra_info="{}",
                closed=False,
                archived=False,
                save_me=False
            )

            progress_item.put()

            progress_archive = CustomerProgressArchive(
                identifier=progress_id,
                entity_identifier=self.request.get("entity_identifier"),
                field_app_identifier=self.request.get("field_app_identifier"),
                booking_identifier=self.request.get("booking_identifier"),
                step_state=step_key,
                updated=d,
                extra_info="{}"
            )

            progress_archive.put()
            ret_json["success"] = True

            n = datetime.now()
            n_minus_1 = n + timedelta(hours=-1)

            gcs_filez = [
                GCSLockedFile("/CustomerProgressCache/perm_sub_pending_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + "_" + str(n.hour) + ".json"),
                GCSLockedFile("/CustomerProgressCache/perm_sub_pending_" + str(n_minus_1.year) + "_" + str(n_minus_1.month) + "_" + str(n_minus_1.day) + "_" + str(n_minus_1.hour) + ".json")
            ]

            for gcs_file in gcs_filez:
                data = gcs_file.read(True)
                if not data is None:
                    entries = json.loads(data)
                    idx_to_remove = -1
                    cnt = -1
                    for entry in entries:
                        cnt += 1
                        if entry["field_app_identifier"] == progress_item.field_app_identifier:
                            idx_to_remove = cnt
                            break

                    if not idx_to_remove == -1:
                        del entries[idx_to_remove]
                        gcs_file.unlock()
                        gcs_file.write(json.dumps(entries), "text/plain", "public-read")
                else:
                    gcs_file.unlock()


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "unique_zips":
        apps = FieldApplicationEntry.query(FieldApplicationEntry.utility_provider == "n/a")
        postals = []
        for app in apps:
            if not app.customer_postal in postals:
                postals.append(app.customer_postal)

        postals.sort()
        self.response.content_type = "text/plain"
        for postal in postals:
            self.response.out.write(postal + "\n")

    elif self.request.get("fn") == "update_missing_zips":
        bucket_name = os.environ.get('BUCKET_NAME',
                        app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name

        app_id = app_identity.get_application_id()

        filename = bucket + '/postals.json'
        credsRetryParams = gcs.RetryParams(initial_delay=0.2,
                            max_delay=5.0,
                            backoff_factor=2,
                            max_retry_period=15,
                            urlfetch_timeout=30)
        gcs_file = gcs.open(filename, 'r', retry_params=credsRetryParams)
        json_txt = gcs_file.read()
        gcs_file.close()

        unique_postals_list = json.loads(json_txt)
        shorthand_longhand_set = {"SCE": "southern_california_edison", "SDGE": "san_diego_gas_&_electric", "PGE": "pacific_gas_&_electric_company"}
        postal_code_shorthand_dict = {}
        for item in unique_postals_list:
            postal_code_shorthand_dict[item["FIELD1"]] = item["FIELD2"]

        logging.info(unique_postals_list)
        logging.info(postal_code_shorthand_dict)

        apps = FieldApplicationEntry.query(FieldApplicationEntry.utility_provider == "n/a")
        bookings = SurveyBooking.query(SurveyBooking.utility_provider == "n/a")

        apps_to_put = []
        bookings_to_put = []

        for app in apps:
            if app.customer_postal in postal_code_shorthand_dict.keys():
                app.utility_provider = shorthand_longhand_set[postal_code_shorthand_dict[app.customer_postal]]
                apps_to_put.append(app)
            else:
                logging.info(app.customer_postal + " not in postal_code_shorthand_dict.keys")

        for booking in bookings:
            if booking.postal in postal_code_shorthand_dict.keys():
                booking.utility_provider = shorthand_longhand_set[postal_code_shorthand_dict[booking.postal]]
                bookings_to_put.append(booking)

        if len(apps_to_put) == 1:
            apps_to_put[0].put()

        if len(bookings_to_put) == 1:
            bookings_to_put[0].put()

        if len(apps_to_put) > 1:
            ndb.put_multi(apps_to_put)

        if len(bookings_to_put) > 1:
            ndb.put_multi(bookings_to_put)

        self.response.out.write("kk done")

    elif self.request.get("fn") == "get_comp_package":
        self.response.content_type = "application/json"

        server_name = self.request.environ["SERVER_NAME"]
        user_primary_state = self.request.get("user_primary_state").upper()
        user_type = self.request.get("user_type").upper()

        path = Helpers.get_compensation_image(server_name,user_type,user_primary_state)

        comp_path = "./bootstrap/js/ViewerJS/index.html#"+path

        ret_json = {}
        ret_json["comp_path"] = comp_path

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "rep_recruiter_search":
        self.response.content_type = "application/json"
        ret_json = {}
        rep_phone = self.request.get("rep_phone")

        rep_ids = Helpers.get_rep_id_by_phone(rep_phone)
        ret_json["result"] = len(rep_ids ) > 0
        ret_json["reps"] = []
        for rep_id in rep_ids:
            ret_json["reps"].append({"rep_id": rep_id})

        if ret_json["result"]:
            rep_id_idx_dict = {}

            count = 0
            for item in rep_ids:
                rep_id_idx_dict[item] = count
                count += 1

            users = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids))
            for user in users:
                ret_json["reps"][rep_id_idx_dict[user.rep_id]]["name"] = user.first_name + " " + user.last_name


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "test_sales_rabbit_credentials":
        self.response.content_type = "application/json"

        username = self.request.get("email")
        password = self.request.get("password")

        site_url = "https://dashboard.salesrabbit.com/"

        ret_json = {}
        ret_json["success"] = False

        resp = urlfetch.fetch(url=site_url,
            deadline=30,
            method=urlfetch.GET,
            follow_redirects=False)

        php_session_id = None
        sign_in_url = None
        if resp.status_code > 300 and resp.status_code < 305:
            try:
                session_val = resp.header_msg.getheaders("Set-Cookie")[len(resp.header_msg.getheaders("Set-Cookie")) - 1]
                if not session_val == "":
                        if session_val.index("PHPSESSID") >= 0:
                            php_session_id = session_val[0:session_val.index(";")]
                            php_session_id = php_session_id.replace("PHPSESSID=", "")

                if not php_session_id is None:
                    sign_in_url_val = resp.header_msg.getheader("Location")

                    if not sign_in_url_val is None:
                        sign_in_url = sign_in_url_val

            except:
                logging.info("No PHP Session ID Set")
                php_session_id = None
                sign_in_url = None

        if (not php_session_id is None) and (not sign_in_url is None):
            resp2 = urlfetch.fetch(url=sign_in_url,
                deadline=30,
                headers=
                {
                    "Cookie": "PHPSESSID=" + php_session_id,
                    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/34.0.1847.116 Chrome/34.0.1847.116 Safari/537.36",
                },
                method=urlfetch.GET,
                follow_redirects=False
            )
            signon_page_dom = BeautifulSoup(resp2.content)
            signon_input_els = signon_page_dom.find_all("input")
            auth_state = None
            for signon_input_el in signon_input_els:
                try:
                    nayme = str(signon_input_el["name"])
                    if nayme == "AuthState":
                        try:
                            auth_state = signon_input_el["value"]
                        except:
                            auth_state = auth_state
                except:
                    logging.info("AuthState not Found")
                    auth_state = auth_state

            signon_fields = {
                "action" : "login",
                "username": username,
                "password": password,
                "regularsubmit": "Login",
                "AuthState" : auth_state
            }
            signon_form_data = urllib.urlencode(signon_fields)
            resp3 = urlfetch.fetch(url=sign_in_url,
                payload=signon_form_data,
                deadline=30,
                headers=
                {
                    "Cookie": "PHPSESSID=" + php_session_id,
                    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/34.0.1847.116 Chrome/34.0.1847.116 Safari/537.36",
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                method=urlfetch.POST,
                follow_redirects=False
            )
            if resp3.header_msg.getheader("Location") == "https://dashboard.salesrabbit.com/":
                ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "store_sales_rabbit_credentials":
        username = self.request.get("email")
        password = self.request.get("password")
        data_to_store = {};
        data_to_store["username"] = username
        data_to_store["password"] = password
        json_to_store = json.dumps(data_to_store)
        encrypted_json = Helpers.encrypt(json_to_store)

        bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())

        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/sales_rabbit_info_' + app_identity.get_application_id() + '.txt'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(
                        filename,
                        'w',
                        content_type="text/plain",
                        options={'x-goog-meta-foo': 'foo',
                                 'x-goog-meta-bar': 'bar',
                                 'x-goog-acl': 'public-read'},
                        retry_params=write_retry_params)
        gcs_file.write(encrypted_json)
        gcs_file.close()
        self.response.out.write("")

    elif self.request.get("fn") == "kwikie54":
        bb = SurveyBooking(
            address="38622 13th st E",
            archived=False,
            associated_rep_id="ROME0330",
            booking_day=28,
            booking_month=1,
            booking_year=2016,
            city="Palmdale",
            completion_state=2,
            email="customer85739test@ymail.com",
            field_app_identifier="20934a7cf6901eab72550fa380ebfcf22696ec88856a66e58571936b9bb17dc4bb6bb2052c539dae3874eae50570f205465e87f9ab93553bc2ce4f3b067541cb",
            field_app_lead_id="E1MXNEzyvsP7",
            fund="n/a",
            has_associated_field_entry=True,
            identifier="c0dba7d0172f625e00b3807529da9ea540c206f1965a8eeb5a95ae1bd7f53616b6288172cbcc8dddca2ce7219d342caa0ce7cec2b25d9452a29a6b10b2ea1361",
            name="Juan Flores",
            notes=".",
            office_identifier="c0dfef0dd54cb36249d651a0112f5a25191e5f896d8858a8ad16d8a619fd91650ed41a5822fb15250c03942d22d89aabd28b5d6da3a57f4b965a61ac3ea9895a",
            phone_number="6619476973",
            postal="93550",
            slot_number=1,
            state="CA",
            trust_docs="n/a",
            utility_no="2270048150",
            utility_provider="southern_california_edison",
            save_me=False
        )
        bb.put()

    elif self.request.get("fn") == "kwikie55":
        app = FieldApplicationEntry(
            identifier="4781cd845f8a9fbd12dc3204e0379d7e1677e58f8e34e5664197cc1f21c62fbfc42b683bcce6f21a76da1c5495edf90418673aec0ee595f4c08aacac1c94e64e",
            booking_identifier="4ef064b2fbf34b00eb6c6c48f188f11a00626e376a53ca66fd035aad913e0bc8e76dd9f876f85eaa5f2ae111505a3ca6787a527106f3e91d59b70be374d11afe",
            customer_address="2085 E Oakridge Circle",
            customer_city="Layton",
            customer_county="n/a",
            customer_cpf_id=-1,
            customer_dob = datetime(1970, 1, 1),
            customer_email="kstobias@yahoo.com",
            customer_first_name="Kevin",
            customer_last_name="Tobias",
            customer_kwh_price="-1.0",
            customer_mosaic_id=-1,
            customer_phone="8015462988",
            customer_postal="84040",
            customer_signature_date=datetime(2016, 1, 15),
            customer_state="UT",
            customer_utility_account_number="0000000",
            image_extension="png",
            insert_time=1452916228008,
            office_identifier="062828d9f89abe6439f2606375e51c6b131f98e2f99d8e3b0b9a7c93860784dab7cc760f26974ee02375e94f5783d456362989f56ea28f436bc20b6f6f844ea2",
            processed=0,
            rep_email="justincov1@gmail.com",
            rep_id="COVI0311",
            rep_phone="8018217799",
            sp_two_time=datetime(2016, 2, 1, 17, 0, 0),
            utility_provider="rocky_mountain_power",
            rep_lead_id="86p1rd1L0tnV",
            opt_rep_notes=" ",
			archived=False,
			archive_reason="n/a",
            has_holds=False,
            hold_items="[]",
            save_me=False,
            save_me_reason="n/a",
            save_me_dt=datetime(1970, 1, 1),
            spouse_name="n/a",
            hide_from_recent_view=False,
            usage_info_available=False,
            usage_months=0,
            total_kwhs=float(0),
            total_dollars=float(0),
            highest_amount=float(0),
            proposal_state=0,
            tier_option="A",
            deal_closed=False,
            new_survey_state=0,
            usage_data="{}",
            deal_locked=False
        )
        app.put()

        if self.configuration["customer_progress_v2"]:
            CustomerProgressManager.progress("account_creation", "account_created", Helpers.pacific_today(), app, app.booking_identifier)

    elif self.request.get("fn") == "lzw_test":
        import lzw
        import base91
        bucket_name = os.environ.get('BUCKET_NAME',
            app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name

        w9_image_file = bucket + '/Images/' + "W-9.jpg"
        credsRetryParams = gcs.RetryParams(initial_delay=0.2,
            max_delay=5.0,
            backoff_factor=2,
            max_retry_period=15,
            urlfetch_timeout=30
        )

        f = gcs.open(w9_image_file, 'r', retry_params=credsRetryParams)
        compressed1 = "".join(lzw.compress(f.read()))
        bayse64 = base64.b64encode(compressed1)
        f.close()

        f = gcs.open(w9_image_file, 'r', retry_params=credsRetryParams)
        compressed2 = "".join(lzw.compress(f.read()))
        b91 = base91.encode(compressed2)
        f.close()

        self.response.out.write(str(len(compressed1)) + " vs " + str(len(compressed2)))
        self.response.out.write("<br><br>")
        self.response.out.write(str(len(bayse64)) + " vs " + str(len(b91)))

    elif self.request.get("fn") == "fix_pp_entries":
        pp_entries = PerfectPacketEntry.query(PerfectPacketEntry.rep_completion_date < Helpers.pacific_now() + timedelta(days=-365 * 7))
        entries_to_put = []
        for pp_entry in pp_entries:
            pp_entry.rep_completion_date = datetime(2015, 9, 1, 6, 30, 15)
            entries_to_put.append(pp_entry)

        ndb.put_multi(entries_to_put)

    elif self.request.get("fn") == "kwikie669":
        #change surveyor back
        pp_entry = PerfectPacketEntry(
            identifier=Helpers.guid(),
            booking_identifier="0ee01d2ad9e850e20206aa5286ffde0709dc497e7c01b3f96f22cb4dd39adee8d907c204b18adedc5dd4d550fbb70dece82d0f3bcdd3884733df718e23ac2d72",
            field_application_identifier="f94448db6b9d0226828b4e1860364aa64212cf5a8786b004837228b23911a0ed95fda095463e3f53ec050bb977c83b34611334931d96e7d8f3a95b8ff5eb95e4",
            surveyor_identifier="818d28feb58223c7ebc1aabb52f7692dee22bbf74c2e55e077d64baf96c4eba377e26582424a8429de315334649b6187bf35bb9767db3c4d5249030ef070fa5b",
            surveyor_completion_state=1,
            surveyor_completion_date=Helpers.pacific_now() + timedelta(days=-50),
            rep_identifier="fa2e6e84e34f63e5d89f09fdc3627b71a91c2c8d99989773d01de996f0f7ac514308f41c0d7b954473c690d5414c39ba8b8eb381f2d7a9d71a87683b1d652454	",
            rep_completion_state=0,
            rep_completion_date=datetime(1970, 1, 1),
            outstanding_items="[]",
            created=Helpers.pacific_now() + timedelta(days=-50),
            archived=False,
            save_me=False
        )
        pp_entry.put()

        pp_entry2 = PerfectPacketEntry(
            identifier=Helpers.guid(),
            booking_identifier="4395d8a641c879c52723f8a7745f78b77feddac4cb0a57f17b972dcf69cbecbf2738d708104c1275fb81216eb46bf82753d117c4e7d66db3c172927efb7b4d62",
            field_application_identifier="37d5c3d89e837914a7a2dafba662cbb5e8b82bd43b50126b6768ba97c2c7db0bc1e886020f66eb0f7e95b22debd40d133fe6e5552b5385d1f8f3edda6fe5e7f2",
            surveyor_identifier="818d28feb58223c7ebc1aabb52f7692dee22bbf74c2e55e077d64baf96c4eba377e26582424a8429de315334649b6187bf35bb9767db3c4d5249030ef070fa5b",
            surveyor_completion_state=1,
            surveyor_completion_date=Helpers.pacific_now() + timedelta(days=-4),
            rep_identifier="a88160c8fb850f0ef85d83575c1a8282184094cf1a295b9e73ebf01735fc3d3dd8db8a739f30184cf3a1284ebdcb404e4dd7b683e9e186017ac048457b97c26f",
            rep_completion_state=0,
            rep_completion_date=datetime(1970, 1, 1),
            outstanding_items="[]",
            created=Helpers.pacific_now() + timedelta(days=-4),
            archived=False,
            save_me=False
        )
        #pp_entry2.put()

    elif self.request.get("fn") == "kwikie660":
        deleted_booking = DeletedSurveyBooking.first(
            DeletedSurveyBooking.year == 2015,
        )
        for booking in deleted_booking.bookings:
            if booking.identifier == "0dd021f6826874c2bac71382cac59e3bd6ac586965381d3769527cdd5d1736c0586985cfd443da3803de51982b6eb16e8988b6a9c5950bb97b6643c0fcfe7069":
                booking2 = SurveyBooking(
                    address=booking.address,
                    archived=booking.archived,
                    associated_rep_id=booking.associated_rep_id,
                    booking_day=booking.booking_day,
                    booking_month=booking.booking_month,
                    booking_year=booking.booking_year,
                    city=booking.city,
                    completion_state=0,
                    email=booking.email,
                    field_app_identifier=booking.field_app_identifier,
                    field_app_lead_id=booking.field_app_lead_id,
                    fund=booking.fund,
                    has_associated_field_entry=True,
                    identifier=booking.identifier,
                    name=booking.name,
                    notes=booking.notes,
                    office_identifier=booking.office_identifier,
                    phone_number=booking.phone_number,
                    postal=booking.postal,
                    save_me=False,
                    slot_number=booking.slot_number,
                    state=booking.state,
                    trust_docs=booking.trust_docs,
                    utility_no=booking.utility_no,
                    utility_provider=booking.utility_provider
                )
                booking2.put()

    elif self.request.get("fn") == "request_to_do_follow_up":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == to_do.assigner)
            usr2 = FieldApplicationUser.first(FieldApplicationUser.identifier == to_do.owner)
            if (not usr is None) and (not usr2 is None):
                due_dt_vals = str(to_do.due_dt.date()).split("-")
                subj = usr.first_name.strip().title() + " " + usr.last_name.strip().title() + " is asking for an update"
                msg = usr.first_name.strip().title() + " " + usr.last_name.strip().title() + " is requesting an update from you on the to-do item: \"" + to_do.name + "\"" + "\r\n\r\n" + to_do.notes + "\r\n\r\n" + "Due: " + due_dt_vals[1] + "/" + due_dt_vals[2] + "/" + due_dt_vals[0]
                Helpers.send_email(usr2.rep_email, subj, msg)

    elif self.request.get("fn") == "to_do_customer_name_search":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []
        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))

        app_ids_to_query = ["-1"]
        for result in results:
            for field in result.fields:
                if field.name == "cust_identifier":
                    app_ids_to_query.append(field.value)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            if (not app_entry.archived) and (not app_entry.save_me):
                ret_json["customers"].append({"name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), "identifier": app_entry.identifier, "location": app_entry.customer_city + ", " + app_entry.customer_state})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "search_customers_by_name":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))

        field_app_identifier_idx_dict = {}
        field_app_ids_to_query = ["-1"]

        for result in results:
            result_item = {}
            for field in result.fields:
                if field.name == "cust_identifier":
                    result_item["identifier"] = field.value
                elif field.name == "cust_name":
                    result_item["name"] = field.value

            keys = result_item.keys()
            if "identifier" in keys and "name" in keys:
                ret_json["results"].append(result_item)
                field_app_identifier_idx_dict[result_item["identifier"]] = len(ret_json["results"]) - 1
                field_app_ids_to_query.append(result_item["identifier"])

        rep_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
        rep_id_results_idxes = {}
        for app_entry in app_entries:
            rep_ids_to_query.append(app_entry.rep_id)
            ret_json["results"][field_app_identifier_idx_dict[app_entry.identifier]]["rep_id"] = app_entry.rep_id
            if not app_entry.rep_id in rep_id_results_idxes.keys():
                rep_id_results_idxes[app_entry.rep_id] = []

            rep_id_results_idxes[app_entry.rep_id].append(field_app_identifier_idx_dict[app_entry.identifier])

        users = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for user in users:
            if user.rep_id in rep_id_results_idxes.keys():
                for idx in rep_id_results_idxes[user.rep_id]:
                    ret_json["results"][idx]["rep_name"] = user.first_name + " " + user.last_name

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pull_notes_for_customer":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["notes"] = []

        cust_notes = CustomerNote.query(CustomerNote.field_app_identifier == self.request.get("identifier")).order(CustomerNote.inserted_utc)
        authors_to_query = ["-1"]
        author_note_idxes = {}
        for cust_note in cust_notes:
            note_item = {}
            note_item["identifier"] = cust_note.identifier
            note_item["author"] = cust_note.author
            note_item["blob_count"] = cust_note.blob_count
            note_item["pacific"] = str(cust_note.inserted_pacific)
            note_item["utc"] = str(cust_note.inserted_utc)
            note_item["perms"] = cust_note.perms
            note_item["content"] = json.loads(cust_note.content)

            if not cust_note.author in authors_to_query:
                authors_to_query.append(cust_note.author)

            if not cust_note.author in author_note_idxes.keys():
                author_note_idxes[cust_note.author] = []

            author_note_idxes[cust_note.author].append(len(ret_json["notes"]))

            ret_json["notes"].append(note_item)

        authors = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(authors_to_query))
        for author in authors:
            try:
                idxes = author_note_idxes[author.identifier]
                for idx in idxes:
                    ret_json["notes"][idx]["author_name"] = author.first_name + " " + author.last_name
            except:
                x = 5

        for item in ret_json["notes"]:
            keys = item.keys()
            if not "author_name" in keys:
                item["author"] = "System"

        ret_json["notes"].reverse()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_note_for_customer":
        p_now = Helpers.pacific_now()
        note_id = "-1"
        content_dict = {}
        content_dict["txt"] = [self.request.get("txt")]
        note_key = "n/a"
        nkey_val = str(self.request.get("nkey"))
        logging.info(nkey_val)
        if nkey_val.lower() == "" or nkey_val.lower() == "none":
            note_key = note_key
        else:
            note_key = str(self.request.get("nkey"))

        blawb_count = 0
        if not str(self.request.get("has_file")) == "0":
            blawb_count += 1
            content_dict["mime_types"] = []

            pic_name = self.request.params["note_image"].filename.lower()
            name_elements = pic_name.split(".")

            pic_type = name_elements[len(name_elements) - 1]
            pic_ext = ""
            pic_mime = ""
            if pic_type.lower() == "png":
                pic_ext = "png"
                pic_mime = "image/png"
            else:
                pic_ext = "jpg"
                pic_mime = "image/jpg"

            content_dict["mime_types"].append(pic_mime)
            file_content = self.request.POST.multi['note_image'].file.read()

            note_id = CustomerTranscriber.transcribe_object(self.request.get("identifier"),
                                                    self.request.get("user_identifier"),
                                                    content_dict,
                                                    blawb_count,
                                                    note_key)
            comm_type = str(self.request.get("comm_type"))
            if (not comm_type == "") and (not comm_type == "none") and (not comm_type == "None"):
                kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="cust_comm_note_type_" + note_id,
                    val=str(self.request.get("comm_type")),
                    expiration=datetime(1970, 1, 1)
                )
                kv.put()

            bucket_name = os.environ.get('BUCKET_NAME',
                                            app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            filename = bucket + '/CustomerNoteBlobs/' + note_id + "_" + str(blawb_count) + "." + pic_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=pic_mime,
                                options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                retry_params=write_retry_params)

            gcs_file.write(file_content)
            gcs_file.close()

        else:
            note_id = CustomerTranscriber.transcribe_object(self.request.get("identifier"),
                                                    self.request.get("user_identifier"),
                                                    content_dict,
                                                    blawb_count,
                                                    note_key)

            comm_type = str(self.request.get("comm_type"))
            if (not comm_type == "") and (not comm_type == "none") and (not comm_type == "None"):
                kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="cust_comm_note_type_" + note_id,
                    val=str(self.request.get("comm_type")),
                    expiration=datetime(1970, 1, 1)
                )
                kv.put()

            customer_response = str(self.request.get("customer_response"))
            if (not customer_response == "") and (not customer_response == "none") and (not customer_response == "None"):
                kv2 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="cust_response_to_note_" + note_id,
                    val=str(self.request.get("customer_response")),
                    expiration=Helpers.pacific_now() + timedelta(days=365)
                )
                kv2.put()
                today = Helpers.pacific_today()
                response_file = GCSLockedFile("/CustomerNoteResponses/" + str(today) + ".json")
                content = response_file.read()
                if content is None:
                    content = "[]"

                items = json.loads(content)
                logging.info(items)
                items.append({"identifier": self.request.get("identifier"), "response": str(self.request.get("customer_response"))})
                response_file.write(json.dumps(items), "application/json", "public-read")
                response_file.unlock()

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps({"identifier": note_id}))

    elif self.request.get("fn") == "get_unapproved_expenses_list":
        self.response.content_type = "application/json"

        ret_dict = {}
        ret_dict["transactions"] = []

        expenses = MonetaryTransaction.query(
            ndb.AND(
                MonetaryTransaction.approved == False,
                MonetaryTransaction.denied == False
            )
        ).order(MonetaryTransaction.recorded_dt)

        for expense in expenses:
            expenses_list = {}
            expenses_list["identifier"] = expense.identifier
            expenses_list["amount"] = (expense.dollars * 100) + expense.cents
            expenses_list["description"] = expense.description
            description_key_temp = expense.description_key.split("_")
            description_key_1 = description_key_temp[0]
            description_key_2 = description_key_temp[1]
            expenses_list["description_key"] = description_key_1[0].upper() + description_key_1[1:] + " " + description_key_2[0].upper() + description_key_2[1:]
            expenses_list["recorded_dt"] = str(expense.recorded_dt)
            users_info = FieldApplicationUser.query(FieldApplicationUser.identifier == expense.recipient)
            for user in users_info:
                expenses_list["rep_id"] = user.rep_id
                expenses_list["user_name"] = user.first_name + " " + user.last_name

            ret_dict["transactions"].append(expenses_list)


        self.response.out.write(json.dumps(ret_dict))

    elif self.request.get("fn") == "get_unapproved_expense":

        self.response.content_type = "application/json"

        identifier = self.request.get("identifier")

        file_name = hashlib.md5(str(identifier)).hexdigest()

        ret_dict = {}
        ret_dict["transaction_receipt"] = []

        description = None
        description_key = None
        extra_info_dct = {}

        transactions = MonetaryTransaction.query(MonetaryTransaction.identifier == identifier)

        for receipt in transactions:
            description_key = receipt.description_key
            description = receipt.description
            extra_info_dct = json.loads(receipt.extra_info)

        pic_ext = extra_info_dct["file_extension"]

        folder_name_temp = description_key.split("_")
        folder_name_1 = folder_name_temp[0]
        folder_name_2 = folder_name_temp[1]
        folder = folder_name_1[0].upper() + folder_name_1[1:] + folder_name_2[0].upper() + folder_name_2[1:]

        receipt_image_file = "/Images/Receipts/" + folder + "/" + file_name + "." + pic_ext


        ret_dict = {}
        ret_dict["description"] = description
        ret_dict["receipt"] = receipt_image_file

        self.response.out.write(json.dumps(ret_dict))

    elif self.request.get("fn") == "approve_reimbursement":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        c_num = None
        transaction_date = None
        try:
            identifier = self.request.get("identifier")
            transaction = MonetaryTransaction.first(MonetaryTransaction.identifier == identifier)
            if not transaction is None:
                user_id = transaction.recipient
                this_upcoming_friday = Helpers.upcoming_friday()
                now = Helpers.pacific_now()
                weeks_ahead = 0
                if not (now.isoweekday() in [6, 7, 1, 2]):
                    weeks_ahead = 1

                c_num = Helpers.get_check_number_for_transaction(user_id, weeks_ahead)
                transaction.check_number = c_num
                transaction.denied = False
                transaction.approved = True
                Helpers.set_transaction_payout(transaction, weeks_ahead)
                transaction_date = transaction.effective_dt
                usr = FieldApplicationUser.first(FieldApplicationUser.identifier == user_id)
                if not usr is None:
                    Helpers.send_sms(usr.rep_phone, "Cha-Ching! An expense for $" + str(transaction.dollars) + "." + str(transaction.cents) + " has been approved for you.")
                ret_json["success"] = True
        except:
            ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "approve_expense":
        self.response.content_type = "application/json"

        identifier = self.request.get("identifier")
        option = self.request.get("option")

        transaction = MonetaryTransaction.query(MonetaryTransaction.identifier == identifier)

        for item in transaction:
            user_id = item.recipient

        ret_json = {}
        ret_json["success"] = False

        try:

            c_num = "-1"

            if option == "approve_this":

                today = Helpers.pacific_today()
                yr = str(today.year)
                mth = str(today.month)
                dy = str(today.day)

                e_d = datetime(int(yr), int(mth), int(dy), 0, 0, 0) + timedelta(days=-7)
                e_d = e_d + timedelta(minutes=-2)

                c_num = "-1"
                this_upcoming_friday = Helpers.pacific_today()
                weekday = this_upcoming_friday.isoweekday()

                while (not weekday == 5):
                    this_upcoming_friday = this_upcoming_friday + timedelta(days=1)
                    weekday = this_upcoming_friday.isoweekday()

                kkkey = "check_number_for_" + user_id + "_" + str(this_upcoming_friday).split(" ")[0]

                kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy == kkkey)
                for kv_item in kv_items:
                    c_num = kv_item.val

            else:

                today = Helpers.pacific_today()
                yr = str(today.year)
                mth = str(today.month)
                dy = str(today.day)

                e_d = datetime(int(yr), int(mth), int(dy), 0, 0, 0)
                e_d = e_d + timedelta(minutes=-2)


            transactions = MonetaryTransaction.query(MonetaryTransaction.identifier == identifier)

            for transaction in transactions:
                transaction.approved = True
                transaction.effective_dt= e_d
                transaction.check_number=c_num

                transaction.put()

                ret_json["success"] = True

        except:

            ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "deny_expense":

        self.response.content_type = "application/json"

        identifier = self.request.get("identifier")

        ret_json = {}
        ret_json["success"] = False

        try:

            transactions = MonetaryTransaction.query(MonetaryTransaction.identifier == identifier)

            for transaction in transactions:
                transaction.denied = True

                transaction.put()

                ret_json["success"] = True

        except:

            ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "deactivate_user":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.current_status = -1
            user.put()

            offices = OfficeLocation.query(OfficeLocation.is_parent == False)
            for office in offices:
                office.purge_yielder(user.identifier)
                office.purge_recipient(user.identifier)

            Helpers.drop_birthdays_for_user(user)

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps([]))


    elif self.request.get("fn") == "user_manager_assignment":
        usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not usr is None:
            usr.is_manager = (self.request.get("manager") == "1")
            usr.put()

    elif self.request.get("fn") == "user_pm_assignment":
        usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not usr is None:
            usr.is_project_manager = (self.request.get("pm") == "1")
            usr.put()

    elif self.request.get("fn") == "solar_pro_rep_user_type_swap":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            if user.user_type == "solar_pro":
                user.user_type = "field"
            elif user.user_type == "field":
                user.user_type = "solar_pro"
            user.put()

    elif self.request.get("fn") == "get_employee_directory":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        ret_json["offices"] = []

        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0).order(FieldApplicationUser.first_name).order(FieldApplicationUser.last_name)
        for user in users:
            usr_item = {}
            usr_item["identifier"] = user.identifier
            usr_item["email"] = user.rep_email
            usr_item["phone"] = Helpers.format_phone_number(user.rep_phone)
            usr_item["first_name"] = user.first_name
            usr_item["last_name"] = user.last_name
            usr_item["rep_id"] = user.rep_id
            usr_item["address"] = user.address
            usr_item["city"] = user.city
            usr_item["state"] = user.state
            usr_item["postal"] = user.postal
            usr_item["office"] = user.main_office
            usr_item["manager"] = user.is_manager
            usr_item["project_manager"] = user.is_project_manager
            usr_item["user_type"] = user.user_type
            usr_item["accepts_leads"] = user.accepts_leads
            usr_item["registration_date"] = str(user.registration_date)

            ret_json["users"].append(usr_item)

        offices = OfficeLocation.query(OfficeLocation.parent_identifier != "n/a")
        for office in offices:
            ret_json["offices"].append({"name": office.name, "identifier": office.identifier})



        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_unread_note_tally_for_user":
        self.response.content_type = "application/json"
        ret_json = {}

        field_app_ids_to_query = ["-1"]
        index = search.Index(name="cust_names")

        results = index.search(self.session["user_rep_id"])
        for result in results:
            for field in result.fields:
                if field.name == "cust_identifier":
                    field_app_ids_to_query.append(field.value)

        ret_json["count"] = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.field_app_identifier.IN(field_app_ids_to_query),
                CustomerNote.read == False
            )
        ).count()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_customers_for_user_in_session":
        self.response.content_type = "application/json"
        self.session = get_current_session()
        ret_json = {}
        ret_json["customers"] = []

        index = search.Index(name="cust_names")
        field_app_ids_to_query = ["-1"]
        app_entry_identifier_idx_dict = {}

        results = index.search(self.session["user_rep_id"])
        result_cnt = 0
        for result in results:
            result_item = {}
            result_item["unread_count"] = 0
            for field in result.fields:
                if field.name == "cust_name":
                    result_item["cust_name"] = field.value
                elif field.name == "cust_identifier":
                    app_entry_identifier_idx_dict[field.value] = result_cnt
                    result_item["identifier"] = field.value
                    field_app_ids_to_query.append(field.value)

            ret_json["customers"].append(result_item)
            result_cnt += 1

        if self.session["user_rep_id"] == "WATS0822":
            result_item = {}
            result_item["unread_count"] = 0
            result_item["cust_name"] = "Christopher Staley"
            result_item["identifier"] = "c09258b54279174dd3b66af3668b0a083020908cf4484242bb4a4678e94e2d08416c868ccec4d4035599d367bb30dfe7b22daa5c6ad738742042e222aa567b51"
            ret_json["customers"].append(result_item)
            field_app_ids_to_query.append(result_item["identifier"])
            app_entry_identifier_idx_dict[result_item["identifier"]] = result_cnt
            result_cnt += 1

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.field_app_identifier.IN(field_app_ids_to_query),
                CustomerNote.read == False
            )
        )
        for note in notes:
            ret_json["customers"][app_entry_identifier_idx_dict[note.field_app_identifier]]["unread_count"] += int(note.read == False)

        #ret_json["customers"] = Helpers.bubble_sort(ret_json["customers"], "cust_name")
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "read_notes_for_customer":
        self.response.content_type = "application/json"
        ret_json = {}

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.read == False
            )
        )
        ret_json["count"] = notes.count()

        if ret_json["count"] > 0:
            notes_to_put = []
            for note in notes:
                note.read = True
                notes_to_put.append(note)

            if len(notes_to_put) == 1:
                notes_to_put[0].put()
            elif len(notes_to_put) > 0:
                ndb.put_multi(notes_to_put)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "np_client_error_logger":
        self.response.content_type = "application/json"

        ret_json = {}
        ret_json["items"] = []
        ret_json["success"] = False

        user_identifier = "-1"
        try:
            user_identifier = self.session["user_identifier"]
        except:
            user_identifier = user_identifier
        user_agent = self.request.headers['User-Agent']
        error_message = self.request.get("error_message")
        line_number = self.request.get("line_number")
        url = self.request.get("url")
        column = self.request.get("column")
        stack_trace = self.request.get("stack_trace")
        date_created = Helpers.pacific_now()

        n = datetime.now()

        gcs_file = GCSLockedFile("/Logs/client_error_log_" + user_identifier + "_" + str(n.year) + "_" + str(n.month) + "_" + str(n.day) + ".txt")
        result = gcs_file.read()

        if not result is None:
            ret_json["items"] = json.loads(result)

            data_to_store = {}
            data_to_store["user_identifier"] = user_identifier
            data_to_store["user_agent"] = user_agent
            data_to_store["error_date"] = str(date_created)
            data_to_store["url"] = url
            data_to_store["error_message"] = error_message
            data_to_store["line_number"] = line_number
            data_to_store["column"] = column
            data_to_store["stack_trace"] = stack_trace

            ret_json["items"].append(data_to_store)

            gcs_file.write(json.dumps(ret_json["items"]), "text/plain", "public-read")

        else:

            data_to_store = {}
            data_to_store["user_identifier"] = user_identifier
            data_to_store["user_agent"] = user_agent
            data_to_store["error_date"] = str(date_created)
            data_to_store["url"] = url
            data_to_store["error_message"] = error_message
            data_to_store["line_number"] = line_number
            data_to_store["column"] = column
            data_to_store["stack_trace"] = stack_trace

            ret_json["items"].append(data_to_store)

            gcs_file.write(json.dumps(ret_json["items"]), "text/plain", "public-read")

        ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json["success"]))

    elif self.request.get("fn") == "rep_sp2_reschedule_inhouse":

        self.response.content_type = "application/json"

        identifier = self.request.get("identifier")
        sp2_date_items = self.request.get("sp2_date").split("-")
        h = int(self.request.get("sp2_hour"))
        sp2_min = self.request.get("sp2_minute")
        sp2_ampm = self.request.get("sp2_ampm")

        ret_json = {}
        ret_json["success"] = False

        ev = CalendarEvent.first(
            ndb.AND(
                CalendarEvent.event_key == "sp2",
                CalendarEvent.field_app_identifier == identifier
            )
        )
        if not ev is None:

            if 5 == 5:

                sp2_dt_start = datetime(int(sp2_date_items[2]), int(sp2_date_items[0]), int(sp2_date_items[1]))

                orig_h = h
                if h == 12 and sp2_ampm == "AM":
                    h = 0

                elif h < 12 and sp2_ampm == "PM":
                    h += 12

                sp2_dt_with_hours_added = sp2_dt_start + timedelta(hours=h)
                sp2_dt_with_mins_added = sp2_dt_with_hours_added + timedelta(minutes=int(sp2_min))

                wdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
                mths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                new_date_str = wdays[sp2_dt_start.isoweekday() - 1] + " " + mths[sp2_dt_start.month - 1] + " " + str(sp2_dt_start.day) + ", " + str(sp2_dt_start.year) + " at "
                if len(str(orig_h)) == 1:
                    new_date_str += "0" + str(orig_h)
                else:
                    new_date_str += str(orig_h)

                new_date_str += ":"
                if len(str(sp2_min)) == 1:
                    new_date_str += "0" + str(sp2_min)
                else:
                    new_date_str += str(sp2_min)

                new_date_str += sp2_ampm

                app_entry = FieldApplicationEntry.query(FieldApplicationEntry.identifier == identifier)

                for item in app_entry:
                    old_sp_too_time = item.sp_two_time
                    old_date_str = wdays[item.sp_two_time.weekday()] + " " + mths[item.sp_two_time.month - 1] + " " + str(item.sp_two_time.day) + ", " + str(item.sp_two_time.year) + " at "
                    h2 = item.sp_two_time.hour
                    ampm2 = "AM"
                    if item.sp_two_time.hour > 12:
                        h2 -= 12
                        ampm2 = "PM"

                    sp2_min2 = item.sp_two_time.minute
                    if len(str(h2)) == 1:
                        old_date_str += "0" + str(h2)
                    else:
                        old_date_str += str(h2)

                    old_date_str += ":"
                    if len(str(sp2_min2)) == 1:
                        old_date_str += "0" + str(sp2_min)
                    else:
                        old_date_str += sp2_min

                    old_date_str += ampm2

                    item.sp_two_time = sp2_dt_with_mins_added

                    minutes_off = Helpers.get_sp2_special_offset(item.office_identifier)
                    ret_json = Helpers.scheduling_conflict(item.sp_two_time, item.sp_two_time + timedelta(minutes=119 - minutes_off), item.rep_id, ev.identifier)
                    if ret_json["success"] or str(self.request.get("force")) == "1":
                        item.put()

                        ev.start_dt = item.sp_two_time
                        ev.end_dt = item.sp_two_time + timedelta(minutes=119 - minutes_off)
                        ev.put()

                        template_vars = {}
                        template_vars["cust_name"] = item.customer_first_name + " " + item.customer_last_name
                        template_vars["original_time"] = old_date_str
                        template_vars["new_time"] = new_date_str
                        template_vars["rep_phone"] = ""
                        template_vars["rep_name"] = ""
                        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id == item.rep_id)
                        for rep in reps:
                            template_vars["rep_name"] = rep.first_name + " " + rep.last_name
                            template_vars["rep_phone"] = Helpers.format_phone_number(rep.rep_phone)

                        if not str(self.request.get("skip_email")) == "1":
                            if not item.customer_email == "didnt_want_to_provide_email@no_domain.com":             
                                Helpers.send_html_email(item.customer_email, "New Power Appointment Rescheduled", "sp2_rescheduled", template_vars)

                        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "sp2_annoy_" + item.identifier)
                        if not kv is None:
                            kv.key.delete()
                        
                        kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "sp2_annoy_" + item.identifier + "_" + str(old_sp_too_time.year) + "-" + str(old_sp_too_time.month) + "-" + str(old_sp_too_time.day) + "-" + str(old_sp_too_time.hour) + "-" + str(old_sp_too_time.minute))
                        if not kv2 is None:
                            kv2.key.delete()

            else:

                ret_json["success"] = False

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "kwikie882":
        pw = "password"
        pw = Helpers.hash_pass(pw)
        self.response.out.write(pw)

    elif self.request.get("fn") == "get_rep_info":
        ret_json = {}
        ret_json["info"] = None
        self.response.content_type = "application/json"
        users = FieldApplicationUser.query(FieldApplicationUser.identifier == self.session["user_identifier"])
        for user in users:
            ret_json["info"] = {}
            ret_json["info"]["address"] = user.address
            ret_json["info"]["city"] = user.city
            ret_json["info"]["state"] = user.state
            ret_json["info"]["postal"] = user.postal
            ret_json["info"]["first_name"] = user.first_name
            ret_json["info"]["last_name"] = user.last_name
            ret_json["info"]["phone"] = Helpers.format_phone_number(user.rep_phone)
            ret_json["info"]["email"] = user.rep_email
            ret_json["info"]["notification_settings"] = json.loads(GCSLockedFile("/ApplicationSettings/UserSettings/Notifications/" + user.identifier + ".json").read())

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_rep_phone":
        users = FieldApplicationUser.query(FieldApplicationUser.identifier == self.session["user_identifier"])
        for user in users:
            user.rep_phone = self.request.get("new_phone").replace("(", "").replace(")", "").replace("-", "")
            user.put()
            self.session["user_phone"] = user.rep_phone

        self.response.out.write("")

    elif self.request.get("fn") == "update_rep_address":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
        if not user is None:
            user.address = self.request.get("address")
            user.put()
            Helpers.create_to_do_payroll_address_update(user)

    elif self.request.get("fn") == "update_rep_city":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
        if not user is None:
            user.city = self.request.get("city")
            user.put()
            Helpers.create_to_do_payroll_address_update(user)

    elif self.request.get("fn") == "update_rep_state":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
        if not user is None:
            user.state = self.request.get("state")
            user.put()
            Helpers.create_to_do_payroll_address_update(user)

    elif self.request.get("fn") == "update_rep_postal":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
        if not user is None:
            user.postal = self.request.get("postal")
            user.put()
            Helpers.create_to_do_payroll_address_update(user)

    elif self.request.get("fn") == "update_rep_email":
        users = FieldApplicationUser.query(FieldApplicationUser.identifier == self.session["user_identifier"])
        found_user = False
        existing_users = FieldApplicationUser.query(FieldApplicationUser.rep_email == self.request.get("new_emaill").lower())
        for existing_user in existing_users:
            found_user = True

        if not found_user:
            for user in users:
                user.rep_email = self.request.get("new_email").lower()
                user.put()
                self.session["user_email"] = user.rep_email

    elif self.request.get("fn") == "rep_sp2_trigger_after":
        self.response.content_type = "application/json"

        try:
            user_identifier = self.session["user_identifier"]
            rep_id = self.session["user_rep_id"]
            survey_identifier = Survey.first(Survey.active_triggers == "{\"field\":[\"after_rep_completes_sp2\"]}").identifier

            start_dt = datetime(2015, 11, 1)
            end_dt = Helpers.pacific_now() + timedelta(days=-1)
            end_dt = datetime(end_dt.year, end_dt.month, end_dt.day, 11, 59, 59)

            yesterday_key = "sp2_follow_up_v2_" + user_identifier + "_" + str(end_dt.year) + "_" + str(end_dt.month) + "_" + str(end_dt.day)
            yesterday_key = hashlib.md5(yesterday_key).hexdigest()

            items = []
            yesterday_vals = memcache.get(yesterday_key)
            yesterday_booking_identifiers = []
            if yesterday_vals is None:
                app_entries = FieldApplicationEntry.query(
                    ndb.AND
                    (
                        FieldApplicationEntry.archived == False,
                        FieldApplicationEntry.rep_id == rep_id,
                        FieldApplicationEntry.sp_two_time > start_dt,
                        FieldApplicationEntry.sp_two_time <= end_dt

                    )
                )

                temp_items = []
                for app_entry in app_entries:
                    if app_entry.save_me:
                        continue

                    data_to_store = {}
                    data_to_store["booking_identifier"] = app_entry.booking_identifier
                    data_to_store["sp2_date"] = str(app_entry.sp_two_time.month) + "/" + str(app_entry.sp_two_time.day) + "/" + str(app_entry.sp_two_time.year)
                    data_to_store["cust_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

                    yesterday_booking_identifiers.append(app_entry.booking_identifier)

                    temp_items.append(data_to_store)

                responses = SurveyResponse.query(
                    ndb.AND
                    (
                        SurveyResponse.user_identifier == user_identifier,
                        SurveyResponse.survey_identifier == survey_identifier
                    )
                )

                yesterday_booking_identifiers_to_exclude = []
                for response in responses:
                    identifier_types = json.loads(response.hidden_identifiers)
                    found = False
                    if "SurveyBooking" in identifier_types:
                        identifiers = json.loads(response.hidden_identifier_values)
                        idx = identifier_types.index("SurveyBooking")
                        booking_identifier = identifiers[idx]

                        if booking_identifier in yesterday_booking_identifiers:
                            found = True

                    if found:
                        yesterday_booking_identifiers_to_exclude.append(booking_identifier)

                for item in temp_items:
                    if not item["booking_identifier"] in yesterday_booking_identifiers_to_exclude:
                        items.append(item)

                memcache.set(key=yesterday_key, value=json.dumps(items), time=60 * 60 * 24 * 2)

            else:
                items = json.loads(yesterday_vals)

            now = Helpers.pacific_now()
            today_start_dt = datetime(now.year, now.month, now.day, 0, 0, 0)
            today_end_dt = now

            today_app_entries = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.archived == False,
                    FieldApplicationEntry.rep_id == rep_id,
                    FieldApplicationEntry.sp_two_time >= today_start_dt,
                    FieldApplicationEntry.sp_two_time <= today_end_dt
                )
            )

            temp_today_items = []
            today_booking_identifiers = []
            for today_app_entry in today_app_entries:
                if today_app_entry.save_me:
                    continue

                data_to_store = {}
                data_to_store["booking_identifier"] = today_app_entry.booking_identifier
                data_to_store["sp2_date"] = str(today_app_entry.sp_two_time.month) + "/" + str(today_app_entry.sp_two_time.day) + "/" + str(today_app_entry.sp_two_time.year)
                data_to_store["cust_name"] = today_app_entry.customer_first_name.strip().title() + " " + today_app_entry.customer_last_name.strip().title()

                today_booking_identifiers.append(today_app_entry.booking_identifier)
                temp_today_items.append(data_to_store)

            yesterday = Helpers.pacific_today() + timedelta(days=-1)
            yesterday_dt = datetime(yesterday.year, yesterday.month, yesterday.day)

            today_responses = SurveyResponse.query(
                ndb.AND
                (
                    SurveyResponse.user_identifier == user_identifier,
                    SurveyResponse.survey_identifier == survey_identifier,
                    SurveyResponse.insert_time >= yesterday_dt
                )
            )

            today_booking_identifiers_to_exclude = []

            for today_response in today_responses:
                identifier_types = json.loads(response.hidden_identifiers)
                found = False

                if "SurveyBooking" in identifier_types:
                    identifiers = json.loads(today_response.hidden_identifier_values)
                    idx = identifier_types.index("SurveyBooking")
                    booking_identifier = identifiers[idx]

                    if booking_identifier in today_booking_identifiers:
                        found = True

                if found:
                    today_booking_identifiers_to_exclude.append(booking_identifier)

            for item in temp_today_items:
                if not item["booking_identifier"] in today_booking_identifiers_to_exclude:
                    items.append(item)

            booking_ids_to_query = ["-1"]
            for item in items:
                booking_ids_to_query.append(item["booking_identifier"])

            booking_identifiers_to_keep = []
            bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
            for booking in bookings:
                if (not booking.archived) and (not booking.save_me):
                    booking_identifiers_to_keep.append(booking.identifier)

            final_items = []
            for item in items:
                if item["booking_identifier"] in booking_identifiers_to_keep:
                    final_items.append(item)

            ret_json = {}
            ret_json["items"] = final_items
            ret_json["success"] = True

        except:
            ret_json = {}
            ret_json["success"] = False
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "save_custom_options":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            info = json.loads(proposal.info)
            info["custom_svcs"] = json.loads(self.request.get("options"))
            proposal.info = json.dumps(info)
            proposal.put()

    elif self.request.get("fn") == "list_held_customers_for_admin":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []

        req_payload = json.loads(self.request.get("payload"))
        apps = []
        if (not req_payload["has_firstname_filter"]) and (not req_payload["has_lastname_filter"]):

            apps = FieldApplicationEntry.query(
                FieldApplicationEntry.has_holds == True
            ).order(-FieldApplicationEntry.insert_time)#.fetch(50, offset=int(req_payload["offset"]))

        elif (req_payload["has_firstname_filter"] and (not req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.has_holds == True,
                    ndb.OR(
                        FieldApplicationEntry.customer_first_name == req_payload["fname"],
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        elif (not req_payload["has_firstname_filter"] and (req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.has_holds == True,
                    ndb.OR(
                        FieldApplicationEntry.customer_last_name == req_payload["lname"],
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        else:
            #assume both are present
            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.has_holds == True,
                    ndb.AND(
                        ndb.OR(
                            FieldApplicationEntry.customer_first_name == req_payload["fname"],
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                        ),
                        ndb.OR
                        (
                            FieldApplicationEntry.customer_last_name == req_payload["lname"],
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                        )
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        for app in apps:
            customer_item = {}
            customer_item["identifier"] = app.identifier
            customer_item["name"] = app.customer_first_name + " " + app.customer_last_name
            customer_item["hold_items"] = json.loads(app.hold_items)
            ret_json["customers"].append(customer_item)

        ret_json["original_payload"] = req_payload

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "release_hold_for_customer":
        cust = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        cust.archive_reason = "n/a"
        hold_items = json.loads(cust.hold_items)
        try:
            del hold_items[int(self.request.get("index"))]
        except:
            hold_items = hold_items

        if len(hold_items) == 0:
            cust.has_holds = False

        cust.hold_items = json.dumps(hold_items)
        cust.put()

    elif self.request.get("fn") == "list_archived_customers_for_admin":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []

        req_payload = json.loads(self.request.get("payload"))
        apps = []
        if (not req_payload["has_firstname_filter"]) and (not req_payload["has_lastname_filter"]):

            apps = FieldApplicationEntry.query(
                FieldApplicationEntry.archived == True
            ).order(-FieldApplicationEntry.insert_time)#.fetch(50, offset=int(req_payload["offset"]))

        elif (req_payload["has_firstname_filter"] and (not req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.archived == True,
                    ndb.OR(
                        FieldApplicationEntry.customer_first_name == req_payload["fname"],
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        elif (not req_payload["has_firstname_filter"] and (req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.archived == True,
                    ndb.OR(
                        FieldApplicationEntry.customer_last_name == req_payload["lname"],
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        else:
            #assume both are present
            apps = FieldApplicationEntry.query(
                ndb.AND(
                    FieldApplicationEntry.archived == True,
                    ndb.AND(
                        ndb.OR(
                            FieldApplicationEntry.customer_first_name == req_payload["fname"],
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                        ),
                        ndb.OR
                        (
                            FieldApplicationEntry.customer_last_name == req_payload["lname"],
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                        )
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        for app in apps:
            customer_item = {}
            customer_item["identifier"] = app.identifier
            customer_item["name"] = app.customer_first_name + " " + app.customer_last_name
            customer_item["archive_reason"] = app.archive_reason
            ret_json["customers"].append(customer_item)

        ret_json["original_payload"] = req_payload

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_archived_customers_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []

        req_payload = json.loads(self.request.get("payload"))
        apps = []
        if (not req_payload["has_firstname_filter"]) and (not req_payload["has_lastname_filter"]):
            apps = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.archived == True,
                    FieldApplicationEntry.rep_id == self.session["user_rep_id"]
                )
            ).order(-FieldApplicationEntry.insert_time)#.fetch(50, offset=int(req_payload["offset"]))

        elif (req_payload["has_firstname_filter"] and (not req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.archived == True,
                    FieldApplicationEntry.rep_id == self.session["user_rep_id"],
                    ndb.OR
                    (
                        FieldApplicationEntry.customer_first_name == req_payload["fname"],
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                        FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)



        elif (not req_payload["has_firstname_filter"] and (req_payload["has_lastname_filter"])):

            apps = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.archived == True,
                    FieldApplicationEntry.rep_id == self.session["user_rep_id"],
                    ndb.OR
                    (
                        FieldApplicationEntry.customer_last_name == req_payload["lname"],
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                        FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        else:
            #assume both are present
            apps = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.archived == True,
                    FieldApplicationEntry.rep_id == self.session["user_rep_id"],
                    ndb.AND
                    (
                        ndb.OR
                        (
                            FieldApplicationEntry.customer_first_name == req_payload["fname"],
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].upper(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].lower(),
                            FieldApplicationEntry.customer_first_name == req_payload["fname"].title()
                        ),
                        ndb.OR
                        (
                            FieldApplicationEntry.customer_last_name == req_payload["lname"],
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].upper(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].lower(),
                            FieldApplicationEntry.customer_last_name == req_payload["lname"].title()
                        )
                    )
                )
            ).order(-FieldApplicationEntry.insert_time)

        for app in apps:
            customer_item = {}
            customer_item["identifier"] = app.identifier
            customer_item["name"] = app.customer_first_name + " " + app.customer_last_name
            customer_item["archive_reason"] = app.archive_reason
            ret_json["customers"].append(customer_item)

        ret_json["original_payload"] = req_payload

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "fixer333":
        entries1 = PerfectPacketEntry.query(PerfectPacketEntry.archived == True)
        entries2 = PerfectPacketSubmission.query(PerfectPacketSubmission.archived == True)
        entries3 = PerfectPacketApproval.query(PerfectPacketApproval.archived == True)
        entries4 = FieldApplicationEntry.query(FieldApplicationEntry.archived == True)
        entries5 = SurveyBooking.query(SurveyBooking.archived == True)

        app_identifiers_to_query = ["-1"]
        surveys_to_query = ["-1"]
        entries_to_query = ["-1"]
        submissions_to_query = ["-1"]
        approvals_to_query = ["-1"]

        apps_to_put = []
        surveys_to_put = []
        approvals_to_put = []
        submissions_to_put = []
        entries_to_put = []
        for entry in entries4:
            app_identifiers_to_query.append(entry.identifier)
            surveys_to_query.append(entry.booking_identifier)

        for entry in entries5:
            app_identifiers_to_query.append(entry.field_app_identifier)
            surveys_to_query.append(entry.identifier)

        for entry in entries3:
            app_identifiers_to_query.append(entry.field_application_identifier)
            surveys_to_query.append(entry.booking_identifier)
            submissions_to_query.append(entry.packet_submission_identifier)
            entries_to_query.append(entry.packet_entry_identifier)
            approvals_to_query.append(entry.identifier)

        for entry in entries2:
            app_identifiers_to_query.append(entry.field_application_identifier)
            surveys_to_query.append(entry.booking_identifier)
            submissions_to_query.append(entry.identifier)
            entries_to_query.append(entry.packet_entry_identifier)

        for entry in entries1:
            entries_to_query.append(entry.identifier)
            app_identifiers_to_query.append(entry.field_application_identifier)
            surveys_to_query.append(entry.booking_identifier)

        apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_identifiers_to_query))
        surveys = SurveyBooking.query(SurveyBooking.identifier.IN(surveys_to_query))
        approvals = PerfectPacketApproval.query(PerfectPacketApproval.identifier.IN(approvals_to_query))
        submissions = PerfectPacketApproval.query(PerfectPacketApproval.field_application_identifier.IN(app_identifiers_to_query))
        entries = PerfectPacketEntry.query(PerfectPacketEntry.identifier.IN(app_identifiers_to_query))


        for entity_rows in [apps, surveys, approvals, submissions, entries]:
            items_to_put = []
            for entity in entity_rows:
                entity.archived = True
                items_to_put.append(entity)

            if len(items_to_put) == 1:
                items_to_put[0].put()
            elif len(items_to_put) > 1:
                ndb.put_multi(items_to_put)
            else:
                x = 25

    elif self.request.get("fn") == "list_held_customers_for_rep":
        self.response.content_type = 'application/json'
        ret_json = {}
        ret_json["customers"] = []
        entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.has_holds == True,
                FieldApplicationEntry.rep_id == self.session["user_rep_id"]
            )
        )
        for entry in entries:
            cust = {}
            cust["identifier"] = entry.identifier
            cust["name"] = entry.customer_first_name + " " + entry.customer_last_name
            cust["hold_items"] = json.loads(entry.hold_items)
            cust["insert_time"] = entry.insert_time
            ret_json["customers"].append(cust)

        ret_json["customers"] = Helpers.bubble_sort(ret_json["customers"], "insert_time")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "fix_profile_pix":
        keyy = "tmp_users"
        val = memcache.get(keyy)
        if val is None:
            users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
            idents = []
            for usr in users:
                idents.append(usr.identifier)

            memcache.set(key=keyy, value=json.dumps(idents), time=3600)
        else:
            users = json.loads(val)
            if len(users) > 0:
                id = users[0]

                bucket_name = os.environ.get(
                    'BUCKET_NAME',
                    app_identity.get_default_gcs_bucket_name()
                )
                bucket = '/' + bucket_name
                write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                gcs_file1 = GCSLockedFile("/Images/default.jpg")
                bytes1 = gcs_file1.read()
                gcs_file2 = GCSLockedFile("/Images/default_thumb.jpg")
                bytes2 = gcs_file2.read()

                if not bytes1 is None:
                    filename = bucket + "/Images/ProfilePictures/Full/" + id + ".jpg"

                    gcs_file1 = gcs.open(
                        filename,
                        'w',
                        content_type="image/jpeg",
                        options={
                            'x-goog-meta-foo': 'foo',
                            'x-goog-meta-bar': 'bar',
                            'x-goog-acl': 'public-read',
                            'cache-control': 'public, max-age=0'
                        },
                        retry_params=write_retry_params)

                    gcs_file1.write(bytes1)
                    gcs_file1.close()

                if not bytes2 is None:
                    filename = bucket + "/Images/ProfilePictures/Thumb/" + id + ".jpg"

                    gcs_file2 = gcs.open(
                        filename,
                        'w',
                        content_type="image/jpeg",
                        options={
                            'x-goog-meta-foo': 'foo',
                            'x-goog-meta-bar': 'bar',
                            'x-goog-acl': 'public-read',
                            'cache-control': 'public, max-age=0'
                        },
                        retry_params=write_retry_params)

                    gcs_file2.write(bytes2)
                    gcs_file2.close()

                del users[0]
                memcache.set(key=keyy, value=json.dumps(users), time=3600)

                self.response.out.write("more work..")
            else:
                self.response.out.write("done...")

    elif self.request.get("fn") == "send_message":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["threads"] = []

        utc_now = datetime.now()
        txt = self.request.get("txt")
        blawb_count = 0
        has_blobs = self.request.get("has_files")
        recipients = json.loads(self.request.get("recipients"))
        is_everyone = ("everyone" in recipients)
        if is_everyone:
            recipients = []
            us = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
            for u in us:
                recipients.append(u.identifier)

        msg_ids = []
        for recipient in recipients:
            msg_ids.append(Helpers.guid())

        fyle_names = []
        fyle_mimes = []

        if has_blobs:
            while blawb_count < int(self.request.get("file_count")):
                filename = self.request.POST.multi["msg_file_" + str(blawb_count)].filename
                myme = self.request.POST["msg_file_" + str(blawb_count)].type

                fyle_names.append(filename)
                fyle_mimes.append(myme)

                blawb_count += 1

        if has_blobs:
            recip_cnt = 0
            for recipient in recipients:
                blawb_count = 0
                while blawb_count < int(self.request.get("file_count")):
                    fyle = self.request.POST.multi["msg_file_" + str(blawb_count)].file.read()

                    bucket_name = os.environ.get(
                        'BUCKET_NAME',
                        app_identity.get_default_gcs_bucket_name()
                    )
                    bucket = '/' + bucket_name

                    extension = fyle_names[blawb_count].split(".")[len(fyle_names[blawb_count].split(".")) - 1]
                    filename = bucket + '/MessageBlobs/' + msg_ids[recip_cnt] + "_" + str(blawb_count) + "." + extension

                    write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                    gcs_file = gcs.open(
                        filename,
                        'w',
                        content_type=myme,
                        options={
                            'x-goog-meta-foo': 'foo',
                            'x-goog-meta-bar': 'bar',
                            'x-goog-acl': 'public-read',
                            'content-disposition': 'attachment'
                        },
                        retry_params=write_retry_params
                    )

                    gcs_file.write(fyle)
                    gcs_file.close()

                    blawb_count += 1

                recip_cnt += 1

        start_new_threads = (self.request.get("identifier") == "-1")

        mts = []
        msgs = []

        cnt = 0
        while cnt < len(recipients):
            mts.append(None)
            cnt += 1

        cnt = 0
        while cnt < len(recipients):
            msg = Message(
                identifier=msg_ids[cnt],
                sender_identifier=self.session["user_identifier"],
                recipient_identifier=recipients[cnt],
                send_time=utc_now,
                content=txt,
                read_by_recipient=False,
                blob_count=int(self.request.get("file_count")),
                blob_names=json.dumps(fyle_names),
                blob_mimes=json.dumps(fyle_mimes)
            )
            msgs.append(msg)

            cnt += 1

        cnt = 0
        if start_new_threads:
            while cnt < len(recipients):
                mt = MessageThread(
                    identifier=Helpers.guid(),
                    original_sender_identifier=self.session["user_identifier"],
                    original_recipient_identifier=recipients[cnt],
                    latest_activity=utc_now,
                    messages=[msgs[cnt]],
                    latest_recipient=recipients[cnt],
                    read=False
                )
                mts[cnt] = mt
                cnt += 1
        else:
            mt = MessageThread.first(MessageThread.identifier == self.request.get("identifier"))

            while cnt < len(recipients):
                mt.messages.append(msgs[0])
                mt.latest_recipient = msgs[0].recipient_identifier
                mt.read = False
                mts[cnt] = mt
                cnt += 1

        ret_json["threads"] = []
        for mt in mts:
            ret_json["threads"].append(mt.prepare_for_client())

        for message_thread in mts:
            if not message_thread is None:
                message_thread.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "reactivate_user":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.current_status = 0
            user.put()

    elif self.request.get("fn") == "read_message":
        thread = MessageThread.first(MessageThread.identifier == self.request.get("thread_identifier"))
        if not thread is None:
            for message in thread.messages:
                if message.identifier == self.request.get("identifier"):
                    message.read_by_recipient = True
                    thread.read = True
                    thread.put()


    elif self.request.get("fn") == "list_all_users":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["contacts"] = []

        users = []
        if str(self.request.get("kicks")) == "1":
            users = FieldApplicationUser.query()
        elif str(self.request.get("kicks")) == "2":
            users = FieldApplicationUser.query(FieldApplicationUser.current_status == -1)
        else:
            users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        for user in users:
            usr_item = {}
            usr_item["identifier"] = user.identifier
            usr_item["rep_id"] = user.rep_id
            usr_item["name"] = user.first_name + " " + user.last_name
            usr_item["first_name"] = user.first_name
            usr_item["last_name"] = user.last_name
            usr_item["email"] = user.rep_email
            ret_json["contacts"].append(usr_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_non_admins":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []

        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        for user in users:
            if user.user_type == "super":
                continue

            usr_item = {}
            usr_item["identifier"] = user.identifier
            usr_item["name"] = user.first_name + " " + user.last_name
            usr_item["first_name"] = user.first_name
            usr_item["last_name"] = user.last_name
            usr_item["rep_id"] = user.rep_id
            ret_json["users"].append(usr_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_threads_for_user":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["threads"] = []

        threads = MessageThread.query(
            ndb.OR(
                MessageThread.original_sender_identifier == self.session["user_identifier"],
                MessageThread.original_recipient_identifier == self.session["user_identifier"]
            )
        ).order(-MessageThread.latest_activity).fetch(50, offset=int(self.request.get("offset")))

        for thread in threads:
            ret_json["threads"].append(thread.prepare_for_client())

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_unread_threads_for_user":
        import json
        u_id = ""
        try:
            u_id = self.session["user_identifier"]
        except:
            u_id = u_id

        try:
            cookie_val = self.request.cookies.get('snooze_message_notifications')
            if not cookie_val is None:
                u_id = self.request.cookies.get('snooze_message_notifications')
        except:
            u_id = u_id

        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["senders"] = []
        ret_json["u_id"] = u_id
        threads = MessageThread.query(
            ndb.AND
            (
                MessageThread.latest_recipient == u_id,
                MessageThread.read == False
            )
        )
        for thread in threads:
            last_message = thread.messages[len(thread.messages) - 1]
            sender = last_message.sender_identifier

            if not sender in ret_json["senders"]:
                ret_json["senders"].append(sender)

        if len(ret_json["senders"]) > 0:
            ret_json["sender_name_dict"] = {}
            users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(ret_json["senders"]))
            for user in users:
                ret_json["sender_name_dict"][user.identifier] = user.first_name + " " + user.last_name

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "assume_session":
        if 5 == 5:
            if not self.session["user_type"] == "super":
                self.session.non_existement_method("foo", "bar")
            user = FieldApplicationUser.first(FieldApplicationUser.rep_id == self.request.get("rep_id"))
            if not user.user_type == "super":
                self.session["user_identifier"] = user.identifier
                self.session["user_type"] = user.user_type
                self.session["user_name"] = user.first_name + " " + user.last_name
                self.session["user_phone"] = user.rep_phone
                self.session["user_email"] = user.rep_email
                self.session["user_rep_id"] = user.rep_id
                self.session["user_rep_office"] = str(user.main_office)
                self.session["assumed"] = "1"
            if self.session["user_email"] == "thomas@thepower.co" or self.session["user_email"] == "rnirnber@gmail.com":
                if not user.rep_email == "rnirnber@gmail.com":
                    self.session["user_identifier"] = user.identifier
                    self.session["user_type"] = user.user_type
                    self.session["user_name"] = user.first_name + " " + user.last_name
                    self.session["user_phone"] = user.rep_phone
                    self.session["user_email"] = user.rep_email
                    self.session["user_rep_id"] = user.rep_id
                    self.session["user_rep_office"] = str(user.main_office)
                    self.session["assumed"] = "1"
        else:            
            x = 25

    elif self.request.get("fn") == "list_bad_repids":
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        ret_json = {}
        ret_json["users"] = []
        for user in users:
            usr_item = {}
            usr_item["name"] = user.first_name + " " + user.last_name
            usr_item["rep_id"] = user.rep_id
            letter_cnt = 0
            for char in usr_item["rep_id"]:
                letter_cnt += int((ord(char) >= 65 and ord(char) <= 90) or (ord(char) >= 97 and ord(char) <= 122))

            if letter_cnt < 4:
                ret_json["users"].append(usr_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "upload_rep_pic":
        from PIL import Image
        from io import BytesIO
        import StringIO

        coords = json.loads(self.request.get("coords"))
        coords_copy = {}
        for key in coords.keys():
            coords_copy[key] = int(coords[key])

        user_image = Image.open(BytesIO(self.request.POST.multi["filedata"].file.read()))
        user_image.crop(
            (
                int(coords["x"]),
                int(coords["y"]),
                int(coords["x"]) + int(coords["w"]),
                int(coords["y"]) + int(coords["h"])
            )
        )
        user_image.load()

        user_image = user_image.resize((1000, 1000), Image.ANTIALIAS)

        output = StringIO.StringIO()

        user_image.save(output, format='JPEG')

        output.seek(0)
        output_s = output.read()

        b64 = base64.b64encode(output_s)

        bytes_stream = BytesIO(base64.b64decode(b64))

        output2 = StringIO.StringIO()
        user_image.save(output2, format='JPEG')
        output2.seek(0)

        output2_s = output2.read()

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        user_image = user_image.resize((200, 200), Image.ANTIALIAS)

        output3 = StringIO.StringIO()
        user_image.save(output3, format='JPEG')
        output3.seek(0)

        output3_s = output3.read()

        filename = bucket + '/Images/ProfilePictures/Full/' + self.session["user_identifier"] + '.jpg'
        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="image/jpeg",
                    options=
                    {
                        'x-goog-meta-foo': 'foo',
                        'x-goog-meta-bar': 'bar',
                        'x-goog-acl': 'public-read',
                        'cache-control': 'no-cache'
                    },
                    retry_params=write_retry_params
        )
        gcs_file.write(output2_s)
        gcs_file.close()

        filename2 = bucket + '/Images/ProfilePictures/Thumb/' + self.session["user_identifier"] + '.jpg'
        gcs_file2 = gcs.open(
                    filename2,
                    'w',
                    content_type="image/jpeg",
                    options=
                    {
                        'x-goog-meta-foo': 'foo',
                        'x-goog-meta-bar': 'bar',
                        'x-goog-acl': 'public-read',
                        'cache-control': 'no-cache'
                    },
                    retry_params=write_retry_params
        )
        gcs_file2.write(output3_s)
        gcs_file2.close()

        output.close()
        output2.close()
        output3.close()
        bytes_stream.close()

    elif self.request.get("fn") == "fix_message_threads":
        mts_to_put = []
        mts = MessageThread.query()
        for mt in mts:
            msgs = mt.messages
            mt.latest_recipient = msgs[len(msgs) - 1].recipient_identifier
            mt.read = msgs[len(msgs) - 1].read_by_recipient
            mts_to_put.append(mt)

        ndb.put_multi(mts_to_put)

    elif self.request.get("fn") == "fix_automatic_overrides":
        users_to_put = []
        users = FieldApplicationUser.query()
        for user in users:
            user.automatic_override_designee = user.recruiter_rep_id
            users_to_put.append(user)

        ndb.put_multi(users_to_put)

    elif self.request.get("fn") == "pull_recruiter_rep_ids":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        users = FieldApplicationUser.query()
        for user in users:
            usr_item = {}
            usr_item["name"] = user.first_name + " " + user.last_name
            usr_item["rep_id"] = user.rep_id
            usr_item["recruiter_rep_id"] = user.recruiter_rep_id

            ret_json["users"].append(usr_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "enable_disable_automatic_overrides":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.automatic_override_enabled = bool(int(self.request.get("flag")))
            user.put()

        self.response.out.write(" ")

    elif self.request.get("fn") == "rep_id_to_name":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["name"] = ""
        user = FieldApplicationUser.first(FieldApplicationUser.rep_id == self.request.get("rep_id"))
        if not user is None:
            ret_json["name"] = user.first_name + " " + user.last_name

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_rep_by_rep_id":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        user = FieldApplicationUser.first(FieldApplicationUser.rep_id == self.request.get("rep_id").upper())
        if not user is None:
            ret_json["success"] = True
            ret_json["identifier"] = user.identifier
            ret_json["rep_id"] = user.rep_id
            ret_json["name"] = user.first_name.strip().title() + " " + user.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "reassign_automatic_override_designee":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.automatic_override_designee = self.request.get("designee")
            user.put()

    elif self.request.get("fn") == "set_automatic_override_amount":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.automatic_override_amount = float(self.request.get("amount"))
            user.put()

    elif self.request.get("fn") == "list_admins":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["admins"] = []
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.user_type == "super"
            )
        )
        for user in users:
            ret_json["admins"].append({"name": user.first_name.strip().title() + " " + user.last_name.strip().title(), "allowed_functions": json.loads(user.allowed_functions), "identifier": user.identifier})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "admin_tool_access_allow_deny":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        allowed = (self.request.get("allowed") == "1")
        if not user is None:
            allowed_functions = json.loads(user.allowed_functions)
            if allowed:
                if not self.request.get("tool") in allowed_functions:
                    allowed_functions.append(self.request.get("tool"))
            else:
                if self.request.get("tool") in allowed_functions:
                    idx = allowed_functions.index(self.request.get("tool"))
                    del allowed_functions[idx]

            user.allowed_functions = json.dumps(allowed_functions)
            user.put()

    elif self.request.get("fn") == "pull_future_transactions_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["transactions"] = []
        identifier = self.request.get("identifier")
        millis = (int(time.time()) * 1000)
        millis -= (1000 * 60 * 60 * 24 * 180)

        if self.request.get("type") == "1A" or self.request.get("type") == "1B":        
            pp_subs = PerfectPacketSubmission.query(
                ndb.AND
                (
                    PerfectPacketSubmission.rep_identifier == identifier,
                    PerfectPacketSubmission.rep_submission_date >= Helpers.pacific_now() + timedelta(days=-180)
                )
            )
            app_identifiers = ["-1"]
            app_identifiers_with_closers = []
            for pp_sub in pp_subs:
                if pp_sub.archived or pp_sub.save_me:
                    continue

                info = json.loads(pp_sub.extra_info)
                if "project_management_checkoffs" in info.keys():
                    if "welcome_call_completed" in info["project_management_checkoffs"].keys():
                        if info["project_management_checkoffs"]["welcome_call_completed"]["checked"]:
                            app_identifiers.append(pp_sub.field_application_identifier)                            

                            if "closer" in info.keys():
                                app_identifiers_with_closers.append(pp_sub.field_application_identifier)


            ret_json["app_identifiers_with_closers"] = app_identifiers_with_closers
            v2_transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.recipient == identifier,
                    MonetaryTransactionV2.description_key == "rep_sales_commission_" + self.request.get("type"),
                    MonetaryTransactionV2.field_app_identifier.IN(app_identifiers)
                )
            )

            app_identifiers.remove("-1")
            for t in v2_transactions:
                if t.field_app_identifier in app_identifiers:
                    app_identifiers.remove(t.field_app_identifier)

            if len(app_identifiers) > 0:
                app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_identifiers))
                bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_identifiers))
                proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_identifiers))                

                app_identifier_name_dict = {}
                office_identifiers = ["-1"]
                app_identifier_booking_dict = {}
                app_identifier_proposal_dict = {}
                app_identifier_baseline_price_dict = {}
                app_entry_copies = []
                for app_entry in app_entries:
                    app_entry_copies.append(app_entry)
                    app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                    if not app_entry.office_identifier in office_identifiers:
                        office_identifiers.append(app_entry.office_identifier)
                    app_identifier_baseline_price_dict[app_entry.identifier] = app_entry.baseline_price
                
                for booking in bookings:
                    app_identifier_booking_dict[booking.field_app_identifier] = booking

                for proposal in proposals:
                    proposal.fix_system_size()
                    proposal.fix_additional_amount()
                    app_identifier_proposal_dict[proposal.field_app_identifier] = json.loads(proposal.info)

                office_locations = OfficeLocation.query(OfficeLocation.identifier.IN(office_identifiers))
                office_identifier_parent_identifier_dict = {}
                for ol in office_locations:
                    office_identifier_parent_identifier_dict[ol.identifier] = ol.parent_identifier

                funds = Helpers.list_funds()
                pricing_structures = Helpers.get_pricing_structures()

                app_identifier_price_per_kw_dict = {}
                app_identifier_price_per_kw_ppa_dict = {}
                for a in app_entry_copies:
                    app_identifier_price_per_kw_dict[a.identifier] = Helpers.crunch("fx_Commission_Price_Per_Kw", office_identifier_parent_identifier_dict[a.office_identifier], a, app_identifier_booking_dict[a.identifier], app_identifier_proposal_dict[a.identifier], pricing_structures, funds)
                    app_identifier_price_per_kw_ppa_dict[a.identifier] = Helpers.crunch("fx_Commission_Price_Per_Kw_Leaase_PPA", office_identifier_parent_identifier_dict[a.office_identifier], a, app_identifier_booking_dict[a.identifier], app_identifier_proposal_dict[a.identifier], pricing_structures, funds)
                
                for item in app_identifier_price_per_kw_dict.keys():
                    trans = {"name": app_identifier_name_dict[item], "identifier": item}
                    sys_size = float(app_identifier_proposal_dict[item]["system_size"])
                    multiplier = float(app_identifier_price_per_kw_dict[item])
                    fund_name_components =  app_identifier_booking_dict[item].fund.split("_")
                    if "ppa" in fund_name_components or "lease" in fund_name_components:                    
                        multiplier = app_identifier_price_per_kw_ppa_dict[item]
                    total = sys_size * multiplier
                    
                    if item in app_identifiers_with_closers:
                        trans["amount"] = str(0.5 * (sys_size * (multiplier - float(100))))
                    else:
                        trans["amount"] = str(0.5 * (sys_size * multiplier))

                    ret_json["transactions"].append(trans)

        elif self.request.get("type") == "closing_bonuses":
            identifiers = ["-1"]
            pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_submission_date >= Helpers.pacific_now() + timedelta(days=-180))
            for pp_sub in pp_subs:
                if pp_sub.archived or pp_sub.save_me:
                    continue

                info = json.loads(pp_sub.extra_info)
                if "project_management_checkoffs" in info.keys():
                    if "welcome_call_completed" in info["project_management_checkoffs"].keys():
                        if info["project_management_checkoffs"]["welcome_call_completed"]["checked"]:
                            if "closer" in info.keys():
                                if info["closer"] == identifier:
                                    identifiers.append(pp_sub.field_application_identifier)

            if len(identifiers) > 1:
                proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(identifiers))
                app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(identifiers))
                app_identifier_proposal_dict = {}
                app_identifier_name_dict = {}
                for a in app_entries:
                    app_identifier_name_dict[a.identifier] = a.customer_first_name.strip().title() + " " + a.customer_last_name.strip().title()
                for p in proposals:
                    p.fix_system_size()
                    p.fix_additional_amount()
                    app_identifier_proposal_dict[p.field_app_identifier] = json.loads(p.info)
                app_identifiers = []
                for pp_sub in pp_subs:
                    if pp_sub.archived or pp_sub.save_me:
                        continue
                        
                    info = json.loads(pp_sub.extra_info)
                    if "closer" in info.keys():
                        if info["closer"] == identifier:
                            app_identifiers.append(pp_sub.field_application_identifier)

                if len(app_identifiers) > 0:
                    app_identifier_transactions_dict = {}
                    for a in app_identifiers:
                        app_identifier_transactions_dict[a] = {"A": True, "B": True}

                    v2transactions = MonetaryTransactionV2.query(
                        ndb.AND
                        (
                            MonetaryTransactionV2.field_app_identifier.IN(app_identifiers),
                            MonetaryTransactionV2.description_key.IN(["closers_bonus_A", "closers_bonus_B"])
                        )
                    )
                    for t in v2transactions:
                        app_identifier = t.field_app_identifier
                        stripped = t.description_key.replace("closers_bonus_", "")
                        app_identifier_transactions_dict[app_identifier][stripped] = False

                    for item in app_identifier_transactions_dict.keys():
                        if item in app_identifier_proposal_dict.keys() and item in app_identifier_transactions_dict.keys():
                            ss = float(app_identifier_proposal_dict[item]["system_size"])
                            if app_identifier_transactions_dict[item]["A"]:
                                ret_json["transactions"].append({"identifier": item, "name": app_identifier_name_dict[item], "step": "A", "amount": str(0.5 * (ss * float(100)))})
                            if app_identifier_transactions_dict[item]["B"]:
                                ret_json["transactions"].append({"identifier": item, "name": app_identifier_name_dict[item], "step": "B", "amount": str(0.5 * (ss * float(100)))})
                        
        elif self.request.get("type") == "overrides":
            app_ids_to_query = ["-1"]
            pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_submission_date >= Helpers.pacific_now() + timedelta(days=-180))
            for pp_sub in pp_subs:
                if pp_sub.archived or pp_sub.save_me:
                    continue

                info = json.loads(pp_sub.extra_info)
                if "project_management_checkoffs" in info.keys():
                    if "welcome_call_completed" in info["project_management_checkoffs"].keys():
                        if info["project_management_checkoffs"]["welcome_call_completed"]["checked"]:
                            app_ids_to_query.append(pp_sub.field_application_identifier)
                


                v2transactions = MonetaryTransactionV2.query(
                    ndb.AND
                    (
                        MonetaryTransactionV2.field_app_identifier.IN(app_ids_to_query),
                        MonetaryTransactionV2.description_key.IN(["const_complete_override"])
                    )
                )

            for t in v2transactions:
                while t.field_app_identifier in app_ids_to_query:
                    app_ids_to_query.remove(t.field_app_identifier)

            app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
            bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query))
            proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
            office_identifiers = ["-1"]
            app_identifier_name_dict = {}
            app_identifier_office_identifier_dict = {}
            for app_entry in app_entries:
                app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                if not app_entry.office_identifier in office_identifiers:
                    office_identifiers.append(app_entry.office_identifier)
                app_identifier_office_identifier_dict[app_entry.identifier] = app_entry.office_identifier

            app_identifier_sys_size_dict = {}
            for proposal in proposals:
                sys_size = float(0)
                proposal.fix_additional_amount()
                proposal.fix_system_size()
                info = json.loads(proposal.info)
                app_identifier_sys_size_dict[proposal.field_app_identifier] = float(info["system_size"])

            app_identifier_fund_dict = {}
            for booking in bookings:
                app_identifier_fund_dict[booking.field_app_identifier] = booking.fund
                

            office_locations = OfficeLocation.query(OfficeLocation.identifier.IN(office_identifiers))
            office_identifier_market_identifier_dict = {}
            office_identifier_override_data_dict = {}
            for o in office_locations:
                office_identifier_override_data_dict[o.identifier] = o.get_override_data()
                office_identifier_market_identifier_dict[o.identifier] = o.parent_identifier


            override_app_identifier_list = []
            pricing_structures = Helpers.get_pricing_structures()
            for item in app_identifier_sys_size_dict.keys():
                o_identifier = app_identifier_office_identifier_dict[item]
                o_data = office_identifier_override_data_dict[o_identifier]
                for yielder in o_data["data"].keys():
                    for obj in o_data["data"][yielder]:
                        if obj["identifier"] == identifier and float(obj["amount"]) >= 0.01:                            
                            multip_factor = 1.0
                            fund = app_identifier_fund_dict[item]
                            fund_name_components = fund.split("_")
                            if "lease" in fund_name_components or "ppa" in fund_name_components:                                
                                market_identifier = office_identifier_market_identifier_dict[o_identifier]
                                if market_identifier in pricing_structures.keys():
                                    if "ppa_override_multiplication_factor" in pricing_structures[market_identifier].keys():
                                        multip_factor = float(pricing_structures[market_identifier]["ppa_override_multiplication_factor"])

                            if not item in override_app_identifier_list:               
                                ret_json["transactions"].append({"identifier": item, "amount": str(multip_factor * (float(obj["amount"]) * app_identifier_sys_size_dict[item])), "name": app_identifier_name_dict[item]})
                                override_app_identifier_list.append(item)

        elif self.request.get("type") == "futures":
            transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.recipient == identifier,
                    MonetaryTransactionV2.payout_date >= (Helpers.upcoming_friday() + timedelta(days=7)).date()                        
                )
            )

            for item in transactions:
                amt = item.dollars + (float(item.cents) * 0.01)
                ret_json["transactions"].append({"description": item.description, "date": str(item.payout_date), "amount": str(amt)})


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "archived_customers_search":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []
        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))
        potential_identifiers = ["-1"]
        for result in results:
            for field in result.fields:
                if field.name == "cust_identifier":
                    potential_identifiers.append(field.value)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(potential_identifiers))
        for app_entry in app_entries:
            if app_entry.archived:
                customer = {}
                customer["identifier"] = app_entry.identifier
                customer["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                customer["address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
                customer["phone"] = app_entry.customer_phone
                customer["phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
                customer["email"] = app_entry.customer_email
                ret_json["customers"].append(customer)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_true_hk_data_for_reports":
        self.response.content_type = "application/json"
        ret_json = {"data": {}, "rep_id_to_name": {}}
        start_dt = datetime.now()
        end_dt = datetime.now()
        h_p_t = Helpers.pacific_today()

        start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
        while not start_dt.isoweekday() == 7:
            start_dt = start_dt + timedelta(days=-1)

        start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

        start_dt = start_dt + timedelta(days=-7)
        end_dt = end_dt + timedelta(days=-7)
        

        hk_data = HKTally.query(
            ndb.AND(
                HKTally.dt >= start_dt,
                HKTally.dt <= end_dt
            )
        )

        rep_ids_to_query = ["-1"]
        rep_identifier_hk_dict = {}
        for item in hk_data:
            if not item.rep_identifier in rep_identifier_hk_dict.keys():
                rep_identifier_hk_dict[item.rep_identifier] = 0
            rep_identifier_hk_dict[item.rep_identifier] += item.minutes
            if not item.rep_identifier in rep_ids_to_query:
                rep_ids_to_query.append(item.rep_identifier)

        for rep_identifier in rep_identifier_hk_dict.keys():
            minutes = rep_identifier_hk_dict[rep_identifier]
            hours = float(minutes) / float(60)
            hours = round(hours, 2)
            rep_identifier_hk_dict[rep_identifier] = hours

        rep_id_name_dict = {}
        rep_identifier_name_dict = {}
        rep_identifier_rep_id_dict = {}
        rep_id_rep_identifier_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_id_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_rep_id_dict[rep.identifier] = rep.rep_id
            rep_id_rep_identifier_dict[rep.rep_id] = rep.identifier

        for rep_identifier in rep_identifier_hk_dict.keys():
            rep_id = rep_identifier_rep_id_dict[rep_identifier]
            ret_json["data"][rep_id] = rep_identifier_hk_dict[rep_identifier]
            ret_json["rep_id_to_name"][rep_id] = rep_identifier_name_dict[rep_identifier]

        self.response.out.write(json.dumps(ret_json))
        
    elif self.request.get("fn") == "get_leaderboard_data":        
        self.response.content_type = "application/json"
        ret_json = {}

        solar_pro_rep_ids = []
        rep_rep_ids = []

        try:
            metric_keys = json.loads(self.request.get("achievement_metric"))
        except:
            metric_keys = [self.request.get("achievement_metric")]            

        users = FieldApplicationUser.query()
        for user in users:
            if user.user_type in ["field", "asst_mgr", "co_mgr", "sales_dist_mgr", "rg_mgr", "super", "energy_expert", "sales_manager"]:
                rep_rep_ids.append(user.rep_id)
            elif user.user_type == "solar_pro" or user.user_type == "solar_pro_manager":
                solar_pro_rep_ids.append(user.rep_id)

        office_cond = (LeaderBoardStat.dt >= datetime(1970, 1, 1))
        if (not str(self.request.get("office")) == "-1"):
            office_cond = (LeaderBoardStat.office_identifier == self.request.get("office"))

        ak_only_reps = self.request.get("achievement_metric") == "appointments_kept_reps"
        ak_only_solar_pros = self.request.get("achievement_metric") == "appointments_kept_solar_pros"

        achievement_metric = self.request.get("achievement_metric")
        if ak_only_reps or ak_only_solar_pros:
            metric_keys = ["appointments_kept"]
        ret_json["office_tallies"] = {}
        
        ret_json["data"] = {}
        ret_json["rep_id_to_identifier"] = {}
        ret_json["identifier_to_rep_id"] = {}
        ret_json["rep_id_to_name"] = {}
        ret_json["rep_id_offices"] = {}
        for user in users:
            ret_json["rep_id_to_identifier"][user.rep_id] = user.identifier
            ret_json["identifier_to_rep_id"][user.identifier] = user.rep_id
            ret_json["rep_id_to_name"][user.rep_id] = user.first_name.strip().title() + " " + user.last_name.strip().title()

        start_dt = datetime.now()
        end_dt = datetime.now()

        lb_stats = []
        lb_stats2 = []
        h_p_t = Helpers.pacific_today()
        if self.request.get("time_metric") == "all_time":
            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    office_cond
                )
            )
            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == self.request.get("appointment_cancelled"),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "daily":
            start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
            end_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day, 23, 59, 59)
            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= Helpers.pacific_now(),
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "weekly":
            start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
            while not start_dt.isoweekday() == 7:
                start_dt = start_dt + timedelta(days=-1)

            start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
            end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
            end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= Helpers.pacific_now(),
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "monthly":
            start_dt = datetime(h_p_t.year, h_p_t.month, 1)
            end_dt = datetime(h_p_t.year, h_p_t.month, 28)
            while end_dt.month == start_dt.month:
                end_dt = end_dt + timedelta(days=1)

            end_dt = end_dt + timedelta(seconds=-1)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= Helpers.pacific_now(),
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "quarterly":
            months_start_map = {"1": 1, "2": 1, "3": 1, "4": 4, "5": 4, "6": 4, "7": 7, "8": 7, "9": 7, "10": 10, "11": 10, "12": 10}
            months_end_map = {"1": 3, "2": 3, "3": 3, "4": 6, "5": 6, "6": 6, "7": 9, "8": 9, "9": 9, "10": 12, "11": 12, "12": 12}
            days_end_map = {"3": 31, "6": 30, "9": 30, "12": 31}

            start_dt = datetime(h_p_t.year, months_start_map[str(h_p_t.month)], 1)
            end_month = months_end_map[str(h_p_t.month)]
            end_day = days_end_map[str(end_month)]
            end_dt = datetime(h_p_t.year, end_month, end_day, 23, 59, 59)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= Helpers.pacific_now(),
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "yearly":
            start_dt = datetime(h_p_t.year, 1, 1)
            end_dt = datetime(h_p_t.year, 12, 31, 23, 59, 59)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= Helpers.pacific_now(),
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "yesterday":
            start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day) + timedelta(days=-1)
            end_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day) + timedelta(seconds=-1)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "last_week":
            start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
            while not start_dt.isoweekday() == 7:
                start_dt = start_dt + timedelta(days=-1)

            start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
            end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
            end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

            start_dt = start_dt + timedelta(days=-7)
            end_dt = end_dt + timedelta(days=-7)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "last_month":
            start_dt = datetime(h_p_t.year, h_p_t.month, 1)
            start_dt = start_dt + timedelta(days=-1)
            while not start_dt.day == 1:
                start_dt = start_dt + timedelta(days=-1)


            end_dt = datetime(start_dt.year, start_dt.month, start_dt.day, 23, 59, 59)
            curr_month = end_dt.month
            while end_dt.month == curr_month:
                end_dt = end_dt + timedelta(days=1)
            end_dt = end_dt + timedelta(days=-1)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "last_quarter":
            months_start_map = {"1": 10, "2": 10, "3": 10, "4": 1, "5": 1, "6": 1, "7": 4, "8": 4, "9": 4, "10": 7, "11": 7, "12": 7}
            months_end_map = {"1": 12, "2": 12, "3": 12, "4": 3, "5": 3, "6": 3, "7": 6, "8": 6, "9": 6, "10": 9, "11": 9, "12": 9}
            days_end_map = {"3": 31, "6": 30, "9": 30, "12": 31}

            start_dt = datetime(h_p_t.year, months_start_map[str(h_p_t.month)], 1)
            end_month = months_end_map[str(h_p_t.month)]
            end_day = days_end_map[str(end_month)]
            end_dt = datetime(h_p_t.year, end_month, end_day, 23, 59, 59)

            if h_p_t.month < 4:
                start_dt = datetime(start_dt.year - 1, start_dt.month, start_dt.day)
                end_dt = datetime(end_dt.year - 1, end_dt.month, end_dt.day, end_dt.hour, end_dt.minute, end_dt.second)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "last_year":
            start_dt = datetime(h_p_t.year - 1, 1, 1)
            end_dt = datetime(h_p_t.year - 1, 12, 31, 23, 59, 59)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        elif self.request.get("time_metric") == "all_time":
            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    office_cond
                )
            )
            lb_stats2 = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key == "appointment_cancelled",
                    office_cond
                )
            )

        elif self.request.get("time_metric") == "custom":
            start_vals = self.request.get("start").split("-")
            end_vals = self.request.get("end").split("-")

            start_dt = datetime(int(start_vals[0]), int(start_vals[1]), int(start_vals[2]), 0, 0, 0)
            end_dt = datetime(int(end_vals[0]), int(end_vals[1]), int(end_vals[2]), 23, 59, 59)

            lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key.IN(metric_keys),
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt,
                    office_cond
                )
            )

            if self.request.get("achievement_metric") == "leads_acquired":
                lb_stats2 = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "appointment_cancelled",
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        office_cond
                    )
                )

        #ak_only_reps = self.request.get("achievement_metric") == "appointments_kept_reps"
        #ak_only_solar_pros = self.request.get("achievement_metric") == "appointments_kept_solar_pros"
        #solar_pro_rep_ids = []
        #rep_rep_ids = []
        rep_id_clockins_list = {}
        if self.request.get("achievement_metric") == "app_stat_clockins":
            users = FieldApplicationUser.query()
            for user in users:
                rep_id_clockins_list[user.rep_id] = []

        rep_id_timestamps = {}
        rep_id_app_identifiers = {}
        office_identifier_timestamps = {}
        office_identifier_app_identifiers = {}
        for lb_stat in lb_stats:            
            cont = True

            #HIDE ROB REIMER
            #if lb_stat.rep_id in ["REIM1111", "REIM0822"]:
            #    cont = False            

            if ("appointments_kept" in metric_keys) and (ak_only_reps) and (not lb_stat.rep_id in rep_rep_ids):
                cont = False
            if ("appointments_kept" in metric_keys) and (ak_only_solar_pros) and (not lb_stat.rep_id in solar_pro_rep_ids):
                cont = False

            if cont:
                if not lb_stat.rep_id in ret_json["data"].keys():
                    ret_json["data"][lb_stat.rep_id] = 0
                if not lb_stat.office_identifier in ret_json["office_tallies"].keys():
                    ret_json["office_tallies"][lb_stat.office_identifier] = 0
                if not lb_stat.rep_id in ret_json["rep_id_offices"].keys():
                    ret_json["rep_id_offices"][lb_stat.rep_id] = []
                if not lb_stat.office_identifier in ret_json["rep_id_offices"][lb_stat.rep_id]:
                    ret_json["rep_id_offices"][lb_stat.rep_id].append(lb_stat.office_identifier)

                if not self.request.get("achievement_metric") == "app_stat_clockins":
                    ret_json["data"][lb_stat.rep_id] += 1
                    ret_json["office_tallies"][lb_stat.office_identifier] += 1

                    if not lb_stat.rep_id in rep_id_timestamps.keys():
                        rep_id_timestamps[lb_stat.rep_id] = []
                    rep_id_timestamps[lb_stat.rep_id].append(str(lb_stat.dt).split(".")[0])

                    if not lb_stat.rep_id in rep_id_app_identifiers.keys():
                        rep_id_app_identifiers[lb_stat.rep_id] = []
                    rep_id_app_identifiers[lb_stat.rep_id].append(lb_stat.field_app_identifier)    
                    if not lb_stat.office_identifier in office_identifier_timestamps.keys():
                        office_identifier_timestamps[lb_stat.office_identifier] = []
                    office_identifier_timestamps[lb_stat.office_identifier].append(str(lb_stat.dt).split(".")[0])

                    if not lb_stat.office_identifier in office_identifier_app_identifiers.keys():
                        office_identifier_app_identifiers[lb_stat.office_identifier] = []
                    office_identifier_app_identifiers[lb_stat.office_identifier].append(lb_stat.field_app_identifier)

                else:
                    dt_str = str(lb_stat.dt.date())
                    if not dt_str in rep_id_clockins_list[lb_stat.rep_id]:
                        ret_json["data"][lb_stat.rep_id] += 1
                        ret_json["office_tallies"][lb_stat.office_identifier] += 1
                        rep_id_clockins_list[lb_stat.rep_id].append(dt_str)

        for lb_stat2 in lb_stats2:
            if not (lb_stat.rep_id in ["REIM1111", "REIM0822"]):                
                if lb_stat2.rep_id in ret_json["data"].keys():
                    #ret_json["data"][lb_stat2.rep_id] -= 1
                    ret_json["data"][lb_stat2.rep_id] -= 0
                if lb_stat2.office_identifier in ret_json["office_tallies"].keys():
                    #ret_json["office_tallies"][lb_stat2.office_identifier] -= 1
                    ret_json["office_tallies"][lb_stat2.office_identifier] -= 0

        ret_json["start_dt"] = str(start_dt.date())
        ret_json["end_dt"] = str(end_dt.date())
        ret_json["rep_id_timestamps"] = rep_id_timestamps
        ret_json["office_identifier_timestamps"] = office_identifier_timestamps
        ret_json["rep_id_app_identifiers"] = rep_id_app_identifiers
        ret_json["office_identifier_app_identifiers"] = office_identifier_app_identifiers
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "kwikie9":
        floor = 1450051245200
        ceiling = 3155760000000
        cnt = 0
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == 'AVIL1022')
        for app_entry in app_entries:
            if app_entry.insert_time >= floor and app_entry.insert_time <= ceiling:
                cnt += 1

        self.response.out.write(str(cnt))

    elif self.request.get("fn") == "survey_schedule_admin":
        ret_json = Helpers.get_admin_booking_items(self.request.get("email_rep_id"), self.request.get("password"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_rep_notification_setting":
        f = GCSLockedFile("/ApplicationSettings/UserSettings/Notifications/" + self.request.get("identifier") + ".json")
        content = f.read()
        if not content is None:
            settings = json.loads(content)
            settings[self.request.get("notification_key")][self.request.get("medium")] = (int(self.request.get("value")) == 1)

            f.write(json.dumps(settings), "text/plain", "public-read")

        self.response.out.write("kk")

    elif self.request.get("fn") == "get_d_values":
        question = SurveyQuestion.first(SurveyQuestion.identifier == "f5cd42d98e50fb355013dbc6bc1b194f6aa18fa03c0ec29bb9f600eec7da3a3f09416990a92505243880a88dab341cdbb2cef4151510931b0459893fa93f6b70")
        self.response.content_type = "text/plain"
        self.response.out.write("\n".join(question.dependent_value.split("|||||")))

    elif self.request.get("fn") == "test_yesterday_timestamps":
        epoch = datetime(1970, 1, 1)
        dt_floor = Helpers.pacific_now()
        dt_ceiling = Helpers.pacific_now()

        dt_floor = dt_floor + timedelta(days=-1)
        dt_ceiling = dt_ceiling + timedelta(days=-1)

        dt_floor = datetime(dt_floor.year, dt_floor.month, dt_floor.day, 0, 0, 0)
        dt_ceiling = datetime(dt_ceiling.year, dt_ceiling.month, dt_ceiling.day, 11, 59, 59)

        app_entry_floor = int((dt_floor - epoch).total_seconds() * 1000)
        if app_entry_floor < 0:
            app_entry_floor = 0

        app_entry_ceiling = int((dt_ceiling - epoch).total_seconds() * 1000)

        logging.info(app_entry_floor)
        logging.info(app_entry_ceiling)

        logging.info(datetime.fromtimestamp(app_entry_floor / 1000))
        logging.info(datetime.fromtimestamp(app_entry_ceiling / 1000))

    elif self.request.get("fn") == "gv_test":
        from twilio import twiml
        from twilio.rest import TwilioRestClient

        account_sid = "AC62604e9a588ac09c2da2e019573ea9ed"
        auth_token = "b920f0c1393cadb2fa7b0b51b540a102"
        client = TwilioRestClient(account_sid, auth_token)
        # replace "to" and "from_" with real numbers
        rv = client.messages.create(to="+18312750754",
                                    from_="+19512526641",
                                    body="Hello Monkey!")
        self.response.write(str(rv))

    elif self.request.get("fn") == "timestamp_test":
        dt = datetime(1970, 1, 1)
        dt = dt + timedelta(seconds=(1450685904592 / 1000))
        #dt = datetime.fromtimestamp(1450685904592 / 1000)
        self.response.out.write(str(dt))

        self.response.out.write("<br />")
        self.response.out.write(str(Helpers.epoch_millis_to_pacific_dt(1450685904592)))

    elif self.request.get("fn") == "fix_notification_settings":
        users = FieldApplicationUser.query()
        for user in users:
            settings_option = {}
            settings_option["new_customer_note"] = {}
            settings_option["new_customer_note"]["sms"] = True
            settings_option["new_customer_note"]["email"] = True
            f1 = GCSLockedFile("/ApplicationSettings/UserSettings/Notifications/" + user.identifier + ".json")
            f1.write(json.dumps(settings_option), "text/plain", "public-read")

    elif self.request.get("fn") == "init_customer_notes":
        #current step: fund set
        done = True
        step = int(self.request.get("step"))
        entries = FieldApplicationEntry.query().order(FieldApplicationEntry.insert_time).fetch(20, offset=step)
        for entry in entries:
            done = False

            booking = SurveyBooking.first(SurveyBooking.identifier == entry.booking_identifier)
            if not booking is None and booking.completion_state > 0:
                user = FieldApplicationUser.first(FieldApplicationUser.rep_email == "rnirnber@gmail.com")
                if not user is None:
                    try:
                        pacific_dt = datetime(booking.booking_year, booking.booking_month, booking.booking_day, 17, 30)
                        utc_dt = pacific_dt + timedelta(hours=8)
                        CustomerTranscriber.transcribe(entry, user, "survey_status_update", 0, utc_dt, pacific_dt)
                    except:
                        logging.error("Couldn't record customer note on init_customer_notes")
                else:
                    logging.info("user was none")
        if done:
            self.response.out.write("kk all done")
        else:
            self.redirect("/data?fn=init_customer_notes&step=" + str(step + 20))

    elif self.request.get("fn") == "get_override_data":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["managers"] = []
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            user = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            ret_json["rep_name"] = "Unknown Rep"
            if not user is None:
                ret_json["rep_name"] = user.first_name.strip().title() + " " + user.last_name.strip().title()
                office = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                if not office is None:
                    managers = FieldApplicationUser.query(
                        ndb.AND
                        (
                            FieldApplicationUser.main_office == app_entry.office_identifier,
                            FieldApplicationUser.user_type.IN(["rg_mgr", "sales_dist_mgr", "co_mgr", "asst_mgr", "co_asst_mgr", "energy_expert", "sales_manager"])
                        )
                    )
                    for manager in managers:
                        manager_item = {}
                        manager_item["rep_id"] = manager.rep_id
                        manager_item["identifier"] = manager.identifier
                        manager_item["name"] = manager.first_name.strip().title() + " " + manager.last_name.strip().title()
                        manager_item["user_type"] = manager.user_type

                        ret_json["managers"].append(manager_item)

                    key = user.identifier + "_" + office.identifier + "_payout_json"
                    kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == key)
                    ret_json["has_previous_data"] = (not kv_item is None)
                    if ret_json["has_previous_data"]:
                        ret_json["previous_data"] = json.loads(kv_item.val)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_unbooked_surveys":
        self.response.content_type = "application/json"
        ret_json = {"count": len(
            SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.booking_year == 1970,
                    SurveyBooking.associated_rep_id == self.session["user_rep_id"]
                )
            ).to_list()
        )}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_surveys_for_admin":
        self.response.content_type = "application/json"

        criteria = self.request.get("criteria")
        ret_json = []
        surveys = []
        filter_fn = lambda dt: True

        if criteria == "unbooked":
            surveys = SurveyBooking.query(SurveyBooking.booking_year == 1970)
        else:

            thirty_days_ago = Helpers.pacific_now() + timedelta(days=-30)
            epoch = datetime(1970, 1, 1)
            time_floor = int((thirty_days_ago - epoch).total_seconds() * 1000)

            app_entries = FieldApplicationEntry.query(
                ndb.AND
                (
                    FieldApplicationEntry.insert_time >= time_floor,
                    FieldApplicationEntry.archived == False
                )
            )

            booking_identifiers_to_query = ["-1"]
            for app_entry in app_entries:
                booking_identifiers_to_query.append(app_entry.booking_identifier)

            tomorrow = Helpers.pacific_now() + timedelta(days=1)
            tomorrow = tomorrow.date()
            filter_fn = lambda dt: dt >= tomorrow

            surveys = SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.completion_state == 0,
                    SurveyBooking.identifier.IN(booking_identifiers_to_query)
                )
            )

        identifier_idx_map = {}
        app_entries_to_query = ["-1"]
        for survey in surveys:
            if filter_fn(date(survey.booking_year, survey.booking_month, survey.booking_day)):
                survey_item = {}
                atts = ["identifier", "name", "city", "state", "booking_year", "booking_month", "booking_day", "address", "office_identifier", "field_app_lead_id", "slot_number"]
                for att in atts:
                    survey_item[att] = getattr(survey, att)

                ret_json.append(survey_item)
                identifier_idx_map[survey.identifier] = len(ret_json) - 1
                app_entries_to_query.append(survey.field_app_identifier)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_entries_to_query))
        for app_entry in app_entries:
            booking_id = app_entry.booking_identifier
            ret_json[identifier_idx_map[booking_id]]["insert_time"] = app_entry.insert_time
            ret_json[identifier_idx_map[booking_id]]["sp2_time"] = str(app_entry.sp_two_time)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "adjust_survey_appointment":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False

        date_items = self.request.get("date").split("-")
        m = int(date_items[0])
        d = int(date_items[1])
        y = int(date_items[2])

        survey = SurveyBooking.first(SurveyBooking.identifier == self.request.get("identifier"))
        if not survey is None:
            survey.booking_day = d
            survey.booking_month = m
            survey.booking_year = y
            survey.slot_number = int(self.request.get("slot"))

            bookings = SurveyBooking.query(
                ndb.AND
                (
                    SurveyBooking.booking_day == d,
                    SurveyBooking.booking_month == m,
                    SurveyBooking.booking_year == y,
                    SurveyBooking.slot_number == survey.slot_number,
                    SurveyBooking.office_identifier == self.request.get("office_identifier"),
                    ndb.OR
                    (
                        SurveyBooking.completion_state == 0,
                        SurveyBooking.completion_state == 1,
                        SurveyBooking.completion_state == 2,
                        SurveyBooking.completion_state == 3
                    )
                )
            )
            archiv_cnt = 0
            booking_cnt = 0
            for booking in bookings:
                archiv_cnt += (int(booking.archived))
                booking_cnt += 1

            ret_json["success"] = (archiv_cnt == booking_cnt)

            if ret_json["success"]:
                survey.put()
            else:
                ret_json["already_booked"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "save_notes_for_sales_rep_from_proposal":
        self.response.content_type = "application/json"
        ret = {"success": True}

        existing_note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "notes_to_sales_rep"
            )
        )
        if not existing_note is None:
            existing_note.content = json.dumps({"txt": [self.request.get("txt")]})
            existing_note.put()
            self.response.out.write(json.dumps(ret))
            return
        

        new_note = CustomerNote(
            identifier=Helpers.guid(),
            field_app_identifier=self.request.get("identifier"),
            inserted_pacific=Helpers.pacific_now(),
            inserted_utc=datetime.now(),
            author=self.request.get("user_identifier"),
            perms="public",
            content=json.dumps({"txt": [self.request.get("txt")]}),
            blob_count=0,
            note_key="notes_to_sales_rep",
            read=True
        )
        new_note.put()
        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "pull_proposal_info_for_customer":
        self.response.content_type = "application/json"
        ret_json = {}

        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
        credit_check = CreditCheck.first(CreditCheck.field_app_identifier == self.request.get("identifier"))

        req_action = RepRequiredAction.first(
            ndb.AND
            (
                RepRequiredAction.field_app_identifier == self.request.get("identifier"),
                RepRequiredAction.action_key=="proposal_incomplete"
            )
        )

        funds = Helpers.list_funds()

        if proposal is None:
            if not app_entry is None:
                fields = {}
                default_svcs = [{"value": "20_year_cleaning_plan", "qty": 1}, {"value": "20_year_maintenance_plan_(requires_20_yr_inverter)", "qty": 1}]
                fields["additional_svcs"] = default_svcs
                fields["additional_amount"] = "0.00"
                proposal = CustomerProposalInfo(
                    identifier=Helpers.guid(),
                    field_app_identifier=self.request.get("identifier"),
                    version=1,
                    info=json.dumps(fields)
                )
                proposal.put()

        credit_score = "Unknown"
        if not credit_check is None:
            if credit_check.score > 0:
                credit_score = str(credit_check.score)
                
        ret_json["proposal_info"] = {"identifier": proposal.identifier, "field_app_identifier": proposal.field_app_identifier, "version": proposal.version, "info": json.loads(proposal.info)}
        if not "azimuth" in ret_json["proposal_info"]["info"].keys():
            ret_json["proposal_info"]["info"]["azimuth"] = ""
        if not "estimated_slope_of_array" in ret_json["proposal_info"]["info"].keys():
            ret_json["proposal_info"]["info"]["estimated_slope_of_array"] = ""
        ret_json["requires_proposal"] = False
        for fund in funds:
            if fund["value"] == booking.fund:
                ret_json["requires_proposal"] = fund["requires_proposal"]

        admin_qualifier = str(self.request.get("admin_qualifier") == "1")
        if admin_qualifier and (not app_entry is None):
            ret_json["credit_score"] = credit_score
            ret_json["customer_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            ret_json["customer_address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            ret_json["sp_two_time"] = str(app_entry.sp_two_time)
            ret_json["total_kwhs"] = app_entry.total_kwhs
            ret_json["total_dollars"] = app_entry.total_dollars
            ret_json["usage_months"] = app_entry.usage_months
            ret_json["customer_phone"] = app_entry.customer_phone
            ret_json["customer_phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret_json["customer_email"] = app_entry.customer_email
            ret_json["spouse_name"] = "n/a"
            ret_json["lead_generator"] = app_entry.lead_generator
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            spouse_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "second_homeowner_" + self.request.get("identifier"))
            if not spouse_kv is None:
                spouse_info = json.loads(spouse_kv.val)
                ret_json["spouse_name"] = spouse_info["first_name"] + " " + spouse_info["last_name"]
            if not rep is None:
                ret_json["rep_name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                ret_json["rep_phone_formatted"] = Helpers.format_phone_number(app_entry.rep_phone)
                ret_json["rep_phone"] = app_entry.rep_phone
                ret_json["opt_rep_notes"] = app_entry.opt_rep_notes
                if not req_action is None:
                    info2 = json.loads(req_action.message)
                    if "required_action" in info2.keys():                        
                        ret_json["opt_rep_notes"] += ("\n" + info2["required_action"])
                    if "rep_response" in info2.keys():
                        ret_json["opt_rep_notes"] += ("\n" + info2["rep_response"])
                ret_json["total_kwhs"] = app_entry.total_kwhs
                ret_json["usage_months"] = app_entry.usage_months

            ret_json["approval_amount"] = "-1"
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "approval_amount_" + self.request.get("identifier"))
            if not kv_item is None:
                ret_json["approval_amount"] = kv_item.val

        if "lead_generator" in ret_json.keys():
            if not ret_json["lead_generator"] == "-1":
                solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == ret_json["lead_generator"])
                if not solar_pro is None:
                    ret_json["lead_generator"] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

        ret_json["ab_timestamp"] = "1970-01-01"
        ab_stat = LeaderBoardStat.first(
            ndb.AND(
                LeaderBoardStat.field_app_identifier == self.request.get("identifier"),
                LeaderBoardStat.metric_key == "leads_acquired"
            )
        )
        if not ab_stat is None:
            ret_json["ab_timestamp"] = str(ab_stat.dt).split(".")[0]

        note_to_rep = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "notes_to_sales_rep"
            )
        )
        ret_json["notes_to_sales_rep"] = None
        if not note_to_rep == None:
            ret_json["notes_to_sales_rep"] = json.loads(note_to_rep.content)["txt"]

        ret_json["bill_photo"] = None
        if Helpers.gcs_file_exists("/Images/TitanPhotos/" + self.request.get("identifier") + "/bill.jpg"):
            ret_json["bill_photo"] = True

        ret_json["panel_photos"] = False
        cnt = 1
        while cnt < 2:
            if Helpers.gcs_file_exists("/Images/TitanPhotos/" + self.request.get("identifier") + "/panel_" + str(cnt) + ".jpg"):
                ret_json["panel_photos"] = True
            cnt = cnt + 1

        ret_json["roof_photos"] = []
        cnt = 1
        while cnt < 4:
            if Helpers.gcs_file_exists("/Images/TitanPhotos/" + self.request.get("identifier") + "/roof_" + str(cnt) + ".jpg"):
                ret_json["roof_photos"].append(1)
            cnt = cnt + 1

    

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_sp_details":
        self.response.content_type = "application/json"
        ret_json = {"name": "Self-Gen"}
        ret_json["phone"] = "Self Gen"
        ret_json["phone_formatted"] = "Self Gen"

        if not self.request.get("identifier") == "-1":
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                if not app_entry.lead_generator == "-1":
                    lead_generator = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not lead_generator is None:
                        ret_json["name"] = lead_generator.first_name.strip().title() + " " + lead_generator.last_name.strip().title()
                        ret_json["phone"] = lead_generator.rep_phone
                        ret_json["phone_formatted"] = Helpers.format_phone_number(ret_json["phone"])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "save_proposal_info":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("field_app_identifier"))
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("field_app_identifier"))
        fields = json.loads(self.request.get("fields"))
        fields["original_year_one_production"] = str(fields["year_one_production"])
        admin_qualifier = (self.request.get("admin_qualifier") == "1")
        rep_qualifier = (self.request.get("rep_qualifier") == "1")

        if str(self.request.get("spruce_image_hack")) == "1" and str(self.request.get("has_cad_photo")) == "0":
            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                    max_delay=5.0,
                                                    backoff_factor=2,
                                                    max_retry_period=15,
                                                    urlfetch_timeout=30)
            filename = bucket + "/Images/PPA_CAD_photo.jpg"
            fields["cad_photo"] = {"mime_type": "image/jpg", "extension": "jpg"}
            Helpers.gcs_copy("/Images/PPA_CAD_photo.jpg", '/ProposalBlobs/' + self.request.get("field_app_identifier") + "_cad_photo.jpg", "image/jpeg", "public-read")

        if str(self.request.get("has_cad_photo")) == "1":
            pic_name = self.request.params["cad_photo"].filename.lower()
            name_elements = pic_name.split(".")

            pic_type = name_elements[len(name_elements) - 1]
            pic_ext = ""
            pic_mime = ""
            if pic_type.lower() == "png":
                pic_ext = "png"
                pic_mime = "image/png"
            else:
                pic_ext = "jpg"
                pic_mime = "image/jpg"

            file_content = self.request.POST.multi['cad_photo'].file.read()
                

            bucket_name = os.environ.get('BUCKET_NAME',
                                        app_identity.get_default_gcs_bucket_name())

            bucket = '/' + bucket_name
            filename = bucket + '/ProposalBlobs/' + self.request.get("field_app_identifier") + "_cad_photo." + pic_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=pic_mime,
                                options={'x-goog-meta-foo': 'foo',
                                        'x-goog-meta-bar': 'bar',
                                        'x-goog-acl': 'public-read'
                                },
                                retry_params=write_retry_params)

            gcs_file.write(file_content)
            gcs_file.close()

            fields["cad_photo"] = {"mime_type": pic_mime, "extension": pic_ext}

        if str(self.request.get("has_fund_proposal")) == "1":
            pic_ext = "pdf"
            pic_mime = "application/pdf"

            file_content = self.request.POST.multi['fund_proposal'].file.read()
                

            bucket_name = os.environ.get('BUCKET_NAME',
                                        app_identity.get_default_gcs_bucket_name())

            bucket = '/' + bucket_name
            filename = bucket + '/ProposalBlobs/' + self.request.get("field_app_identifier") + "_fund_proposal." + pic_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=pic_mime,
                                options={'x-goog-meta-foo': 'foo',
                                        'x-goog-meta-bar': 'bar',
                                        'x-goog-acl': 'public-read'
                                },
                                retry_params=write_retry_params)

            gcs_file.write(file_content)
            gcs_file.close()

            fields["fund_proposal"] = {"mime_type": pic_mime, "extension": pic_ext}

            
        if str(self.request.get("has_paperwork_pdf")) == "1":
            pic_name = self.request.params["paperwork_pdf"].filename.lower()
            name_elements = pic_name.split(".")

            pic_type = name_elements[len(name_elements) - 1]
            pic_ext = ""
            pic_mime = ""
            if pic_type.lower() == "png":
                pic_ext = "png"
                pic_mime = "image/png"
            else:
                pic_ext = "jpg"
                pic_mime = "image/jpg"

            pic_ext = "pdf"
            pic_mime = "application/pdf"

            file_content = self.request.POST.multi['paperwork_pdf'].file.read()

            bucket_name = os.environ.get('BUCKET_NAME',
                                        app_identity.get_default_gcs_bucket_name())

            bucket = '/' + bucket_name
            filename = bucket + '/ProposalBlobs/' + self.request.get("field_app_identifier") + "_paperwork_pdf." + pic_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=pic_mime,
                                options={'x-goog-meta-foo': 'foo',
                                        'x-goog-meta-bar': 'bar',
                                        'x-goog-acl': 'public-read'
                                },
                                retry_params=write_retry_params)

            gcs_file.write(file_content)
            gcs_file.close()

            fields["paperwork_pdf"] = {"mime_type": pic_mime, "extension": pic_ext}



        if rep_qualifier:
            if not app_entry is None:
                app_entry.highest_amount = float(fields["highest_amount"])
                app_entry.usage_months = int(fields["usage_months"])
                app_entry.total_dollars = float(fields["total_dollars"])
                app_entry.total_kwhs = float(fields["total_kwhs"])
                app_entry.put()

                del fields["highest_amount"]
                del fields["usage_months"]
                del fields["total_dollars"]
                del fields["total_kwhs"]

        if not proposal is None:
            old_info = json.loads(proposal.info)
            if "additional_amount" in old_info.keys():
                fields["additional_amount"] = old_info["additional_amount"]

            if "additional_svcs" in old_info.keys():
                fields["additional_svcs"] = old_info["additional_svcs"]

            tkwhs = app_entry.total_kwhs
            y1prod = ""
            nums = ["0", "1", "2","3","4", "5", "6", "7", "8","9", "."]
            for ch in fields["year_one_production"]:
                if ch in nums:
                    y1prod += ch

            y1prod = float(y1prod)
            percentage = y1prod / tkwhs
            percentage *= float(100)
            if percentage > float(100):
                percentage = float(100)
            percentage = int(percentage)
            fields["offset"] = str(percentage) + "%"
            if str(self.request.get("has_cad_photo")) == "0":
                fields["cad_photo"] = old_info["cad_photo"]
            if str(self.request.get("has_fund_proposal")) == "0":
                if "fund_proposal" in old_info.keys():
                    fields["fund_proposal"] = old_info["paperwork_pdf"]

                
            proposal.info = json.dumps(fields)
            proposal.version = int(self.request.get("version"))
            proposal.put()

            usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not usr is None:
                CustomerTranscriber.transcribe(app_entry, usr, "proposal_updated")

            if not app_entry is None:
                app_entry.proposal_state = 2
                app_entry.put()

        elif proposal is None and admin_qualifier:
            tkwhs = app_entry.total_kwhs
            y1prod = ""
            nums = ["0", "1", "2","3","4", "5", "6", "7", "8","9", "."]
            for ch in fields["year_one_production"]:
                if ch in nums:
                    y1prod += ch

            y1prod = float(y1prod)
            percentage = y1prod / tkwhs
            percentage *= float(100)
            if percentage > float(100):
                percentage = float(100)
            percentage = int(percentage)
            fields["offset"] = str(percentage) + "%"

            default_svcs = [{"value": "20_year_cleaning_plan", "qty": 1}, {"value": "20_year_maintenance_plan_(requires_20_yr_inverter)", "qty": 1}]
            fields["additional_svcs"] = default_svcs

            proposal = CustomerProposalInfo(
                identifier=Helpers.guid(),
                field_app_identifier=self.request.get("field_app_identifier"),
                version=1,
                info=json.dumps(fields)
            )
            proposal.put()

        else:
            if rep_qualifier:

                if not "additional_amount" in fields.keys():
                    fields["additional_amount"] = "0.00"

                proposal = CustomerProposalInfo(
                    identifier=Helpers.guid(),
                    field_app_identifier=self.request.get("field_app_identifier"),
                    version=1,
                    info=json.dumps(fields)
                )
                proposal.put()

                usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "proposal_updated")

        self.response.out.write(" ")

    elif self.request.get("fn") == "sp2_booking_doublecheck":
        self.response.content_type = "application/json"
        ret_json = {}

        date_vals = self.request.get("sp2_date").split("-")
        hours = int(self.request.get("sp2_hours"))
        mins = int(self.request.get("sp2_mins"))
        pm = (self.request.get("pm") == "1")
        if pm and (not hours == 12):
            hours += 12

        dt = datetime(int(date_vals[2]), int(date_vals[0]), int(date_vals[1]), hours, mins, 0)
        app_entry = FieldApplicationEntry.first(
            ndb.AND
            (
                FieldApplicationEntry.sp_two_time == dt,
                FieldApplicationEntry.rep_id == self.session["user_rep_id"]
            )
        )
        ret_json["double_booked"] = ((not app_entry is None) and (not app_entry.archived) and (not app_entry.save_me))

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_income_verification_for_customer":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "income_verification_required_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="income_verification_required_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365)
            )
        kv.val = self.request.get("value")
        kv.put()

    elif self.request.get("fn") == "out_of_bounds_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/out_of_bounds_email", params={})

    elif self.request.get("fn") == "tax_info_for_customer":
        self.response.content_type = "application/json"
        ret_json = {"filing_status": None, "federal_percentage": None, "state_percentage": None}
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "filing_status_" + self.request.get("identifier"))
        if not kv is None:
            ret_json["filing_status"] = kv.val
        kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "federal_tax_percentage_" + self.request.get("identifier"))
        if not kv2 is None:
            ret_json["federal_percentage"] = kv2.val
        kv3 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "state_tax_percentage_" + self.request.get("identifier"))
        if not kv2 is None:
            ret_json["state_percentage"] = kv3.val

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_titan_status":
        ret = {}
        if Helpers.gcs_file_exists("/TitanStatus/" + self.request.get("identifier") + ".json"):
            f = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
            ret = json.loads(f.read())
            ret["phone"] = ""
            ret["address"] = ""
            ret["email"] = ""
            ret["foo"] = "bar"
            f.unlock()
        else:
            ret["welcome_call_date"] = "1970-01-01"
            ret["survey_needed"] = False
            ret["survey_date"] = "1970-01-01"
            ret["survey_time"] = "00:00:00"
            ret["survey_completed"] = False
            ret["roof_work_needed"] = False
            ret["roof_work_cost"] = 0
            ret["mpu_needed"] = False
            ret["install_date"] = "1970-01-01"
            ret["notes"] = ""
            ret["permited_submitted"] = False
            ret["cancelled"] = False
            ret["phone"] = ""
            ret["address"] = ""
            ret["email"] = ""
            ret["foo"] = "bar"
            ret["pto"] = False


        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret["address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            ret["email"] = app_entry.customer_email


        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "titan_wc_update_string":
        data = {}
        data["welcome_call_date"] = "1970-01-01"
        data["survey_needed"] = False
        data["survey_date"] = "1970-01-01"
        data["survey_time"] = "00:00:00"
        data["survey_completed"] = False
        data["roof_work_needed"] = False
        data["roof_work_cost"] = 0
        data["mpu_needed"] = False
        data["install_date"] = "1970-01-01"
        data["notes"] = ""
        data["cancelled"] = False
        data["permited_submitted"] = False


        if Helpers.gcs_file_exists("/TitanStatus/" + self.request.get("identifier") + ".json"):
            f = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
            data = json.loads(f.read())
            f.unlock()

        data[self.request.get("key")] = str(self.request.get("value"))

        f2 = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
        f2.write(json.dumps(data), "application/json", "public-read")
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                if self.request.get("key") == "notes":
                    Helpers.send_sms(rep.rep_phone, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s status has been updated:\n\n" + self.request.get("value"))

    elif self.request.get("fn") == "titan_wc_update_bool":
        data = {}
        data["welcome_call_date"] = "1970-01-01"
        data["survey_needed"] = False
        data["survey_date"] = "1970-01-01"
        data["survey_time"] = "00:00:00"
        data["survey_completed"] = False
        data["roof_work_needed"] = False
        data["roof_work_cost"] = 0
        data["mpu_needed"] = False
        data["install_date"] = "1970-01-01"
        data["notes"] = ""
        data["permited_submitted"] = False
        data["cancelled"] = False

        if Helpers.gcs_file_exists("/TitanStatus/" + self.request.get("identifier") + ".json"):
            f = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
            data = json.loads(f.read())
            f.unlock()

        data[self.request.get("key")] = (self.request.get("value") == "1")

        f2 = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
        f2.write(json.dumps(data), "application/json", "public-read")
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                x = 5
                #Helpers.send_sms(rep.rep_phone, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s status has been updated. Please login to the rep portal and use the customer progress tool to inspect changes")

    elif self.request.get("fn") == "titan_wc_update_float":
        data = {}
        data["welcome_call_date"] = "1970-01-01"
        data["survey_needed"] = False
        data["survey_date"] = "1970-01-01"
        data["survey_time"] = "00:00:00"
        data["survey_completed"] = False
        data["roof_work_needed"] = False
        data["roof_work_cost"] = 0
        data["mpu_needed"] = False
        data["install_date"] = "1970-01-01"
        data["notes"] = ""
        data["permited_submitted"] = False
        data["cancelled"] = False

        if Helpers.gcs_file_exists("/TitanStatus/" + self.request.get("identifier") + ".json"):
            f = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
            data = json.loads(f.read())
            f.unlock()

        data[self.request.get("key")] = float(self.request.get("value"))

        f2 = GCSLockedFile("/TitanStatus/" + self.request.get("identifier") + ".json")
        f2.write(json.dumps(data), "application/json", "public-read")
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                x = 5
                #Helpers.send_sms(rep.rep_phone, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s status has been updated. Please login to the rep portal and use the customer progress tool to inspect changes")

    elif self.request.get("fn") == "load_pending_titan":
        ninety_days_ago = Helpers.pacific_now() + timedelta(days=-90)
        last_time_to_use = datetime(2021, 7, 26)
        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.dt >= last_time_to_use,
                LeaderBoardStat.metric_key == "packets_submitted"
            )
        )
        app_ids_to_query = ["-1"]
        ret_json = {}
        ret_json["customers"] = []        
        rep_ids_to_query = ["-1"]

        app_id_idx_dict = {}        
        for stat in stats:
            if len(str(self.request.get("rep_id"))) == 8:
                if stat.rep_id == self.request.get("rep_id"):
                    app_ids_to_query.append(stat.field_app_identifier)
                    app_id_idx_dict[stat.field_app_identifier] = len(ret_json["customers"])
                    obj = {"field_app_identifier": stat.field_app_identifier}
                    obj["rep"] = stat.rep_id
                    if not obj["rep"] in rep_ids_to_query:
                        rep_ids_to_query.append(obj["rep"])
                    
                    obj["cancelled"] = False
                    obj["pto"] = False
                    if Helpers.gcs_file_exists("/TitanStatus/" + stat.field_app_identifier + ".json"):
                        temp_f = GCSLockedFile("/TitanStatus/" + stat.field_app_identifier + ".json")
                        content = temp_f.read()
                        temp_f.unlock()
                        deserialized = json.loads(content)

                        if "cancelled" in deserialized.keys():
                            obj["cancelled"] = (deserialized["cancelled"] == True)
                        if "pto" in deserialized.keys():
                            obj["pto"] = deserialized["pto"]


                    ret_json["customers"].append(obj)

                    

            else:
                app_ids_to_query.append(stat.field_app_identifier)
                app_id_idx_dict[stat.field_app_identifier] = len(ret_json["customers"])
                obj = {"field_app_identifier": stat.field_app_identifier}
                obj["rep"] = stat.rep_id
                if not obj["rep"] in rep_ids_to_query:
                    rep_ids_to_query.append(obj["rep"])
                ret_json["customers"].append(obj)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            idx = app_id_idx_dict[app_entry.identifier]
            ret_json["customers"][idx]["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        rep_id_name_dict = {}
        for rep in reps:
            rep_id_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        for item in ret_json["customers"]:
            
            item["rep"] = rep_id_name_dict[item["rep"]]

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))        

    elif self.request.get("fn") == "get_training_media":
        media = []
        if str(self.request.get("type")) in ["audio", "video", "doc"]:
            media = TrainingMedia.query(
                ndb.OR(
                    TrainingMedia.type == self.request.get("type"),
                    TrainingMedia.type == "section_" + self.request.get("type")
                )
            )
        elif str(self.request.get("type")) == "manager":
            media = TrainingMedia.query(TrainingMedia.type.IN(["manager_video", "manager_audio", "manager_doc", "section_manager"]))
        else:
            media = TrainingMedia.query()

            
        self.response.content_type = "application/json"
        ret_json = {"media": []}
        for m in media:
            obj = {"identifier": m.identifier, "type": m.type, "name": m.name, "display_index": m.display_index, "extra_info": json.loads(m.extra_info)}
            ret_json["media"].append(obj)

        ret_json["media"] = Helpers.bubble_sort(ret_json["media"], "display_index")
        ret_json["quizzes"] = []
        quizzes = Quiz.query()
        if str(self.request.get("active_quizzes_only")) == "1":
            quizzes = Quiz.query(Quiz.active == True)
        keys_to_query = ["-1"]
        ret_json["scores"] = {}
        for quiz in quizzes:
            obj = {"identifier": quiz.identifier, "name": quiz.name, "active": quiz.active, "display_index": quiz.display_index}
            ret_json["quizzes"].append(obj)
            keys_to_query.append("quiz_score_" + quiz.identifier + "_" + self.session["user_identifier"])
            ret_json["scores"][quiz.identifier] = "-1%"
        ret_json["quizzes"] = Helpers.bubble_sort(ret_json["quizzes"], "display_index")
        
        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_item in kv_items:
            key_vals = kv_item.keyy.split("_")
            ret_json["scores"][key_vals[2]] = kv_item.val
        
        ret_json["power_ups"] = []
        power_ups = PowerUp.query()
        for p in power_ups:
            obj = {}
            obj["identifier"] = p.identifier
            obj["name"] = p.name
            obj["rep_payout_amount"] = str(round(p.rep_payout_amount, 2))
            obj["recruiter_payout_amount"] = str(round(p.recruiter_payout_amount, 2))
            obj["incentives"] = json.loads(p.incentives)
            obj["requirements"] = json.loads(p.requirements)
            obj["display_index"] = p.display_index
            ret_json["power_ups"].append(obj)

        ret_json["power_ups"] = Helpers.bubble_sort(ret_json["power_ups"], "display_index")
        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_name_for_powerup":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.name = self.request.get("name")
            p.put()

    elif self.request.get("fn") == "update_power_up_rep_payout":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.rep_payout_amount = float(self.request.get("amount"))
            p.put()

    elif self.request.get("fn") == "update_power_up_recruiter_payout":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.recruiter_payout_amount = float(self.request.get("amount"))
            p.put()

    elif self.request.get("fn") == "add_incentive_to_power_up":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            incentives = json.loads(p.incentives)
            incentives.append("New Incentive")
            p.incentives = json.dumps(incentives)
            p.put()

    elif self.request.get("fn") == "save_incentives_for_power_up":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.incentives = json.dumps(json.loads(self.request.get("incentives")))
            p.put()

    elif self.request.get("fn") == "add_power_up_requirement":
        new_id = Helpers.guid()
        self.response.content_type = "application/json"
        ret_json = {"identifier": new_id}
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            reqs = json.loads(p.requirements)
            reqs.append({"identifier": new_id, "text": "New Requirement"})
            p.requirements = json.dumps(reqs)
            p.put()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_text_for_power_up_requirement":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            reqs = json.loads(p.requirements)
            for req in reqs:
                if req["identifier"] == self.request.get("requirement_identifier"):
                    req["text"] = self.request.get("text")
            p.requirements = json.dumps(reqs)
            p.put()

    elif self.request.get("fn") == "drop_power_up_requirement":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            reqs = json.loads(p.requirements)
            idx_to_remove = -1
            cnt = 0
            for req in reqs:
                if req["identifier"] == self.request.get("requirement_identifier"):
                    idx_to_remove = cnt
                cnt += 1

            if idx_to_remove >= 0:
                del reqs[idx_to_remove]
            p.requirements = json.dumps(reqs)
            p.put()

    elif self.request.get("fn") == "drop_power_up":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.key.delete()
            
    elif self.request.get("fn") == "update_requirements_for_power_up":
        p = PowerUp.first(PowerUp.identifier == self.request.get("identifier"))
        if not p is None:
            p.requirements = json.dumps(json.loads(self.request.get("requirements")))
            p.put()

    elif self.request.get("fn") == "update_power_up_index_mapping":
        mapping = json.loads(self.request.get("mapping"))
        ids_to_query = ["-1"] + mapping.keys()
        power_ups = PowerUp.query(PowerUp.identifier.IN(ids_to_query))
        power_ups_to_save = []
        for p in power_ups:
            p.display_index = mapping[p.identifier]
            power_ups_to_save.append(p)
        if len(power_ups_to_save) > 0:
            ndb.put_multi(power_ups_to_save)
            
    elif self.request.get("fn") == "create_power_up":
        count = PowerUp.query().count()
        p = PowerUp(
            identifier=Helpers.guid(),
            name="Level X",
            rep_payout_amount=float(0),
            recruiter_payout_amount=float(0),
            incentives="[]",
            requirements="[]",
            display_index=count + 1
        )
        p.put()
        self.response.content_type = "application/json"
        
        ret_json = {"identifier": p.identifier, "name": p.name}
        ret_json["rep_payout_amount"] = str(round(p.rep_payout_amount, 2))
        ret_json["recruiter_payout_amount"] = str(round(p.recruiter_payout_amount, 2))
        ret_json["incentives"] = json.loads(p.incentives)
        ret_json["requirements"] = json.loads(p.requirements)
        ret_json["display_index"] = p.display_index

        self.response.out.write(json.dumps(ret_json))
    
    elif self.request.get("fn") == "proposal_details_for_customer":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["proposal"] = None
        ret_json["name"] = ""
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            ret_json["proposal"] = json.loads(proposal.info)
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "complete_quiz":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "quiz_score_" + self.request.get("identifier") + "_" + self.request.get("user"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="quiz_score_" + self.request.get("identifier") + "_" + self.request.get("user"),
                expiration=datetime(1970, 1, 1)
            )
        kv.val = self.request.get("score")
        kv.put()
        notification = Notification.first(Notification.action_name == "Quiz Completed")
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("user"))
        quiz = Quiz.first(Quiz.identifier == self.request.get("identifier"))
        if (not notification is None) and (not user is None) and (not quiz is None):
            for p in notification.notification_list:
                Helpers.send_email(p.email_address, "Quiz Completed", user.first_name.strip().title() + " " + user.last_name.strip().title() + " has completed the quiz '" + quiz.name + "'\r\n\r\nScore: " + self.request.get("score"))

    elif self.request.get("fn") == "activate_deactivate_quiz":
        quiz = Quiz.first(Quiz.identifier == self.request.get("identifier"))
        if not quiz is None:
            quiz.active = (self.request.get("active") == "1")
            quiz.put()

    elif self.request.get("fn") == "set_name_for_quiz":
        quiz = Quiz.first(Quiz.identifier == self.request.get("identifier"))
        if not quiz is None:
            quiz.name = self.request.get("name")
            quiz.put()

    elif self.request.get("fn") == "adjust_quiz_indexes":
        mapping = json.loads(self.request.get("mapping"))
        items_to_save = []
        identifiers = ["-1"] + mapping.keys()
        quizzes = Quiz.query(Quiz.identifier.IN(identifiers))
        for quiz in quizzes:
            quiz.display_index = mapping[quiz.identifier]
            items_to_save.append(quiz)

        if len(items_to_save) > 0:
            ndb.put_multi(items_to_save)

    elif self.request.get("fn") == "quiz_details":
        ret_json = {}
        self.response.content_type = "application/json"
        quiz = Quiz.first(Quiz.identifier == self.request.get("identifier"))
        if not quiz is None:
            ret_json["quiz"] = {"identifier": quiz.identifier, "name": quiz.name}
        ret_json["questions"] = []
        questions = QuizQuestion.query(QuizQuestion.quiz_identifier == self.request.get("identifier"))
        for q in questions:
            ret_json["questions"].append({"identifier": q.identifier, "name": q.name, "choices": json.loads(q.choices), "correct_index": q.correct_index, "display_index": q.display_index})
        ret_json["questions"] = Helpers.bubble_sort(ret_json["questions"], "display_index")
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_quiz_question":
        self.response.content_type = "application/json"
        ret_json = {}
        choices = [
            {"text": "Item A"},
            {"text": "Item B"},
            {"text": "Item C"},
            {"text": "Item D"}
        ]
        cnt = QuizQuestion.query(QuizQuestion.quiz_identifier == self.request.get("identifier")).count()
        question = QuizQuestion(
            identifier=Helpers.guid(),
            quiz_identifier=self.request.get("identifier"),
            name="Sample Question",
            choices=json.dumps(choices),
            correct_index=2,
            display_index=(cnt + 1)
        )
        question.put()
        ret_json["identifier"] = question.identifier
        ret_json["quiz_identifier"] = question.quiz_identifier
        ret_json["name"] = question.name
        ret_json["choices"] = choices
        ret_json["correct_index"] = 2
        ret_json["display_index"] = cnt + 1
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_name_for_quiz_question":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            question.name = self.request.get("name")
            question.put() 

    elif self.request.get("fn") == "drop_quiz_question":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            question.key.delete()

    elif self.request.get("fn") == "update_question_choice_text":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            choices = json.loads(question.choices)
            choices[int(self.request.get("idx"))]["text"] = self.request.get("text")
            question.choices = json.dumps(choices)
            question.put()

    elif self.request.get("fn") == "update_quiz_question_indexes":
        mapping = json.loads(self.request.get("mapping"))
        keys = ["-1"] + mapping.keys()
        questions = QuizQuestion.query(QuizQuestion.identifier.IN(keys))
        items_to_save = []
        for question in questions:
            question.display_index = mapping[question.identifier]
            items_to_save.append(question)
        if len(items_to_save) > 0:
            ndb.put_multi(items_to_save)

    elif self.request.get("fn") == "update_choices_for_question":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            question.choices = self.request.get("choices")
            question.correct_index = int(self.request.get("new_correct_idx"))
            question.put()

    elif self.request.get("fn") == "drop_quiz_question_choice":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            choices = json.loads(question.choices)
            del choices[int(self.request.get("idx"))]
            question.correct_index = int(self.request.get("new_correct_idx"))
            question.choices = json.dumps(choices)
            question.put()

    elif self.request.get("fn") == "update_quiz_question_correct_index":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            question.correct_index = int(self.request.get("idx"))
            question.put()

    elif self.request.get("fn") == "add_choice_to_quiz_question":
        question = QuizQuestion.first(QuizQuestion.identifier == self.request.get("identifier"))
        if not question is None:
            choices = json.loads(question.choices)
            choices.append({"text": self.request.get("choice")})
            question.choices = json.dumps(choices)
            question.put()

    elif self.request.get("fn") == "drop_quiz":
        questions = QuizQuestion.query(QuizQuestion.quiz_identifier == self.request.get("identifier"))
        keys = []
        for q in questions:
            keys.append(q.key)
        if len(keys) > 0:
            ndb.delete_multi(keys)
        quiz = Quiz.first(Quiz.identifier == self.request.get("identifier"))
        if not quiz is None:
            quiz.key.delete()

    elif self.request.get("fn") == "create_quiz":
        self.response.content_type = "application/json"
        ret_json = {}
        cnt = Quiz.query().count()
        quiz = Quiz(
            identifier=Helpers.guid(),
            name=self.request.get("name"),
            active=False,
            display_index=(cnt + 1)
        )
        quiz.put()
        ret_json["identifier"] = quiz.identifier
        ret_json["name"] = quiz.name
        ret_json["active"] = quiz.active
        ret_json["display_index"] = quiz.display_index
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_training_media_name":
        media = TrainingMedia.first(TrainingMedia.identifier == self.request.get("identifier"))
        if not media is None:
            media.name = self.request.get("name")
            media.put()

    elif self.request.get("fn") == "delete_training_media":
        media = TrainingMedia.first(TrainingMedia.identifier == self.request.get("identifier"))
        if not media is None:
            media.key.delete()

    elif self.request.get("fn") == "update_training_media_indexing":
        mapping = json.loads(self.request.get("mapping"))
        ids_to_query = ["-1"] + mapping.keys()
        media = TrainingMedia.query(TrainingMedia.identifier.IN(ids_to_query))
        media_to_save = []
        for medium in media:
            medium.display_index = mapping[medium.identifier]
            media_to_save.append(medium)
        if len(media_to_save) == 1:
            media_to_save[0].put()
        elif len(media_to_save) > 1:
            ndb.put_multi(media_to_save)

    elif self.request.get("fn") == "upload_manager_training_media":
        media = TrainingMedia(
            identifier=Helpers.guid(),
            name=self.request.get("name"),
            type="manager_" + self.request.get("type")
        )
        if media.type == "manager_section":
            media.type = "section_manager"
        count = TrainingMedia.query(TrainingMedia.type.IN(["manager_audio", "manager_video", "manager_doc"])).count()
        if "section" in self.request.get("type"):
            count = TrainingMedia.query(
                ndb.OR(
                    TrainingMedia.type == "section_manager",
                    TrainingMedia.type.IN(["manager_audio", "manager_video", "manager_doc"])
                )
            ).count()
        count += 1
        media.display_index = count
        e_info = {}
        if self.request.get("type") == "video":
            e_info["youtube_id"] = str(self.request.get("media")[self.request.get("media").index("/watch?v="):].replace("/watch?v=", ""))
        media.extra_info = json.dumps(e_info)
        media.put()

        if self.request.get("type") in ["audio", "doc"]:
            file_content = self.request.POST.multi['media'].file.read()
                    
            file_mime = self.request.POST['media'].type        
            file_ext = "mp3"
            if "pdf" in file_mime.lower():
                file_ext = "pdf"

            bucket_name = os.environ.get('BUCKET_NAME',
                                    app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            filename = bucket + '/TrainingMedia/' + media.identifier + "." + file_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=file_mime,
                                options={'x-goog-meta-foo': 'foo',
                                        'x-goog-meta-bar': 'bar',
                                        'x-goog-acl': 'public-read'},
                                retry_params=write_retry_params)
            gcs_file.write(file_content)
            gcs_file.close()

    elif self.request.get("fn") == "upload_training_media":
        self.response.content_type = "application/json"
        media = TrainingMedia(
            identifier=Helpers.guid(),
            name=self.request.get("name"),
            type=self.request.get("type"),
        )
        count = TrainingMedia.query(TrainingMedia.type == self.request.get("type")).count()
        if "section" in self.request.get("type"):
            split_vals = self.request.get("type").split("_")
            count = TrainingMedia.query(
                ndb.OR(
                    TrainingMedia.type == split_vals[1],
                    TrainingMedia.type == self.request.get("type")
                )
            ).count()
        count += 1
        media.display_index = count
        e_info = {}
        if self.request.get("type") == "video":
            e_info["youtube_id"] = str(self.request.get("media")[self.request.get("media").index("/watch?v="):].replace("/watch?v=", ""))
        media.extra_info = json.dumps(e_info)
        media.put()

        if self.request.get("type") in ["audio", "doc"]:
            file_content = self.request.POST.multi['media'].file.read()
                    
            file_mime = self.request.POST['media'].type        
            file_ext = "mp3"
            if "pdf" in file_mime.lower():
                file_ext = "pdf"

            bucket_name = os.environ.get('BUCKET_NAME',
                                    app_identity.get_default_gcs_bucket_name())
            bucket = '/' + bucket_name
            filename = bucket + '/TrainingMedia/' + media.identifier + "." + file_ext

            write_retry_params = gcs.RetryParams(backoff_factor=1.1)
            gcs_file = gcs.open(filename,
                                'w',
                                content_type=file_mime,
                                options={'x-goog-meta-foo': 'foo',
                                        'x-goog-meta-bar': 'bar',
                                        'x-goog-acl': 'public-read'},
                                retry_params=write_retry_params)
            gcs_file.write(file_content)
            gcs_file.close()

        ret_json = {"identifier": media.identifier, "name": media.name, "type": media.type, "display_index": count, "extra_info": e_info}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_tax_info":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "filing_status_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="filing_status_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365),                
            )
        kv.val = self.request.get("filing_status")
        kv.put()

        kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "federal_tax_percentage_" + self.request.get("identifier"))
        if kv2 is None:
            kv2 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="federal_tax_percentage_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365),                
            )
        kv2.val = self.request.get("federal_percentage")
        kv2.put()

        kv3 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "state_tax_percentage_" + self.request.get("identifier"))
        if kv3 is None:
            kv3 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="state_tax_percentage_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365),                
            )
        kv3.val = self.request.get("state_percentage")
        kv3.put()

    elif self.request.get("fn") == "add_tax_bracket_matrix":
        brackets = Helpers.read_setting("tax_brackets")
        new_bracket = {"name": self.request.get("name"), "federal": {"brackets": [{"floor": "$0", "ceiling": "$1", "percentage": "0%"}]}, "state": {"brackets": [{"floor": "$0", "ceiling": "$1", "percentage": "0%"}]}}
        brackets.append(new_bracket)
        Helpers.write_setting("tax_brackets", brackets)

    elif self.request.get("fn") == "add_roof_bundle":
        bundles = Helpers.read_setting("doc_bundles")
        bundles.append({"value": "roof_work", "value_friendly": "Roof Work"})
        Helpers.write_setting(b"doc_bundles", bundles)

    elif self.request.get("fn") == "report_paycheck_issue":
        msg = self.request.get("name") + " is reporting an issue with his/her paycheck. Details Below:\r\n\r\n"
        msg += self.request.get("issue")
        msg += "\r\n\r\nContact Info:\r\n"
        msg += self.request.get("email")
        msg += "\r\n"
        msg += self.request.get("phone")

        notification = Notification.first(Notification.action_name == "Paycheck Issue")
        if not notification is None:
            for p in notification.notification_list:
                Helpers.send_email(p.email_address, "Paycheck Issue", msg)

    elif self.request.get("fn") == "plan_set_layout_change":
        self.response.content_type = "application/json"
        ret_json = {"success": True}
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_manager" in info.keys():
                pm = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                if not pm is None:
                    app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
                    if not app_entry is None:
                        subject = "Layout Change for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                        msg = "Layout Change Details:\r\n\r\n"
                        msg += self.request.get("details")
                        Helpers.send_email(pm.rep_email, subject, msg)
                        notification = Notification.first(Notification.action_name == "Plan Set Completed")
                        if not notification is None:
                            for person in notification.notification_list:
                                Helpers.send_email(person.email_address, subject, msg)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "wc_script_finalize":
        notification = Notification.first(Notification.action_name == "WC Scripts")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            if not notification is None:
                for p in notification.notification_list:
                    Helpers.send_static_html(p.email_address, "Welcome Call Script Completed - " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), self.request.get("html"))
        

    elif self.request.get("fn") == "create_pq_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="rnirnber@gmail.com"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Rep Changes Panel Qty",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "create_roof_work_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="rnirnber@gmail.com"
        )

        n = Notification(
            identifier=Helpers.guid(),
            action_name="Roof Docs Signed",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "health_insurance_poll":
        now = Helpers.pacific_now()
        seventy_five_days_ago = now + timedelta(days=-75)
        seventy_five_days_ago_date = date(seventy_five_days_ago.year, seventy_five_days_ago.month, seventy_five_days_ago.day)
        users = FieldApplicationUser.query(FieldApplicationUser.registration_date == seventy_five_days_ago_date)
        for user in users:
            if user.current_status == 0:
                notification = Notification.first(Notification.action_name == "Health Insurance Eligibility")
                if not notification is None:
                    for p in notification.notification_list:
                        Helpers.send_email(p.email_address, "Health Check", user.first_name.strip().title() + " " + user.last_name.strip().title() + " has had a field app account since " + str(user.registration_date) + "...He or she may be eligible for health insurance now because the time delta is equal to 75 days.")

    elif self.request.get("fn") == "ray_delta":
        today = Helpers.pacific_today()
        registration_dt = date(2019, 7, 14)
        delta_seconds = (today - registration_dt).total_seconds()
        delta_minutes = delta_seconds / 60
        delta_hours = delta_minutes / 60
        delta_days = delta_hours / 24
        delta_days = int(delta_days)
        #Helpers.send_email("rnirnber@gmail.com", "delta", str(delta_days))

    elif self.request.get("fn") == "data_not_retrieved_from_logger_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/data_not_retrieved_from_logger")


    elif self.request.get("fn") == "get_power_ups":
        self.response.content_type = "application/json"
        ret_json = {"power_ups": []}
        power_ups = PowerUp.query().order(PowerUp.display_index)
        for p in power_ups:
            obj = {}
            obj["identifier"] = p.identifier
            obj["name"] = p.name
            obj["rep_payout_amount"] = str(round(p.rep_payout_amount, 2))
            obj["recruiter_payout_amount"] = str(round(p.recruiter_payout_amount, 2))
            obj["incentives"] = json.loads(p.incentives)
            obj["requirements"] = json.loads(p.requirements)
            obj["display_index"] = p.display_index
            ret_json["power_ups"].append(obj)

        ret_json["checkoff_data"] = {}
        user_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "power_up_data_" + str(self.request.get("user_identifier")))
        if not user_kv is None:
            ret_json["checkoff_data"] = json.loads(user_kv.val)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "claim_power_up_prize":
        self.response.content_type = "application/json"
        ret_json = {"success": True}
        sign_off = PowerUpSignOff.first(
            ndb.AND(
                PowerUpSignOff.rep_identifier == self.request.get("user_identifier"),
                PowerUpSignOff.power_up_identifier == self.request.get("identifier"),
                PowerUpSignOff.approved == True
            )
        )
        if not sign_off is None:
            ret_json["success"] = False
            ret_json["error_msg"] = "You have already been awarded the prizes for this level."
        else:
            sign_off2 = PowerUpSignOff.first(
                ndb.AND(
                    PowerUpSignOff.rep_identifier == self.request.get("user_identifier"),
                    PowerUpSignOff.power_up_identifier == self.request.get("identifier"),
                    PowerUpSignOff.approved == False,
                    PowerUpSignOff.denied == False
                )
            )
            if not sign_off2 is None:
                ret_json["success"] = False
                ret_json["error_msg"] = "The prizes for this level are already at a state of pending payout."
            else:
                user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("user_identifier"))
                if not user is None:
                    reg_date = user.registration_date
                    six_weeks_ago = (Helpers.pacific_now() + timedelta(days=-42)).date()
                    if reg_date < six_weeks_ago:
                        ret_json["success"] = False
                        ret_json["error_msg"] = "Level Up Prizes are only for reps who have registered within the last six weeks. You are therefore ineligible."
                else:
                    ret_json["success"] = False

        if ret_json["success"]:
            sign_off = PowerUpSignOff(
                identifier=Helpers.guid(),
                rep_identifier=self.request.get("user_identifier"),
                power_up_identifier=self.request.get("identifier"),
                approved=False,
                denied=False,
                created_dt=Helpers.pacific_now(),
                approved_dt=datetime(1970, 1, 1)
            )
            sign_off.put()
            notification = Notification.first(Notification.action_name == "Level Up Requested")
            if not notification is None:
                for person in notification.notification_list:
                    Helpers.send_email(person.email_address, "Sign Off Requested", "Someone is requested sign off for achieving a new power up.")
                    
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_pending_power_ups":
        self.response.content_type = "application/json"
        ret_json = {"sign_offs": []}
        power_ups = PowerUp.query()
        ids_to_query = ["-1"]
        power_up_identifier_name_dict = {}
        for p in power_ups:
            ids_to_query.append(p.identifier)
            power_up_identifier_name_dict[p.identifier] = p.name

        sign_offs = PowerUpSignOff.query(
            ndb.AND(
                PowerUpSignOff.power_up_identifier.IN(ids_to_query),
                PowerUpSignOff.approved == False,
                PowerUpSignOff.denied == False
            )
        )
        rep_ids_to_query = ["-1"]
        for s in sign_offs:
            rep_ids_to_query.append(s.rep_identifier)
            obj = {"identifier": s.identifier, "rep_identifier": s.rep_identifier,"rep_name": "n/a", "submission_date": s.created_dt, "level": power_up_identifier_name_dict[s.power_up_identifier]}
            ret_json["sign_offs"].append(obj)

        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        rep_identifier_name_dict = {}
        for r in reps:
            rep_identifier_name_dict[r.identifier] = r.first_name.strip().title() + " " + r.last_name.strip().title()

        for item in ret_json["sign_offs"]:
            item["rep_name"] = rep_identifier_name_dict[item["rep_identifier"]]

        ret_json["sign_offs"] = Helpers.bubble_sort(ret_json["sign_offs"], "submission_date")

        for item in ret_json["sign_offs"]:
            item["submission_date"] = str(item["submission_date"])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "deny_power_up":
        sign_off = PowerUpSignOff.first(PowerUpSignOff.identifier == self.request.get("identifier"))
        if not sign_off is None:
            sign_off.approved = False
            sign_off.denied = True
            sign_off.put()

    elif self.request.get("fn") == "certify_power_up":
        sign_off = PowerUpSignOff.first(PowerUpSignOff.identifier == self.request.get("identifier"))
        if not sign_off is None:
            power_up = PowerUp.first(PowerUp.identifier == sign_off.power_up_identifier)
            if not power_up is None:
                now = Helpers.pacific_now()
                friday_count = int(now.isoweekday() == 5)
                while friday_count < 2:
                    now = now + timedelta(days=1)
                    friday_count += int(now.isoweekday() == 5)
                
                rep_dollars = int(power_up.rep_payout_amount)
                rep_cents = int(float(power_up.rep_payout_amount * float(100)) % float(100))

                transactions_to_save = []

                rep = FieldApplicationUser.first(
                    ndb.AND(
                        FieldApplicationUser.identifier == sign_off.rep_identifier,
                        FieldApplicationUser.current_status == 0
                    )
                )
                if not rep is None:
                    rep_transaction = MonetaryTransactionV2(
                        identifier=Helpers.guid(),
                        description="Power Up Payout - " + power_up.name + ".",
                        dollars=rep_dollars,
                        cents=rep_cents,
                        approved=True,
                        denied=False,
                        description_key="power_up_rep_payout",
                        recipient=sign_off.rep_identifier,
                        created=Helpers.pacific_now(),
                        check_number=-1,
                        payout_date=now.date(),
                        paid=False,
                        field_app_identifier="-1",
                        extra_info="{}"
                    )
                    
                    if power_up.rep_payout_amount >= float(0.01):
                        transactions_to_save.append(rep_transaction)

                    
                    recruiter = FieldApplicationUser.first(
                        ndb.AND(
                            FieldApplicationUser.rep_id == rep.recruiter_rep_id,
                            FieldApplicationUser.current_status == 0
                        )
                    )
                    if not recruiter is None:
                        if not recruiter.rep_id in ["VAND0127", "COLL0910", "AZ0230"]:
                            recruiter_dollars = int(power_up.recruiter_payout_amount)
                            recruiter_cents = int(float(power_up.recruiter_payout_amount * float(100)) % float(100))

                            recruiter_transaction = MonetaryTransactionV2(
                                identifier=Helpers.guid(),
                                description="Power Up Recruiter Payout - " + power_up.name + " - " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + ".",
                                dollars=recruiter_dollars,
                                cents=recruiter_cents,
                                approved=True,
                                denied=False,
                                description_key="power_up_recruiter_payout",
                                recipient=recruiter.identifier,
                                created=Helpers.pacific_now(),
                                check_number=-1,
                                payout_date=now.date(),
                                paid=False,
                                field_app_identifier="-1",
                                extra_info="{}"
                            )

                            if power_up.recruiter_payout_amount >= float(0.01):
                                transactions_to_save.append(recruiter_transaction)

                    if len(transactions_to_save) > 0:
                        ndb.put_multi(transactions_to_save)

                    notification = Notification.first(Notification.action_name == "Level Up Swag Ordering")
                    if not notification is None:
                        incentives = json.loads(power_up.incentives)
                        for person in notification.notification_list:
                            Helpers.send_email(person.email_address, rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " Needs Swag", rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " completed power up requirements for " + power_up.name + ". The following swag should be provided:\r\n\r\n" + "\r\n".join(incentives))

                    sign_off.approved = True
                    sign_off.denied = False
                    sign_off.put()

    elif self.request.get("fn") == "power_up_checkoff":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "power_up_data_" + self.request.get("user_identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="power_up_data_" + self.request.get("user_identifier"),
                val="{}",
                expiration=datetime(1970, 1, 1)
            )
        vals = json.loads(kv.val)
        keys = vals.keys()
        if not self.request.get("identifier") in keys:
            vals[self.request.get("identifier")] = []
        if self.request.get("checked") == "1":
            vals[self.request.get("identifier")].append(self.request.get("requirement_identifier"))
        else:
            rem_idx = -1
            if self.request.get("requirement_identifier") in vals[self.request.get("identifier")]:
                rem_idx = vals[self.request.get("identifier")].index(self.request.get("requirement_identifier"))
            if rem_idx > -1:
                del vals[self.request.get("identifier")][rem_idx]
        kv.val = json.dumps(vals)
        kv.put()

    elif self.request.get("fn") == "create_wc_complete_notification":
        p1 = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="mcollins@newpower.net"
        )
        p2 = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="narmstrong@newpower.net"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Welcome Call Completed",
            notification_list=[p1, p2]
        )
        n.put()

    elif self.request.get("fn") == "create_incomplete_proposal_response_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="rnirnber@gmail.com"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Incomplete Proposal Follow-Up",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "create_panel_assessment_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="person@example.com"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Panel Assessment Updated",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "create_pm_assignment_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="cory@newpower.net"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Project Manager Assigned",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "create_save_me_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="ray@newpower.net"
        )
        #p2 = PersonToNotify(
            #identifier=Helpers.guid(),
            #email_address="ray@newpower.net"
        #)
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Save Me State",
            notification_list=[p]
        )
        #n2 = Notification(
            #identifier=Helpers.guid(),
            #action_name="Survey Completed",
            #notification_list=[p2]
        #)
        n.put()
        #n2.put()

    elif self.request.get("fn") == "create_mms_twilio_notification":
        p = PersonToNotify(
            identifier=Helpers.guid(),
            email_address="rnirnber@gmail.com"
        )
        n = Notification(
            identifier=Helpers.guid(),
            action_name="Twilio Message Received",
            notification_list=[p]
        )
        n.put()

    elif self.request.get("fn") == "save_customer":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            Helpers.save_me_state(app_entry, self.request.get("reason"))


    elif self.request.get("fn") == "get_soiling_levels":
        self.response.content_type = "application/json"
        f = GCSLockedFile("/ApplicationSettings/soiling_levels.json");
        ret_json = json.loads(f.read())
        f.unlock()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "write_soiling_levels":
        f = GCSLockedFile("/ApplicationSettings/soiling_levels.json")
        f.write(self.request.get("data"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "true_hk_data":
        self.response.content_type = "application/json"
        #ret_json = [{"minutes": 241, "name": "Ray Nirnberger", "identifier": "38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c"}]
        ret_json = []

        start_dt_vals = self.request.get("start_dt").split("-")
        end_dt_vals = self.request.get("end_dt").split("-")

        s_dt = datetime(int(start_dt_vals[0]), int(start_dt_vals[1]), int(start_dt_vals[2]), 0, 0, 0)
        e_dt = datetime(int(end_dt_vals[0]), int(end_dt_vals[1]), int(end_dt_vals[2]), 23, 59, 59)

        rep_ids_to_query = ["-1"]

        tallies = HKTally.query(
            ndb.AND(
                HKTally.dt >= s_dt,
                HKTally.dt <= e_dt
            )
        )

        rep_identifier_tallies_dict = {}
        for tally in tallies:
            if not tally.rep_identifier in rep_identifier_tallies_dict.keys():
                rep_identifier_tallies_dict[tally.rep_identifier] = 0
            rep_identifier_tallies_dict[tally.rep_identifier] += tally.minutes
            if not tally.rep_identifier in rep_ids_to_query:
                rep_ids_to_query.append(tally.rep_identifier)

        rep_identifier_name_dict = {}
        rep_id_rep_identifier_dict = {}
        rep_identifier_rep_id_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_id_rep_identifier_dict[rep.rep_id] = rep.identifier
            rep_identifier_rep_id_dict[rep.identifier] = rep.rep_id

        rep_identifier_idx_dict = {}
        for rep_identifier in rep_identifier_tallies_dict.keys():
            rep_identifier_idx_dict[rep_identifier] = len(ret_json)
            obj = {"minutes": rep_identifier_tallies_dict[rep_identifier]}
            obj["identifier"] = rep_identifier
            obj["name"] = rep_identifier_name_dict[rep_identifier]
            obj["pin_tally"] = 0
            ret_json.append(obj)

        stat_keys = ["app_stat_CD", "app_stat_R", "app_stat_CB", "app_stat_NQ", "app_stat_NI", "app_stat_AB"]
        

        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.dt >= s_dt,
                LeaderBoardStat.dt <= e_dt,
                LeaderBoardStat.metric_key.IN(stat_keys)
            )
        )

        eligible_rep_identifiers = rep_identifier_tallies_dict.keys()
        eligible_rep_ids = rep_id_rep_identifier_dict.keys()
        for stat in stats:
            if stat.rep_id in eligible_rep_ids:
                rep_identifier = rep_id_rep_identifier_dict[stat.rep_id]
                if rep_identifier in eligible_rep_identifiers:
                    idx = rep_identifier_idx_dict[rep_identifier]
                    ret_json[idx]["pin_tally"] += 1

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "restore_customer":
        identifier = self.request.get("identifier")
        items = [
            FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier),
            SurveyBooking.first(SurveyBooking.field_app_identifier == identifier),
            CustomerProgressItem.first(CustomerProgressItem.field_app_identifier == identifier),
            PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == identifier),
            PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier),
            PerfectPacketApproval.first(PerfectPacketApproval.field_application_identifier == identifier),
            Lead.first(Lead.field_app_identifier == identifier)
        ]

        items_to_put = []
        for item in items:
            if not item is None:
                item.save_me = False
                item.archived = False
                if hasattr(item, "save_me_reason"):
                    item.save_me_reason = "n/a"
                items_to_put.append(item)                

        if len(items_to_put) == 1:
            items_to_put[0].put()
        else:
            ndb.put_multi(items_to_put)

        pm_found = False
        pm_name = ""
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_manager" in info.keys():
                pm = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                if not pm is None:
                    pm_found = True
                    pm_name = pm.first_name.strip().title() + " " + pm.last_name.strip().title()

        if not items[0] is None:
            user = None
            try:
                user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
            except:
                user = User

            if not user is None:
                try:
                    CustomerTranscriber.transcribe(items[0], user, "customer_remove_save_me_annotation")
                except:
                    user = user

        app_entry = items[0]
        if str(self.request.get("unlock")) == "1":
            app_entry.deal_closed = False
            app_entry.deal_locked = False
            app_entry.put()

        notification = Notification.first(Notification.action_name == "Customer Saved")
        msg = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " has been saved/restored from the save me status."
        if pm_found:
            msg += "\r\n\r\nProject Manager: " + pm_name
        if not notification is None:
            for person in notification.notification_list:
                Helpers.send_email(person.email_address, "Customer Saved", msg)

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "save_me_events_" + identifier)

        if not kv is None:
            event_info = json.loads(kv.val)
            kv.key.delete()
            start_dts = event_info["start"]
            end_dts = event_info["end"]
            events = CalendarEvent.query(
                ndb.AND(
                    CalendarEvent.field_app_identifier == identifier,
                    CalendarEvent.event_key.IN(["final_inspection", "install", "permit_to_city"])
                )
            )
            for event in events:
                if event.event_key in start_dts.keys():
                    old_start_dt = event.start_dt
                    old_end_dt = event.end_dt
                    old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
                    old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)

                    start_date_vals = start_dts[event.event_key].split(" ")[0]
                    start_date_vals = start_date_vals.split("-")
                    start_time_vals = start_dts[event.event_key].split(" ")[1]
                    start_time_vals = start_time_vals.split(":")
                    start_date = datetime(int(start_date_vals[0]), int(start_date_vals[1]), int(start_date_vals[2]), int(start_time_vals[0]), int(start_time_vals[1]), int(start_time_vals[2]))

                    end_date_vals = end_dts[event.event_key].split(" ")[0]
                    end_date_vals = end_date_vals.split("-")
                    end_time_vals = end_dts[event.event_key].split(" ")[1]
                    end_time_vals = end_time_vals.split(":")
                    end_date = datetime(int(start_date_vals[0]), int(start_date_vals[1]), int(start_date_vals[2]), int(start_time_vals[0]), int(start_time_vals[1]), int(start_time_vals[2]))


                    event.start_dt = start_date
                    event.end_dt = start_date
                    event.put()

                    from google.appengine.api import taskqueue
                    taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "create_one_time_event"})

    elif self.request.get("fn") == "drop_solar_reader":
        self.response.content_type = "application/json"
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            reader.key.delete()
        self.response.out.write(json.dumps({"foo": "bar"}))

    elif self.request.get("fn") == "add_solar_reader":
        self.response.content_type = "application/json"
        ret_json = {}
        device = SolarReader(
            identifier=Helpers.guid(),
            device_id=str(int(self.request.get("device_id"))),
            hash=self.request.get("hash"),
            office_ownership=self.request.get("ownership"),
            rep_ownership="-1",
            deployment_dt=datetime(1970, 1, 1),
            checked_out=False,
            field_app_identifier="-1",
            retrieval_dt=datetime(1970, 1, 1)
        )
        device.put()
        ret_json["identifier"] = device.identifier
        ret_json["device_id"] = device.device_id
        ret_json["hash"] = device.hash
        ret_json["office_ownership"] = device.office_ownership
        ret_json["rep_ownership"] = device.rep_ownership
        ret_json["deployment_dt"] = str(device.deployment_dt)
        ret_json["checked_out"] = device.checked_out
        ret_json["field_app_identifier"] = "-1"
        ret_json["retrieval_dt"] = "1970-01-01 00:00:00"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "check_out_reader":
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            reader.checked_out = True
            reader.deployment_dt = datetime(1970, 1, 1)
            reader.rep_ownership = self.request.get("rep_identifier")
            reader.field_app_identifier = "-1"
            reader.retrieval_dt = datetime(1970, 1, 1)
            reader.put()

    elif self.request.get("fn") == "check_in_reader":
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            reader.rep_ownership = "-1"
            reader.deployment_dt = datetime(1970, 1, 1)
            reader.checked_out = False
            reader.field_app_identifier = "-1"
            reader.retrieval_dt = datetime(1970, 1, 1)
            reader.put()

    elif self.request.get("fn") == "reassign_solar_reader_office_ownership":
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            reader.office_ownership = self.request.get("office")
            reader.put()
            
    elif self.request.get("fn") == "get_responsible_party_for_reader":
        self.response.content_type = "application/json"
        ret_json = {"party": "Unknown"}
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            if reader.rep_ownership == "-1":
                offices = Helpers.read_setting("solar_reader_offices")
                for office in offices:
                    if office["identifier"] == self.request.get("office"):
                        ret_json["party"] = office["name"]

            else:
                rep = FieldApplicationUser.first(FieldApplicationUser.identifier == reader.rep_ownership)
                if not rep is None:
                    ret_json["party"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_location_for_reader":
        self.response.content_type = "application/json"
        ret_json = {"result": "Unknown"}
        reader = SolarReader.first(SolarReader.identifier == self.request.get("identifier"))
        if not reader is None:
            if reader.checked_out == False or reader.rep_ownership == "-1":
                offices = Helpers.read_setting("solar_reader_offices")
                for office in offices:
                    if office["identifier"] == self.request.get("office"):
                        ret_json["result"] = "In Office (" + office["name"] + ")"
            
            elif not reader.rep_ownership == "-1":
                if reader.deployment_dt.year > 1970:
                    app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == reader.field_app_identifier)
                    if not app_entry is None:
                        ret_json["result"] = "In " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s home.... " + app_entry.customer_address + " " + app_entry.customer_city + ", " + app_entry.customer_state + " " + app_entry.customer_postal
                else:
                    rep = FieldApplicationUser.first(FieldApplicationUser.identifier == reader.rep_ownership)
                    if not rep is None:
                        ret_json["result"] = "With " + rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_sp2_time_for_reader_device":
        self.response.content_type = "application/json"
        ret_json = {"time": "1970-01-01 00:00:00"}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["time"] = str(app_entry.sp_two_time).split(".")[0]
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_solar_reader_devices":
        self.response.content_type = "application/json"
        ret_json = {"devices": []}

        devices = SolarReader.query()
        for device in devices:
            obj = {"identifier": device.identifier}
            obj["device_id"] = device.device_id
            obj["hash"] = device.hash
            obj["office_ownership"] = device.office_ownership
            obj["rep_ownership"] = device.rep_ownership
            obj["deployment_dt"] = str(device.deployment_dt).split(".")[0]
            obj["checked_out"] = device.checked_out
            obj["field_app_identifier"] = device.field_app_identifier
            obj["location"] = "Unknown"
            obj["responsible_party"] = "Unknown"
            obj["retrieval_dt"] = str(device.retrieval_dt).split(".")[0]
            ret_json["devices"].append(obj)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "solar_reader_csv_export":
        offices = Helpers.read_setting("solar_reader_offices")
        office_identifier_name_dict = {}
        for office in offices:
            office_identifier_name_dict[office["identifier"]] = office["name"]
        
        lst = []
        rep_ids_to_query = ["-1"]
        devices = SolarReader.query()
        device_identifier_office_identifier_dict = {}
        device_identifier_rep_identifier_dict = {}
        app_ids_to_query = ["-1"]
        for device in devices:
            obj = {"device_id": device.device_id}
            obj["identifier"] = device.identifier
            device_identifier_office_identifier_dict[device.identifier] = device.office_ownership
            device_identifier_rep_identifier_dict[device.identifier] = device.rep_ownership
            obj["hash"] = device.hash
            obj["office"] = office_identifier_name_dict[device.office_ownership]
            obj["rep"] = device.rep_ownership
            obj["deployed"] = ["Not Deployed", "Deployed"][int(device.deployment_dt.year > 1970)]
            obj["deployment_time"] = str(device.deployment_dt).split(".")[0]
            obj["checked_out"] = device.checked_out
            obj["location"] = "Unknown"
            obj["data_retrieved"] = (device.retrieval_dt.year > 1970)
            obj["retrieval_time"] = str(device.retrieval_dt).split(".")[0]
            obj["field_app_identifier"] = device.field_app_identifier
            obj["sp2_time"] = "N/A"
            if not device.field_app_identifier == "-1":
                app_ids_to_query.append(device.field_app_identifier)
            if not device.rep_ownership == "-1":
                rep_ids_to_query.append(device.rep_ownership)

            lst.append(obj)

        app_identifier_location_dict = {}
        app_identifier_sp2_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_location_dict[app_entry.identifier] = "In " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s home.... " + app_entry.customer_address + " " + app_entry.customer_city + ", " + app_entry.customer_state + " " + app_entry.customer_postal
            app_identifier_sp2_dict[app_entry.identifier] = str(app_entry.sp_two_time).split(".")[0]

        rep_identifier_name_dict = {"-1": "Nobody"}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        for obj in lst:
            obj["rep"] = rep_identifier_name_dict[obj["rep"]]
            if obj["checked_out"] == False or obj["rep"] == "-1":
                office_identifier = device_identifier_office_identifier_dict[obj["identifier"]]
                obj["location"] = "In Office (" + office_identifier_name_dict[office_identifier] + ")"
            
            elif not obj["rep"] == "-1":
                if not "1970" in obj["deployment_time"]:
                    obj["location"] = app_identifier_location_dict[obj["field_app_identifier"]]
                    obj["sp2_time"] = app_identifier_sp2_dict[obj["field_app_identifier"]]
                else:
                    obj["location"] = "With " + obj["rep"]

            rep_identifier = device_identifier_rep_identifier_dict[obj["identifier"]]
            if rep_identifier == "-1":
                obj["responsible_party"] = obj["office"]

            else:
                obj["responsible_party"] = obj["rep"]

            if "1970" in obj["deployment_time"]:
                obj["deployment_time"] = "n/a"

            if "1970" in obj["retrieval_time"]:
                obj["retrieval_time"] = "n/a"

        import tablib
        headers = ("Device ID", "Hash", "Office", "Deployment Status", "Deployment Time", "SP2 Time", "Checked Out", "Location", "Responsible Party", "Data Retrieved", "Retrieval Time", "Field App Identifier")

        data = []
        for item in lst:
            data.append((str(item["device_id"]),
                    item["hash"],
                    item["office"],
                    item["deployed"],
                    item["deployment_time"],
                    item["sp2_time"],
                    str(item["checked_out"]),
                    item["location"],
                    item["responsible_party"],
                    item["data_retrieved"],
                    item["retrieval_time"],
                    item["field_app_identifier"]))

        structured_data = tablib.Dataset(*data, headers=headers)
        attachment_data = {}
        attachment_data["data"] = []
        attachment_data["content_types"] = []
        attachment_data["filenames"] = []

        attachment_data["data"].append(base64.b64encode(structured_data.csv))
        attachment_data["content_types"].append("text/csv")
        attachment_data["filenames"].append("solar_reader_export.csv")

        subject = "Your Data Export"
        msg_body = "See Attached..."
        Helpers.send_email(self.request.get("email"), subject, msg_body, attachment_data)

    elif self.request.get("fn") == "solar_reader_device_id_check":
        self.response.content_type = "application/json"
        reader = SolarReader.first(SolarReader.device_id == str(int(self.request.get("id"))))
        ret_json = {"success": (reader is None)}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "show_saved_customers":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []

        apps = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.save_me == True,
                FieldApplicationEntry.rep_id == self.session["user_rep_id"]
            )
        )

        for app in apps:
            item = {}
            item["identifier"] = app.identifier
            item["name"] = app.customer_first_name.strip().title() + " " + app.customer_last_name.strip().title()
            ret_json["customers"].append(item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "unfinished_surveys":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        bookings = SurveyBooking.query(
            ndb.AND
            (
                ndb.OR
                (
                    SurveyBooking.completion_state == 0,
                    SurveyBooking.completion_state == 1
                ),
                SurveyBooking.archived == False
            )
        )
        booking_identifier_booking_idx_dict = {}
        booking_identifier_field_app_identifier_dict = {}
        booking_identifier_survey_date_dict = {}
        booking_identifier_name_dict = {}
        booking_identifiers_to_query = ["-1"]

        all_results = []

        cnt = 0
        for booking in bookings:
            booking_identifier_booking_idx_dict[booking.identifier] = cnt
            booking_identifier_field_app_identifier_dict[booking.identifier] = booking.field_app_identifier
            booking_identifier_survey_date_dict[booking.identifier] = str(date(booking.booking_year, booking.booking_month, booking.booking_day))
            booking_identifier_name_dict[booking.identifier] = booking.name.strip()

            booking_identifiers_to_query.append(booking.identifier)

            booking_item = {}
            booking_item["booking_identifier"] = booking.identifier
            booking_item["field_app_identifier"] = booking.field_app_identifier
            booking_item["survey_date"] = str(date(booking.booking_year, booking.booking_month, booking.booking_day))
            booking_item["name"] = booking.name.strip()

            all_results.append(booking_item)

            cnt += 1

        idxs_to_exclude = []
        entries = PerfectPacketEntry.query(PerfectPacketEntry.booking_identifier.IN(booking_identifiers_to_query))
        for entry in entries:
            idxs_to_exclude.append(booking_identifier_booking_idx_dict[entry.booking_identifier])

        cnt = 0
        for item in all_results:
            if (not (cnt in idxs_to_exclude)):
                ret_json["results"].append(item)
            cnt += 1

        final_results = []
        today = Helpers.pacific_today()

        for item in ret_json["results"]:
            date_items = item["survey_date"].split("-")
            dayte = date(int(date_items[0]), int(date_items[1]), int(date_items[2]))

            if dayte < today:
                final_results.append(item)

        ret_json["results"] = final_results

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "potential_packet_info":
        self.response.content_type = "application/json"
        ret_json = {}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["customer_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            ret_json["customer_phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret_json["customer_email"] = app_entry.customer_email

            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                ret_json["rep_name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                ret_json["rep_phone"] = Helpers.format_phone_number(rep.rep_phone)
                ret_json["rep_email"] = rep.rep_email

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_packet_manually":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)
            if not booking is None:
                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == booking.associated_rep_id)
                if not rep is None:
                    surveyor = FieldApplicationUser.first(FieldApplicationUser.user_type == "survey")
                    if not surveyor is None:
                        pp_entry = PerfectPacketEntry(
                            identifier=Helpers.guid(),
                            booking_identifier=booking.identifier,
                            field_application_identifier=app_entry.identifier,
                            surveyor_identifier=surveyor.identifier,
                            surveyor_completion_state=1,
                            surveyor_completion_date=datetime(booking.booking_year, booking.booking_month, booking.booking_day),
                            rep_identifier=rep.identifier,
                            rep_completion_state=0,
                            rep_completion_date=datetime(1970, 1, 1),
                            outstanding_items="[]",
                            created=datetime(booking.booking_year, booking.booking_month, booking.booking_day),
                            archived=False,
                            save_me=False
                        )
                        pp_entry.put()
                        ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "save_me_info":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["reason"] = "N/A"
        ret_json["phone"] = "{Missing}"
        ret_json["address"] = "{Missing}"

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["reason"] = app_entry.save_me_reason
            ret_json["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret_json["address"] = app_entry.customer_address

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "save_me_tally":
        self.response.content_type = "application/json"
        ret_json = {}

        field_app_ids_to_query = ["-1"]
        index = search.Index(name="cust_names")

        results = index.search(self.session["user_rep_id"])
        for result in results:
            for field in result.fields:
                if field.name == "cust_identifier":
                    field_app_ids_to_query.append(field.value)

        ret_json["field_app_ids"] = field_app_ids_to_query
        ret_json["count"] = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.identifier.IN(field_app_ids_to_query),
                FieldApplicationEntry.save_me == True
            )
        ).count()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_contests":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["contests"] = []
        contests = ContestItem.query()
        for contest in contests:
            contest_item = {}
            for key in ["identifier", "start_time", "end_time", "name", "description"]:
                contest_item[key] = getattr(contest, key)

            ret_json["contests"].append(contest_item)

        ret_json["contests"] = Helpers.bubble_sort(ret_json["contests"], "start_time")

        for contest in ret_json["contests"]:
            contest["start_time"] = str(contest["start_time"])
            contest["end_time"] = str(contest["end_time"])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_contest":
        st = None
        dt = None
        final_name_vals = None
        try:
            st_vals = self.request.get("st").split("-")
            et_vals = self.request.get("et").split("-")

            st = datetime(int(st_vals[0]), int(st_vals[1]), int(st_vals[2]))
            et = datetime(int(et_vals[0]), int(et_vals[1]), int(et_vals[2]))

            name_vals = self.request.get("name").split(" ")
            final_name_vals = []
            for name_val in name_vals:
                final_name_vals.append(name_val.strip().title())

        except:
            st = st

        if (not st is None) and (not et is None) and (not final_name_vals is None):
            ContestItem(
                identifier=Helpers.guid(),
                name=" ".join(final_name_vals),
                start_time = st,
                end_time=et,
                description="{\"provided\": false}",
                announcable=False,
                winners="[]",
                multiple_winners=False
            ).put()

    elif self.request.get("fn") == "update_contest_name":
        contest = ContestItem.first(ContestItem.identifier == self.request.get("identifier"))
        if not contest is None:
            final_name_vals = None
            name_vals = self.request.get("name").split(" ")
            final_name_vals = []
            for name_val in name_vals:
                final_name_vals.append(name_val.strip().title())

            contest.name = " ".join(final_name_vals)
            contest.put()

    elif self.request.get("fn") == "update_contest_description":
        contest = ContestItem.first(ContestItem.identifier == self.request.get("identifier"))
        if not contest is None:
            description = json.loads(contest.description)
            description["provided"] = True
            description["text"] = self.request.get("description")
            contest.description = json.dumps(description)
            contest.put()

    elif self.request.get("fn") == "update_contest_times":
        contest = ContestItem.first(ContestItem.identifier == self.request.get("identifier"))
        if not contest is None:
            st = None
            dt = None

            try:
                st_vals = self.request.get("st").split("-")
                et_vals = self.request.get("et").split("-")

                st = datetime(int(st_vals[0]), int(st_vals[1]), int(st_vals[2]))
                et = datetime(int(et_vals[0]), int(et_vals[1]), int(et_vals[2]))

            except:
                st = st

            if (not st is None) and (not et is None):
                contest.start_time = st
                contest.end_time = et
                contest.put()

    elif self.request.get("fn") == "auto_purge_save_mes":
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.save_me == True,
                FieldApplicationEntry.save_me_dt <= (Helpers.pacific_now() + timedelta(days=-14))
            )
        )

        app_entries_to_put = []
        app_entry_ids_to_query = ["-1"]
        for app_entry in app_entries:
            if app_entry.save_me_dt.year > 1970:
                app_entry.save_me = False
                app_entry.archived = True
                app_entry_ids_to_query.append(app_entry.identifier)
                app_entries_to_put.append(app_entry)

        for entity_results in [SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_entry_ids_to_query)),
                               PerfectPacketEntry.query(PerfectPacketEntry.field_application_identifier.IN(app_entry_ids_to_query)),
                               PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_entry_ids_to_query)),
                               PerfectPacketApproval.query(PerfectPacketApproval.field_application_identifier.IN(app_entry_ids_to_query)),
                               CustomerProgressItem.query(CustomerProgressItem.field_app_identifier.IN(app_entry_ids_to_query)),
                               PayrollCustomerState.query(PayrollCustomerState.field_app_identifier.IN(app_entry_ids_to_query)),
                               Lead.query(Lead.field_app_identifier.IN(app_entry_ids_to_query))]:

            entities_to_put = []
            for entity_result in entity_results:
                entity_result.archived = True
                if hasattr(entity_result, "save_me"):
                    entity_result.save_me = False

                entities_to_put.append(entity_result)

            if len(entities_to_put) == 1:
                entities_to_put[0].put()
            elif len(entities_to_put) > 1:
                ndb.put_multi(entities_to_put)

        if len(app_entries_to_put) == 1:
            app_entries_to_put[0].put()
        elif len(app_entries_to_put) > 1:
            ndb.put_multi(app_entries_to_put)

        reqd_actions = RepRequiredAction.query(RepRequiredAction.field_app_identifier.IN(app_entry_ids_to_query))
        for a in reqd_actions:
            a.key.delete()


    elif self.request.get("fn") == "update_approval_amount":
        kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "approval_amount_" + self.request.get("identifier"))
        if kv_item is None:
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="approval_amount_" + self.request.get("identifier"),
                expiration=datetime(1970, 1, 1)
            )
        kv_item.val = self.request.get("amount")
        kv_item.put()

    elif self.request.get("fn") == "payroll_disqualification_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/payroll_disqualification", params={})

    elif self.request.get("fn") == "update_sp2_dt":
        self.response.content_type = "application/json"
        dt_vals = self.request.get("dt").split(" ")[0].split("-")
        time_vals = self.request.get("dt").split(" ")[1].split(":")

        dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), int(time_vals[0]), int(time_vals[1]), int(time_vals[2]))

        existing_sp_two_entry = FieldApplicationEntry.first(
            ndb.AND(
                FieldApplicationEntry.sp_two_time == dt,
                FieldApplicationEntry.rep_id == self.request.get("rep_id")
            )
        )
        ret_json = {"success": (existing_sp_two_entry == None)}
        if ret_json["success"]:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                app_entry.sp_two_time = dt
                app_entry.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_data_logger_info":
        self.response.content_type = "application/json"
        ret_json = {"data_exists": False}

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == self.request.get("identifier") + "_data_logging")
        if not kv is None:
            ret_json["data_exists"] = True
            ret_json["data"] =json.loads(kv.val)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_recent_customers":
        self.response.content_type = "application/json"
        ret_json = {}

        seven_days_ago = datetime.now()
        seven_days_ago = seven_days_ago + timedelta(days=-7)
        epoch = datetime(1970, 1, 1)
        insert_time_floor = (seven_days_ago - epoch).total_seconds() * 1000
        insert_time_floor = int(insert_time_floor)

        app_identifier_booking_identifier_dict = {}
        app_identifier_idx_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.insert_time >= insert_time_floor)
        booking_ids_to_query = ["-1"]
        rep_ids_to_query = ["-1"]
        atts = ["booking_identifier", "customer_address", "customer_city", "customer_dob", "customer_email", "customer_first_name", "customer_kwh_price", "customer_last_name", "customer_phone", "customer_postal", "customer_state", "customer_utility_account_number", "identifier", "utility_provider", "insert_time", "opt_rep_notes"]
        cnt = 0
        items = []

        kv_keys_to_query = ["-1"]
        app_ids_to_query = ["-1"]

        for app_entry in app_entries:
            if app_entry.archived or app_entry.save_me or app_entry.hide_from_recent_view:
                continue

            app_identifier_booking_identifier_dict[app_entry.identifier] = app_entry.booking_identifier
            app_identifier_idx_dict[app_entry.identifier] = cnt
            booking_ids_to_query.append(app_entry.booking_identifier)
            rep_ids_to_query.append(app_entry.rep_id)
            app_ids_to_query.append(app_entry.identifier)

            item = {}
            item["booking_identifier"] = app_entry.booking_identifier
            item["customer_address"] = app_entry.customer_address
            item["customer_city"] = app_entry.customer_city
            item["customer_dob"] = str(app_entry.customer_dob)
            item["customer_email"] = app_entry.customer_email
            item["customer_first_name"] = app_entry.customer_first_name
            item["customer_kwh_price"] = app_entry.customer_kwh_price
            item["customer_last_name"] = app_entry.customer_last_name
            item["customer_phone"] = app_entry.customer_phone
            item["customer_phone_formatted"] = Helpers.format_phone_number(item["customer_phone"])
            item["customer_postal"] = app_entry.customer_postal
            item["customer_state"] = app_entry.customer_state
            item["rep_id"] = app_entry.rep_id
            item["customer_utility_account_number"] = app_entry.customer_utility_account_number
            item["sp_two_time"] = app_entry.sp_two_time
            dt = Helpers.epoch_millis_to_pacific_dt(app_entry.insert_time)
            item["recorded_dt"] = dt.strftime("%m/%d/%Y %I:%M %p")
            item["identifier"] = app_entry.identifier
            item["utility_provider"] = app_entry.utility_provider
            item["spouse_name"] = app_entry.spouse_name
            if item["utility_provider"] == "san_diego_gas_&_electric":
                kv_keys_to_query.append("SDGE_meter_number_" + item["identifier"])
            
            #item["annual_income"] = "-1"
            #item["mortgage_payment"] = "-1"
            item["approval_amount"] = "-1"
            item["admin_notes"] = ""
            item["care"] = False
            #kv_keys_to_query.append("mortgage_payment_" + item["identifier"])
            #kv_keys_to_query.append("annual_income_" + item["identifier"])
            kv_keys_to_query.append("approval_amount_" + item["identifier"])
            kv_keys_to_query.append("second_homeowner_" + item["identifier"])

            item["meter_number"] = None

            item["insert_time"] = app_entry.insert_time
            item["opt_rep_notes"] = app_entry.opt_rep_notes
            item["usage_info_available"] = app_entry.usage_info_available
            item["usage_months"] = app_entry.usage_months
            item["total_dollars"] = app_entry.total_dollars
            item["total_kwhs"] = app_entry.total_kwhs
            item["highest_amount"] = app_entry.highest_amount
            item["rep"] = {}
            item["rep"]["id"] = app_entry.rep_id
            #item["credit_score"] = -1
            #item["last_four"] = -1
            item["spouse_info"] = None
            try:
                item["usage_data"] = json.loads(app_entry.usage_data)
            except:
                item["usage_data"] = {}

            items.append(item)
            cnt += 1

        if len(kv_keys_to_query) > 1:
            kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kv_keys_to_query))
            for kv_item in kv_items:
                if "meter_number" in kv_item.keyy:
                    vallllls = kv_item.keyy.split("_")
                    a_id = vallllls[-1]
                    items[app_identifier_idx_dict[a_id]]["meter_number"] = kv_item.val
                #elif "annual_income" in kv_item.keyy:
                    #vallllls = kv_item.keyy.split("_")
                    #a_id = vallllls[-1]
                    #items[app_identifier_idx_dict[a_id]]["annual_income"] = kv_item.val
                #elif "mortgage_payment" in kv_item.keyy:
                    #vallllls = kv_item.keyy.split("_")
                    #a_id = vallllls[-1]
                    #items[app_identifier_idx_dict[a_id]]["mortgage_payment"] = kv_item.val
                elif "approval_amount" in kv_item.keyy:
                    vallllls = kv_item.keyy.split("_")
                    a_id = vallllls[-1]
                    items[app_identifier_idx_dict[a_id]]["approval_amount"] = kv_item.val

                elif "second_homeowner_" in kv_item.keyy:
                    a_id = kv_item.keyy.replace("second_homeowner_", "")
                    items[app_identifier_idx_dict[a_id]]["spouse_info"] = json.loads(kv_item.val)

        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
        for booking in bookings:
            idx = app_identifier_idx_dict[booking.field_app_identifier]
            item = items[idx]
            item["fund"] = booking.fund
            item["trust_docs"] = booking.trust_docs
            item["booking_date"] = str(date(booking.booking_year, booking.booking_month, booking.booking_day))
            item["booking_slot"] = booking.slot_number
            item["funding_tier"] = booking.funding_tier

        notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.note_key.IN(["credit_screen_notes", "welfare"]),
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )
        for note in notes:
            idx = app_identifier_idx_dict[note.field_app_identifier]
            item = items[idx]
            if note.note_key == "credit_screen_notes":
                item["admin_notes"] = json.loads(note.content)["txt"][0]
            elif note.note_key == "welfare":
                item["care"] = True

        #checks = CreditCheck.query(CreditCheck.field_app_identifier.IN(app_ids_to_query))
        #for check in checks:
            #idx = app_identifier_idx_dict[check.field_app_identifier]
            #item = items[idx]
            #item["credit_score"] = check.score
            #item["last_four"] = check.last_four

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for item in items:
                if item["rep"]["id"] == rep.rep_id:
                    item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                    item["rep"]["phone"] = rep.rep_phone
                    item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)

        ret_json["customers"] = Helpers.bubble_sort(items, "sp_two_time")
        for item in ret_json["customers"]:
            item["sp_two_time"] = str(item["sp_two_time"])
        ret_json["funding_list"] = Helpers.list_funds()
        #ret_json["customers"] = items
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "care_check":
        ret_json = {}
        self.response.content_type = "application/json"

        note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "welfare"
            )
        )
        ret_json["care"] = (not note is None)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "bug_fixxx":
        items_to_save = []
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.customer_state == "UT",
                FieldApplicationEntry.utility_provider == ""
            )

        )
        for a in app_entries:
            a.utility_provider = "rocky_mountain_power"
            items_to_save.append(a)

        if len(items_to_save) == 1:
            items_to_save[0].put()
        else:
            ndb.put_multi(items_to_save)

    elif self.request.get("fn") == "search_customers_for_reassignment":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))

        for result in results:
            result_item = {}
            for field in result.fields:
                if field.name == "cust_identifier":
                    result_item["identifier"] = field.value
                elif field.name == "cust_name":
                    result_item["name"] = field.value

            keys = result_item.keys()
            if "identifier" in keys and "name" in keys:
                ret_json["results"].append(result_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "reassign_customer":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        identifier = self.request.get("identifier")
        rep_email = ""
        rep_phone = ""
        rep_id = self.request.get("rep_id")
        rep_identifier = ""
        rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == rep_id)
        
        if not rep is None:
            if 5 == 5:
                rep_email = rep.rep_email
                rep_phone = rep.rep_phone
                rep_identifier = rep.identifier

                solar_readers = SolarReader.query(SolarReader.field_app_identifier == identifier)
                for reader in solar_readers:
                    reader.rep_ownership = rep_identifier
                    reader.put()

                cnt = 0
                atts_list = [{"keys": ["rep_id", "rep_email", "rep_phone"], "values": [rep_id, rep_email, rep_phone]}, {"keys": ["associated_rep_id"], "values": [rep_id]}, {"keys": ["rep_identifier"], "values": [rep_identifier]}, {"keys": ["rep_identifier"], "values": [rep_identifier]}, {"keys": ["rep_identifier"], "values": [rep_identifier]}]
                items_to_put = []
                for entity in [FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier),
                    SurveyBooking.first(SurveyBooking.field_app_identifier == identifier),
                    PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier),
                    PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == identifier),
                    PerfectPacketApproval.first(PerfectPacketApproval.field_application_identifier == identifier)]:

                    if not entity is None:
                        atts_item = atts_list[cnt]
                        cnt2 = 0
                        keys = atts_item["keys"]
                        for key in keys:
                            setattr(entity, key, atts_item["values"][cnt2])
                            cnt2 += 1

                        items_to_put.append(entity)

                    cnt += 1
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
                lead = Lead.first(Lead.field_app_identifier == identifier)
                if not lead is None:
                    lead.rep_identifier = rep.identifier
                    items_to_put.append(lead)
                    
                    if not app_entry is None:                        
                        url = Helpers.shorten_url("https://" + app_identity.get_application_id() + ".appspot.com/rep?autoload=my_leads")
                        msg_sp = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                        if not msg_sp is None:
                            sp_name = msg_sp.first_name.strip().title() + " " + msg_sp.last_name.strip().title()
                            sp_phone = Helpers.format_phone_number(msg_sp.rep_phone)
                            msg = "New Lead: " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ", SP2 time is " + app_entry.sp_two_time.strftime("%m/%d/%Y %I:%M %p") + " Solar Pro: " + sp_name + ", " + sp_phone + "   \n\n" + url
                            if not str(self.request.get("skip_text")) == "1":
                                Helpers.send_sms(rep.rep_phone, msg)

                if not app_entry is None:
                    ev = CalendarEvent.first(
                        ndb.AND(
                            CalendarEvent.event_key == "sp2",
                            CalendarEvent.field_app_identifier == app_entry.identifier
                        )
                    )
                    if not ev is None:
                        ev.calendar_key = rep.identifier
                        ev.put()

                if len(items_to_put) == 1:
                    items_to_put[0].put()
                elif len(items_to_put) > 1:
                    ndb.put_multi(items_to_put)

                if not app_entry is None:
                    if not app_entry.lead_generator == "-1":                        
                        stat9 = LeaderBoardStat.first(
                            ndb.AND(
                                LeaderBoardStat.metric_key == "leads_assigned",
                                LeaderBoardStat.field_app_identifier == identifier
                            )
                        )
                        if stat9 is None:
                            stat9 = LeaderBoardStat(
                                identifier=Helpers.guid(),
                                rep_id=rep_id,
                                metric_key="leads_assigned",
                                office_identifier=rep.main_office,
                                field_app_identifier=app_entry.identifier,
                                in_bounds=True,
                                pin_identifier="-1"
                            )

                        stat9.rep_id = rep_id
                        stat9.dt = Helpers.pacific_now()
                        stat9.put()

                ret_json["success"] = True
            else:
                ret_json = ret_json

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_customer_usage":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            try:
                app_entry.total_kwhs = float(self.request.get("new_total_kwhs"))
                app_entry.total_dollars = float(self.request.get("new_total_dollars"))
                app_entry.highest_amount = float(self.request.get("new_highest_amount"))
                app_entry.usage_info_available = True
                app_entry.usage_months = int(self.request.get("new_usage_months"))
                app_entry.usage_data = self.request.get("new_usage_data")
                app_entry.put()
                
                usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "usage_info_updated")
            except:
                app_entry = app_entry

    elif self.request.get("fn") == "view_deleted_booking":
        identifier = self.request.get("identifier")
        deleted_bookings = DeletedSurveyBooking.first(DeletedSurveyBooking.year == Helpers.pacific_today().year)
        for booking in deleted_bookings.bookings:
            if booking.identifier == identifier:
                logging.info(booking)

    elif self.request.get("fn") == "prep_customer_for_proposal_submission":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.hide_from_recent_view = True
            app_entry.proposal_state = 1
            app_entry.put()

    elif self.request.get("fn") == "remove_from_proposal_tabs":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.proposal_state = 0
            app_entry.put()

            try:
                Helpers.send_sms(app_entry.rep_phone, "At this time, the proposal for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " could not be completed because: " + self.request.get("reason") + ". If you can't resolve this, please reschedule with the customer.")
            except:
                app_entry = app_entry

            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                req_action = RepRequiredAction(
                    identifier=Helpers.guid(),
                    rep_identifier=rep.identifier,
                    field_app_identifier=app_entry.identifier,
                    action_key="proposal_incomplete",
                    message=json.dumps({"required_action": "The proposal for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " could not be completed. Reason given: " + self.request.get("reason")}),
                    created=Helpers.pacific_now(),
                    completed=datetime(1970, 1, 1)
                )
                req_action.put()
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="proposal_incomplete_" + app_entry.identifier,
                val=self.request.get("reason"),
                expiration=datetime(1970, 1, 1)
            )
            kv_item.put()

    elif self.request.get("fn") == "survey_file_upload":
        file_content = self.request.POST.multi['image'].file.read()
        pic_name = self.request.params["image"].filename.lower()
        pic_mime = self.request.POST['image'].type
        pic_ext = "jpg"
        if "png" in pic_mime.lower():
            pic_ext = "png"

        bucket_name = os.environ.get('BUCKET_NAME',
                                app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/SurveyDetails/' + self.request.get("identifier") + "/" + self.request.get("name") + "." + pic_ext

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(filename,
                            'w',
                            content_type=pic_mime,
                            options={'x-goog-meta-foo': 'foo',
                                    'x-goog-meta-bar': 'bar',
                                    'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)
        gcs_file.write(file_content)
        gcs_file.close()        
        
        root_folder = ThirdPartyFolder.first(
            ndb.AND(
                ThirdPartyFolder.field_app_identifier == self.request.get("identifier"),
                ThirdPartyFolder.folder_key == "root_folder"
            )
        )
        if not root_folder is None:

            folder = ThirdPartyFolder.first(
                ndb.AND(
                    ThirdPartyFolder.field_app_identifier == self.request.get("identifier"),
                    ThirdPartyFolder.folder_key == "survey_details"
                )
            )
            drive_folder_id = None
            if folder is None:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
                if not app_entry is None:
                    drive_folder_id = Helpers.create_customer_folder_in_google_drive(app_entry, root_folder.foreign_id, "Survey Details", "survey_details")
            else:
                drive_folder_id = folder.foreign_id

            if not drive_folder_id is None:
                file_content_b64 = base64.b64encode(file_content)
                Helpers.create_file_in_google_drive(drive_folder_id, self.request.get("name") + "." + pic_ext, file_content_b64, pic_mime)

    elif self.request.get("fn") == "get_pending_proposals":
        self.response.content_type = "application/json"
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.proposal_state == 1)
        ret_json = {}
        ret_json["results"] = []
        ret_json["funds"] = Helpers.list_funds()

        app_identifier_idx_dict = {}
        app_ids_to_query = ["-1"]
        for app_entry in app_entries:
            if app_entry.archived or app_entry.save_me:
                continue

            item = {}
            item["identifier"] = app_entry.identifier
            item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["insert_time"] = app_entry.insert_time
            item["sp_two_time"] = app_entry.sp_two_time

            app_identifier_idx_dict[app_entry.identifier] = len(ret_json["results"])
            app_ids_to_query.append(app_entry.identifier)
            ret_json["results"].append(item)

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query))
        for booking in bookings:
            ret_json["results"][app_identifier_idx_dict[booking.field_app_identifier]]["fund"] = booking.fund
            ret_json["results"][app_identifier_idx_dict[booking.field_app_identifier]]["booking_identifier"] = booking.identifier
            ret_json["results"][app_identifier_idx_dict[booking.field_app_identifier]]["funding_tier"] = booking.funding_tier

        ret_json["results"] = Helpers.bubble_sort(ret_json["results"], "sp_two_time")
        for item in ret_json["results"]:
            item["sp_two_time"] = str(item["sp_two_time"])
        ret_json["system_options"] = Helpers.read_setting("system_options")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "old_customer_proposal_search":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []

        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))

        field_app_identifier_idx_dict = {}
        field_app_ids_to_query = ["-1"]

        for result in results:
            result_item = {}
            for field in result.fields:
                if field.name == "cust_identifier":
                    field_app_ids_to_query.append(field.value)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
        booking_ids_to_query = ["-1"]
        identifier_idx_dict = {}

        for app_entry in app_entries:
            if app_entry.archived or app_entry.save_me:
                continue

            item = {}
            item["identifier"] = app_entry.identifier
            item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["insert_time"] = app_entry.insert_time

            identifier_idx_dict[item["identifier"]] = len(ret_json["results"])
            booking_ids_to_query.append(item["identifier"])
            ret_json["results"].append(item)

        credit_checks_to_query = ["-1"]
        item_idx_identifier_dict = {}
        cnt = 0
        for item in ret_json["results"]:
            credit_checks_to_query.append(item["identifier"])
            item_idx_identifier_dict[item["identifier"]] = cnt
            cnt += 1

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(booking_ids_to_query))
        for booking in bookings:
            idx = identifier_idx_dict[booking.field_app_identifier]
            ret_json["results"][idx]["fund"] = booking.fund
            ret_json["results"][idx]["booking_identifier"] = booking.identifier
            ret_json["results"][idx]["funding_tier"] = booking.funding_tier

        #checks = CreditCheck.query(CreditCheck.field_app_identifier.IN(credit_checks_to_query))
        #for check in checks:
        #    idx = item_idx_identifier_dict[check.field_app_identifier]
        #    last_four = str(check.last_four)
        #    if check.last_four > 0:
        #        while len(last_four) < 4:
        #            last_four = "0" + last_four
        #    else:
        #        if check.last_four == -1:
        #            last_four = "Unknown"

        #    score = check.score
        #    if score <= 0:
        #        score = "Unknown"
        #    ret_json["results"][idx]["last_four"] = last_four
        #    ret_json["results"][idx]["score"] = str(score)

        ret_json["results"] = Helpers.bubble_sort(ret_json["results"], "insert_time")
        ret_json["system_options"] = Helpers.read_setting("system_options")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_customer_progress_item_date":
        identifier = self.request.get("identifier")
        new_date_vals = self.request.get("new_date").split("-")
        step_key = self.request.get("step_key")
        new_date = datetime(int(new_date_vals[2]), int(new_date_vals[0]), int(new_date_vals[1]))

        item = CustomerProgressItem.first(CustomerProgressItem.field_app_identifier == identifier)
        archive = CustomerProgressArchive.first(
            ndb.AND
            (
                CustomerProgressArchive.step_state == step_key,
                CustomerProgressArchive.field_app_identifier == identifier
            )
        )
        if not item is None:
            item.updated = new_date
            item.put()

        if not archive is None:
            archive.updated = new_date
            archive.put()

        now = Helpers.pacific_now()
        file1 = GCSLockedFile("/CustomerProgressCache/" + step_key + "_" + str(now.year) + "_" + str(now.month) + "_" + str(now.day) + ".json")
        json1 = file1.read()
        now2 = now + timedelta(hours=-1)
        file2 = GCSLockedFile("/CustomerProgressCache/" + step_key + "_" + str(now2.year) + "_" + str(now2.month) + "_" + str(now2.day) + ".json")
        json2 = file2.read()

        if not json1 is None:
            items1 = json.loads(json1)
            for item in items1:
                if item["field_app_identifier"] == identifier:
                    item["updated"] = {"year": new_date.year, "month": new_date.month, "day": new_date.day}

            file11 = GCSLockedFile("/CustomerProgressCache/" + step_key + "_" + str(now.year) + "_" + str(now.month) + "_" + str(now.day) + ".json")
            file11.write(json.dumps(items1), "text/plain", "public-read")

        if not json2 is None:
            items2 = json.loads(json2)
            for item in items2:
                if item["field_app_identifier"] == identifier:
                    item["updated"] = {"year": new_date.year, "month": new_date.month, "day": new_date.day}

            file22 = GCSLockedFile("/CustomerProgressCache/" + step_key + "_" + str(now.year) + "_" + str(now.month) + "_" + str(now.day) + ".json")
            file22.write(json.dumps(items2), "text/plain", "public-read")

        self.response.out.write("  ")

    elif self.request.get("fn") == "generate_proposal":
        import StringIO
        from PIL import Image, ImageDraw, ImageFont
        from io import BytesIO

        from fpdf import FPDF
        from PyPDF2 import PdfFileWriter,PdfFileReader
        from google.appengine.api import app_identity

        identifier = self.request.get("identifier")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        proposal_info = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == app_entry.identifier)

        if not proposal_info is None:
            proposal_info.fix_additional_amount()
        booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)

        if (not app_entry is None) and (not booking is None):
            if not proposal_info is None:
                proposal_dict = json.loads(proposal_info.info)

                if "panel_type" in proposal_dict.keys() and "new_panel_qty" in proposal_dict.keys() and "panel_qty_override" in proposal_dict.keys():
                    if "[[[" in proposal_dict["panel_type"]:
                        wattage = proposal_dict["panel_type"][proposal_dict["panel_type"].index("[[["):]
                        wattage = wattage.replace("[[[", "").replace("]]]", "")
                        wattage = float(wattage)

                        new_ss = wattage * float(proposal_dict["new_panel_qty"])
                        new_ss /= float(1000)
                        proposal_dict["system_size"] = str(new_ss)


                if "panel_type" in proposal_dict.keys():
                    if "[[[" in proposal_dict["panel_type"]:
                        proposal_dict["panel_type"] = proposal_dict["panel_type"][0:proposal_dict["panel_type"].index("[[[")]                    

                proposal_keys = proposal_dict.keys()
                proposal_info.info = json.dumps(proposal_dict)
            else:
                proposal_dict = {}
            if "system_size" in proposal_keys and "cad_photo" in proposal_keys and "offset" in proposal_keys:
                if str(self.request.get("doc_option")) == "internal":

                    pdf = FPDF('P', 'in', 'Letter')
                    pdf.add_page()
                    pdf.set_font('Arial', 'B', 18.0)
                    pdf.cell(7.5, 1.0, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s Numbers", 0, 0, "C")
                    pdf.ln(1.0)

                    #build the text content of the numbers...
                    formulas = Helpers.read_setting("proposal_formulas")
                    keyys = []
                    for formula in formulas.keys():
                        keyys.append("expose_to_rep_" + formula)

                    kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keyys))
                    for item in kv_items:
                        f_name = item.keyy.replace("expose_to_rep_", "")
                        compiled_formula = Helpers.compile_formula(f_name)
                        if not compiled_formula is None:
                            number = str(round(compiled_formula["fn"](app_entry, booking, proposal_dict), 2))

                            pdf.set_x(1.0)
                            pdf.set_font('Arial', 'B', 16)
                            pdf.cell(6.0, 0.15, f_name.replace("_", " "), 0, 0)
                            pdf.set_font('Arial', '', 14)
                            pdf.write(0.15, number)
                            pdf.ln(0.5)

                    buff = StringIO.StringIO()
                    buff.write(pdf.output('', 'S'))
                    buff.seek(2)

                    self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Numbers_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                    self.response.content_type = "application/pdf"
                    self.response.out.write(buff.getvalue())

                    buff.close()

                elif str(self.request.get("doc_option")) == "proposal_v2":
                    rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                    if not rep is None:
                        existing_pp_entry = PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == app_entry.identifier)
                        if existing_pp_entry is None:
                            pp_entry = PerfectPacketEntry(
                                identifier=Helpers.guid(),
                                booking_identifier=booking.identifier,
                                field_application_identifier=app_entry.identifier,
                                surveyor_identifier=FieldApplicationUser.first(FieldApplicationUser.user_type == "survey").identifier,
                                surveyor_completion_state=1,
                                surveyor_completion_date=Helpers.pacific_now(),
                                rep_identifier=rep.identifier,
                                rep_completion_state=0,
                                rep_completion_date=datetime(1970, 1, 1),
                                outstanding_items=json.dumps([]),
                                created=Helpers.pacific_now(),
                                archived=False,
                                save_me=False
                            )
                            pp_entry.put()


                    formulaz = Helpers.read_setting("proposal_formulas")
                    ###
                    ###
                    ###
                    ###
                    
                    

                    
                    funds = Helpers.list_funds()
                    use_uploaded_pdf = False
                    for fund in funds:
                        if fund["value"] == booking.fund:
                            if "requires_proposal" in fund.keys():
                                use_uploaded_pdf = fund["requires_proposal"]

                    if not use_uploaded_pdf:

                        token = hashlib.md5(Helpers.guid()).hexdigest()
                        docs = ComposedDocument.query(ComposedDocument.bundle_key == "customer_proposals")
                        doc_items = []
                        for doc in docs:
                            doc_items.append(doc)

                        doc_items = Helpers.bubble_sort(doc_items, "idx")

                        qualified_documents = []
                        qualified_tokens = []
                        app_entry_ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                        market_ol = None
                        if not app_entry_ol is None:
                            market_ol = OfficeLocation.first(OfficeLocation.identifier == app_entry_ol.parent_identifier)

                        for doc in doc_items:
                            fn = Helpers.compile_document_formula(json.loads(doc.criteria)["formula"])
                            if (app_entry.customer_state == "UT") and (app_entry.customer_postal[0] == "7"):
                                app_entry.customer_state = "TX"
                            if fn["fn"](app_entry, booking, proposal_info, market_ol):
                                qualified_documents.append(doc.identifier)
                                qualified_tokens.append(doc.token)
                                Helpers.populate_document_v2("", "", doc, app_entry, booking, proposal_info, token, rep, "", "")

                        time.sleep(5)
                        final_bytes = []
                        final_pdfs = []
                        for doc_token in qualified_tokens:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/TempDocs/" + token + "_" + doc_token + ".pdf"
                            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                max_delay=5.0,
                                backoff_factor=2,
                                max_retry_period=15,
                                urlfetch_timeout=30)

                            fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                            final_bytes.append(BytesIO(fyle.read()))
                            final_pdfs.append(PdfFileReader(final_bytes[len(final_bytes) - 1], False))
                            fyle.close()

                        out_pdf = PdfFileWriter()
                        for final_pdf in final_pdfs:
                            page_cnt = 0
                            page_total = final_pdf.getNumPages()
                            while page_cnt < page_total:
                                out_pdf.addPage(final_pdf.getPage(page_cnt))
                                page_cnt += 1

                        final_buff = StringIO.StringIO()
                        out_pdf.write(final_buff)
                        final_buff.seek(2)


                        
                        for item in final_bytes:
                            item.close()
                    else:
                        final_bytes = []
                        final_pdfs = []
                        final_buff = StringIO.StringIO()

                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        filename = bucket + "/ProposalBlobs/" + booking.field_app_identifier + "_fund_proposal.pdf"
                        retryParameters = gcs.RetryParams(initial_delay=0.2,
                            max_delay=5.0,
                            backoff_factor=2,
                            max_retry_period=15,
                            urlfetch_timeout=30)

                        fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                        final_bytes.append(BytesIO(fyle.read()))
                        final_pdfs.append(PdfFileReader(final_bytes[len(final_bytes) - 1], False))
                        fyle.close()

                        out_pdf = PdfFileWriter()
                        for final_pdf in final_pdfs:
                            page_cnt = 0
                            page_total = final_pdf.getNumPages()
                            while page_cnt < page_total:
                                out_pdf.addPage(final_pdf.getPage(page_cnt))
                                page_cnt += 1

                        final_buff = StringIO.StringIO()
                        out_pdf.write(final_buff)
                        final_buff.seek(2)


                        for item in final_bytes:
                            item.close()

                    self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Proposal_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                    self.response.content_type = "application/pdf"
                    self.response.out.write(final_buff.getvalue())
                    final_buff.close()
                    return
                    
                    
                    
                    ###
                    ###
                    ###
                    if app_entry.customer_state == "CA":
                        page_1_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_1")))
                        page1_img = Image.open(page_1_bytes)
                        cover_font1 = ImageFont.truetype("Lato-Regular.ttf", 68)
                        cover_font2 = ImageFont.truetype("Lato-Light.ttf", 48)
                        cover_font3 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 62)
                        page2_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)
                        page3_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 52)
                        page3_font2 = ImageFont.truetype("Lato-Medium.ttf", 57)
                        cover_font4 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)

                        name_image = Image.new("RGBA", (900,90), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image)
                        draw.text((5, 0), app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), (12,134,193), font=cover_font1)
                        page1_img.paste(name_image, (800, 2220), name_image)

                        name_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image2)
                        draw.text((5, 0), app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), (93, 106, 113), font=cover_font2)
                        page1_img.paste(name_image2, (798, 2470), name_image2)

                        address_image = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image)
                        txt1 = app_entry.customer_address.strip().split(" ")
                        new_items = []
                        for component in txt1:
                            new_items.append(component.strip().title())
                        txt1 = " ".join(new_items)

                        draw.text((5, 0), txt1, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image, (799, 2530), address_image)

                        address_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image2)
                        txt2 = app_entry.customer_city.strip().title()
                        txt2 += ", " + app_entry.customer_state
                        txt2 += " " + app_entry.customer_postal
                        new_items2 = []
                        for component in txt2.split(" "):
                            if component in ["CA", "UT", "TX", "CO"]:
                                new_items2.append(component.strip())
                            else:
                                new_items2.append(component.strip().title())
                        txt2 = " ".join(new_items2)

                        draw.text((5, 0), txt2, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image2, (799, 2590), address_image2)

                        pricing_structures = Helpers.get_pricing_structures()
                        ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                        funds = Helpers.list_funds()
                        if not ol is None:
                            market_identifier = ol.parent_identifier  
                        
                        avg_kwh_cost = Helpers.crunch("fx_Avg_Cost_Per_Kwh_Over_30_Years", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

                        kwh_price_estimation_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(kwh_price_estimation_image)

                        draw.text((5, 0), str(round(avg_kwh_cost * 100.0, 1)), (255, 255, 255), font=cover_font3)
                        page1_img.paste(kwh_price_estimation_image, (230, 2776), kwh_price_estimation_image)

                        escalator_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(escalator_image)
                        draw.text((5, 0), "0%", (255, 255, 255), font=cover_font3)
                        page1_img.paste(escalator_image, (845, 2781), escalator_image)

                        buff = StringIO.StringIO()
                        page1_img.save(buff, "PDF", resolution=100.0, quality=100.0)
                        buff.seek(2)

                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + identifier + "_1.pdf"
                        gcs_file = gcs.open(
                                    filename,
                                    'w',
                                    content_type="application/pdf",
                                    options={'x-goog-meta-foo': 'foo',
                                                'x-goog-meta-bar': 'bar',
                                                'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params
                        )
                        gcs_file.write(buff.getvalue())
                        gcs_file.close()
                        page_1_bytes.close()
                        buff.close()

                        page_2_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_2")))
                        page2_img = Image.open(page_2_bytes)

                        highest_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(highest_bill_image)
                        draw.text((5, 0), Helpers.currency_format(app_entry.highest_amount), (247, 150, 33), font=page2_font1)
                        page2_img.paste(highest_bill_image, (270 + Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(app_entry.highest_amount), 400), 1030), highest_bill_image)

                        avg_bill_amount = Helpers.crunch("fx_Average_Bill_W_Utility", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)                                                
                        average_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(average_bill_image)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(avg_bill_amount), 265)
                        draw.text((5, 0), Helpers.currency_format(avg_bill_amount), (247, 150, 33), font=page2_font1)
                        page2_img.paste(average_bill_image, (836 + l_off, 1030), average_bill_image)

                        estimated_bill_amt = Helpers.crunch("fx_Utility_Bill_In_30_Years", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        estimated_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(estimated_bill_image)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(estimated_bill_amt), 400)
                        draw.text((5, 0), Helpers.currency_format(estimated_bill_amt), (247, 150, 33), font=page2_font1)
                        page2_img.paste(estimated_bill_image, (1300 + l_off, 1030), estimated_bill_image)

                        thirty_year_cost_amt = Helpers.crunch("fx_30_Year_Utility_Cost", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

                        thirty_year_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(thirty_year_image)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(thirty_year_cost_amt), 300)
                        draw.text((5, 0), Helpers.currency_format(thirty_year_cost_amt), (247, 150, 33), font=page2_font1)
                        page2_img.paste(thirty_year_image, (1785 + l_off, 1030), thirty_year_image)

                        buff2 = StringIO.StringIO()

                        page2_img.save(buff2, "PDF", resolution=100.0, quality=100.0)
                        buff2.seek(2)

                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + identifier + "_2.pdf"
                        gcs_file = gcs.open(
                                    filename,
                                     'w',
                                    content_type="application/pdf",
                                    options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params
                        )
                        gcs_file.write(buff2.getvalue())
                        gcs_file.close()
                        buff2.close()
                        page_2_bytes.close()
                        
                        page3_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_3")))
                        page3_img = Image.open(page3_bytes)

                        new_bill_amt = Helpers.crunch("fx_Solar_Bill_After_Promo", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        new_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(new_bill_image)
                        draw.text((5, 0), Helpers.currency_format(new_bill_amt), (247, 150, 33), font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(new_bill_amt))
                        page3_img.paste(new_bill_image, (2200 - l_off, 745), new_bill_image)


                        months = Helpers.crunch("fx_Promo_Length_In_Months", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        n_months = Image.new("RGBA", (2000, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(n_months)
                        draw.text((5, 0), "First " + str(int(months)) + " months promotional bill", (22, 135, 195), font=page3_font2)
                        page3_img.paste(n_months, (330, 930), n_months)

                        promo_amt = Helpers.crunch("fx_Promo_Bill", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        promo_months_bill = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(promo_amt))
                        draw = ImageDraw.Draw(promo_months_bill)
                        draw.text((5, 0), Helpers.currency_format(promo_amt), (247, 150, 33), font=page3_font1)
                        page3_img.paste(promo_months_bill, (2200 - l_off, 925), promo_months_bill)

                        year_one_amt = Helpers.crunch("fx_Year_1_Savings", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        year_one_savings = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(year_one_savings)
                        draw.text((5, 0), Helpers.currency_format(year_one_amt), (247, 150, 33), font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(year_one_amt))
                        page3_img.paste(year_one_savings, (2200 - l_off, 1105), year_one_savings)

                        thirty_year_amt = Helpers.crunch("fx_30_Year_Savings", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        thirty_year_saving_img = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(thirty_year_amt))
                        draw = ImageDraw.Draw(thirty_year_saving_img)
                        draw.text((5, 0), Helpers.currency_format(thirty_year_amt), (247, 150, 33), font=page3_font1)
                        page3_img.paste(thirty_year_saving_img, (2200 - l_off, 1285), thirty_year_saving_img)

                        avg_savings_amt = Helpers.crunch("fx_Per_Year_Avg_Savings", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        avg_savings_thirty = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(avg_savings_amt))
                        draw = ImageDraw.Draw(avg_savings_thirty)
                        draw.text((5, 0), Helpers.currency_format(avg_savings_amt), (247, 150, 33), font=page3_font1)
                        page3_img.paste(avg_savings_thirty, (2200 - l_off, 1465), avg_savings_thirty)

                        payment_escalator_img = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(payment_escalator_img)
                        draw.text((5, 0), "0%", (247, 150, 33), font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1, "0%")
                        page3_img.paste(payment_escalator_img, (2200 - l_off, 1645), payment_escalator_img)

                        bucket_name = os.environ.get('BUCKET_NAME',
                            app_identity.get_default_gcs_bucket_name())

                        bucket = '/' + bucket_name
                        filename = bucket + '/ProposalBlobs/' + app_entry.identifier + "_cad_photo." + proposal_dict["cad_photo"]["extension"]

                        retryParameters = gcs.RetryParams(initial_delay=0.2,
                            max_delay=5.0,
                            backoff_factor=2,
                            max_retry_period=15,
                            urlfetch_timeout=30)

                        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
                        cad_stream = BytesIO(gcs_file.read())
                        gcs_file.close()


                        buff22 = StringIO.StringIO()
                        cad_image = Image.open(cad_stream)
                        cad_image = cad_image.resize((910, 682), Image.ANTIALIAS)
                        cad_image.save(buff22, "JPEG")
                        buff22.seek(2)


                        cpy = Image.new("RGBA", cad_image.size, (255, 255, 255, 0))
                        width = cpy.size[0]
                        height = cpy.size[1]

                        w_cnt = 0
                        while w_cnt < width:
                            h_cnt = 0
                            while h_cnt < height:
                                pixel_data = cad_image.getpixel((w_cnt, h_cnt))
                                cpy.putpixel((w_cnt, h_cnt), pixel_data)
                                h_cnt += 1
                            w_cnt += 1

                        page3_img.paste(cpy, (1450, 2145), cpy)

                        buff3 = StringIO.StringIO()
                        page3_img.save(buff3, "PDF", resolution=100.0, quality=100.0)
                        buff3.seek(2)

                        ###
                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + identifier + "_3.pdf"
                        gcs_file = gcs.open(
                                    filename,
                                     'w',
                                    content_type="application/pdf",
                                    options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params
                        )
                        gcs_file.write(buff3.getvalue())
                        gcs_file.close()
                        buff3.close()
                        page3_bytes.close()
                        buff22.close()
                        cad_stream.close()

                        for item in [4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/" + app_entry.customer_state.upper() + "/" + str(item) + ".jpg"

                            fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                            f_bytes = BytesIO(fyle.read())
                            img_4 = Image.open(f_bytes)
                            buff44 = StringIO.StringIO()
                            img_4.save(buff44, "PDF", resolution=100.0, quality=100.0)
                            buff44.seek(2)

                            write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                            filename2 = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            fyle2 = gcs.open(
                                        filename2,
                                        'w',
                                        content_type="application/pdf",
                                        options={'x-goog-meta-foo': 'foo',
                                                'x-goog-meta-bar': 'bar',
                                                'x-goog-acl': 'public-read'},
                                        retry_params=write_retry_params
                            )
                            fyle2.write(buff44.getvalue())
                            fyle2.close()
                            fyle.close()
                            f_bytes.close()
                            buff44.close()

                        final_buffs = []
                        final_bytes = []
                        final_pdfs = []
                        for item in [1, 2, 3, 4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                max_delay=5.0,
                                backoff_factor=2,
                                max_retry_period=15,
                                urlfetch_timeout=30)

                            fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                            final_bytes.append(BytesIO(fyle.read()))
                            final_pdfs.append(PdfFileReader(final_bytes[len(final_bytes) - 1], False))

                        out_pdf = PdfFileWriter()
                        for final_pdf in final_pdfs:
                            out_pdf.addPage(final_pdf.getPage(0))

                        final_buff = StringIO.StringIO()
                        out_pdf.write(final_buff)
                        final_buff.seek(2)


                        for item in final_buffs:
                            item.close()
                        for item in final_bytes:
                            item.close()
                        for item in [1, 2, 3, 4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            gcs.delete(filename)

                        self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Proposal_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                        self.response.content_type = "application/pdf"
                        self.response.out.write(final_buff.getvalue())
                        final_buff.close()
                        return

                    else:
                        state = app_entry.customer_state

                        page_1_bytes = BytesIO(
                            base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_1")))
                        
                        page1_img = Image.open(page_1_bytes)
                        cover_font1 = ImageFont.truetype("Lato-Regular.ttf", 68)
                        cover_font2 = ImageFont.truetype("Lato-Light.ttf", 48)
                        cover_font3 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 62)
                        page2_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)
                        page3_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 52)
                        page3_font2 = ImageFont.truetype("Lato-Medium.ttf", 57)
                        cover_font4 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)

                        name_image = Image.new("RGBA", (900, 90), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image)
                        draw.text((5, 0),
                                  app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(),
                                  (12, 134, 193), font=cover_font1)
                        page1_img.paste(name_image, (800, 2220), name_image)

                        name_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image2)
                        draw.text((5, 0),
                                  app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(),
                                  (93, 106, 113), font=cover_font2)
                        page1_img.paste(name_image2, (798, 2470), name_image2)

                        address_image = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image)
                        txt1 = app_entry.customer_address.strip().split(" ")
                        new_items = []
                        for component in txt1:
                            new_items.append(component.strip().title())
                        txt1 = " ".join(new_items)

                        draw.text((5, 0), txt1, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image, (799, 2530), address_image)

                        address_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image2)
                        txt2 = app_entry.customer_city.strip().title()
                        txt2 += ", " + state
                        txt2 += " " + app_entry.customer_postal
                        new_items2 = []
                        for component in txt2.split(" "):
                            if component in ["CA", "UT", "TX", "CO"]:
                                new_items2.append(component.strip())
                            else:
                                new_items2.append(component.strip().title())
                        txt2 = " ".join(new_items2)

                        draw.text((5, 0), txt2, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image2, (799, 2590), address_image2)

                        pricing_structures = Helpers.get_pricing_structures()
                        ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                        funds = Helpers.list_funds()
                        if not ol is None:
                            market_identifier = ol.parent_identifier

                        kwh_amount = Helpers.crunch("fx_Avg_Cost_Per_Kwh_Over_30_Years", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        kwh_price_estimation_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(kwh_price_estimation_image)

                        draw.text((5, 0),
                                    str(round(kwh_amount * 100.0, 1)),
                                    (255, 255, 255), font=cover_font3)
                        page1_img.paste(kwh_price_estimation_image, (230, 2776), kwh_price_estimation_image)

                        escalator_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(escalator_image)
                        draw.text((5, 0), "0%", (255, 255, 255), font=cover_font3)
                        #page1_img.paste(escalator_image, (845, 2781), escalator_image)

                        prod_str = Helpers.currency_format(int(float(proposal_dict["year_one_production"]))).replace("$", "")
                        if "." in prod_str:
                            prod_str = prod_str[0:prod_str.index(".")]

                        estimated_kwh_output_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(estimated_kwh_output_image)
                        draw.text((5, 0), prod_str, (255, 255, 255), font=cover_font4)
                        page1_img.paste(estimated_kwh_output_image, (190, 2940), estimated_kwh_output_image)

                        buff = StringIO.StringIO()
                        page1_img.save(buff, "PDF", resolution=100.0, quality=100.0)
                        buff.seek(2)

                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_1.pdf"
                        gcs_file = gcs.open(
                         filename,
                         'w',
                         content_type="application/pdf",
                         options={'x-goog-meta-foo': 'foo',
                         'x-goog-meta-bar': 'bar',
                         'x-goog-acl': 'public-read'},
                         retry_params=write_retry_params
                        )
                        gcs_file.write(buff.getvalue())
                        gcs_file.close()
                        buff.close()
                        page_1_bytes.close()

                        page_2_bytes = BytesIO(
                                base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_2")))
                        page2_img = Image.open(page_2_bytes)

                        highest_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(highest_bill_image)
                        draw.text((5, 0), Helpers.currency_format(app_entry.highest_amount), (247, 150, 33),
                                    font=page2_font1)
                        page2_img.paste(highest_bill_image, (
                        270 + Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(
                            app_entry.highest_amount), 400), 1030), highest_bill_image)

                        avg_bill_amount = Helpers.crunch("fx_Average_Bill_W_Utility", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        average_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(average_bill_image)
                        # draw.text((5, 0), '$1576.94', (247, 150, 33), font=page2_font1)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1,
                                                                        Helpers.currency_format(avg_bill_amount),
                                                                        265)
                        draw.text((5, 0), Helpers.currency_format(avg_bill_amount), (247, 150, 33),
                                    font=page2_font1)
                        page2_img.paste(average_bill_image, (836 + l_off, 1030), average_bill_image)

                        estimated_bill_amt = Helpers.crunch("fx_Utility_Bill_In_30_Years", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        estimated_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(estimated_bill_image)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(
                            estimated_bill_amt), 400)
                        draw.text((5, 0), Helpers.currency_format(estimated_bill_amt), (247, 150, 33),
                                    font=page2_font1)
                        page2_img.paste(estimated_bill_image, (1300 + l_off, 1030), estimated_bill_image)

                        thirty_year_cost_amt = Helpers.crunch("fx_30_Year_Utility_Cost",  market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        thirty_year_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(thirty_year_image)
                        l_off = Helpers.get_centered_text_left_offset(page2_font1,
                                                                        Helpers.currency_format(
                                                                            thirty_year_cost_amt), 480)
                        draw.text((5, 0), Helpers.currency_format(thirty_year_cost_amt), (247, 150, 33),
                                    font=page2_font1)
                        page2_img.paste(thirty_year_image, (1796 + l_off, 1030), thirty_year_image)

                        buff2 = StringIO.StringIO()

                        page2_img.save(buff2, "PDF", resolution=100.0, quality=100.0)
                        buff2.seek(2)

                        bucket_name = os.environ.get('BUCKET_NAME',
                                                        app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_2.pdf"
                        gcs_file = gcs.open(
                         filename,
                         'w',
                         content_type="application/pdf",
                         options={'x-goog-meta-foo': 'foo',
                           'x-goog-meta-bar': 'bar',
                             'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params
                        )
                        gcs_file.write(buff2.getvalue())
                        gcs_file.close()
                        buff2.close()
                        page_2_bytes.close()

                        page3_bytes = BytesIO(base64.b64decode(
                            Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_3")))
                        page3_img = Image.open(page3_bytes)

                        sys_cost_amt = Helpers.crunch("fx_Total_System_Cost", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)                        
                        sys_cost_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(sys_cost_image)
                        draw.text((5, 0), Helpers.currency_format(sys_cost_amt), (247, 150, 33),
                                    font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(sys_cost_amt))
                        page3_img.paste(sys_cost_image, (2200 - l_off, 745), sys_cost_image)

                        fed_tax_amt = Helpers.crunch("fx_Federal_Tax_Credit", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

                        fed_tax_img = Image.new("RGBA", (2000, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(fed_tax_img)
                        draw.text((5, 0),
                                    Helpers.currency_format(fed_tax_amt),
                                    (247, 150, 33), font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(fed_tax_amt))
                        page3_img.paste(fed_tax_img, (2200 - l_off, 885), fed_tax_img)

                        state_tax_amt = Helpers.crunch("fx_State_Tax_Credit", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        state_tax_img = Image.new("RGBA", (900, 300),
                                                        (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(state_tax_amt))
                        draw = ImageDraw.Draw(state_tax_img)
                        draw.text((5, 0), Helpers.currency_format(state_tax_amt),
                                    (247, 150, 33), font=page3_font1)
                        page3_img.paste(state_tax_img, (2200 - l_off, 1025),
                                        state_tax_img)

                        after_formula_amt = Helpers.crunch("fx_Solar_Bill_After_Promo", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

                        after_formula_img = Image.new("RGBA", (900, 300),
                                                        (255, 255, 255, 0))
                        draw = ImageDraw.Draw(after_formula_img)
                        draw.text((5, 0), Helpers.currency_format(after_formula_amt),
                                    (247, 150, 33), font=page3_font1)
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(
                                                            after_formula_amt))
                        page3_img.paste(after_formula_img, (2200 - l_off, 1165),
                                        after_formula_img)

                        promo_amt = Helpers.crunch("fx_Promo_Bill", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        promo_img = Image.new("RGBA", (900, 300),
                                                            (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(
                                                            promo_amt))
                        draw = ImageDraw.Draw(promo_img)
                        draw.text((5, 0), Helpers.currency_format(promo_amt),
                                    (247, 150, 33), font=page3_font1)
                        page3_img.paste(promo_img,
                                        (2200 - l_off, 1305),
                                        promo_img)

                        thirty_year_savings_amt = Helpers.crunch("fx_30_Year_Savings", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)
                        thirty_year_savings_img = Image.new("RGBA", (900, 300),
                                                        (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(
                                                            thirty_year_savings_amt))
                        draw = ImageDraw.Draw(thirty_year_savings_img)
                        draw.text((5, 0),
                                    Helpers.currency_format(thirty_year_savings_amt),
                                    (247, 150, 33), font=page3_font1)
                        page3_img.paste(thirty_year_savings_img,
                                        (2200 - l_off, 1445),
                                        thirty_year_savings_img)

                        thirty_year_avg_amt = Helpers.crunch("fx_Per_Year_Avg_Savings", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

                        thirty_year_avg_img = Image.new("RGBA", (900, 300),
                                                            (255, 255, 255, 0))
                        l_off = Helpers.get_text_width(page3_font1,
                                                        Helpers.currency_format(
                                                            thirty_year_avg_amt))
                        draw = ImageDraw.Draw(thirty_year_avg_img)
                        draw.text((5, 0),
                                    Helpers.currency_format(thirty_year_avg_amt),
                                    (247, 150, 33), font=page3_font1)
                        page3_img.paste(thirty_year_avg_img,
                                        (2200 - l_off, 1585),
                                        thirty_year_avg_img)

                        bucket_name = os.environ.get('BUCKET_NAME',
                                                        app_identity.get_default_gcs_bucket_name())

                        bucket = '/' + bucket_name
                        filename = bucket + '/ProposalBlobs/' + app_entry.identifier + "_cad_photo." + \
                                    proposal_dict["cad_photo"]["extension"]

                        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                            max_delay=5.0,
                                                            backoff_factor=2,
                                                            max_retry_period=15,
                                                            urlfetch_timeout=30)

                        gcs_file = gcs.open(filename, 'r',
                                            retry_params=retryParameters)
                        cad_stream = BytesIO(gcs_file.read())
                        gcs_file.close()

                        buff22 = StringIO.StringIO()
                        cad_image = Image.open(cad_stream)
                        cad_image = cad_image.resize((910, 682),
                                                        Image.ANTIALIAS)
                        cad_image.save(buff22, "JPEG")
                        buff22.seek(2)

                        cpy = Image.new("RGBA", cad_image.size,
                                        (255, 255, 255, 0))
                        width = cpy.size[0]
                        height = cpy.size[1]

                        w_cnt = 0
                        while w_cnt < width:
                            h_cnt = 0
                            while h_cnt < height:
                                pixel_data = cad_image.getpixel((w_cnt, h_cnt))
                                cpy.putpixel((w_cnt, h_cnt), pixel_data)
                                h_cnt += 1
                            w_cnt += 1

                        page3_img.paste(cpy, (1450, 2145), cpy)

                        buff3 = StringIO.StringIO()
                        page3_img.save(buff3, "PDF", resolution=100.0, quality=100.0)
                        buff3.seek(2)

                        ###
                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                        bucket = '/' + bucket_name
                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                        filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_3.pdf"
                        gcs_file = gcs.open(
                                    filename,
                                     'w',
                                    content_type="application/pdf",
                                    options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params
                        )
                        gcs_file.write(buff3.getvalue())
                        gcs_file.close()
                        buff3.close()
                        page3_bytes.close()
                        buff22.close()
                        cad_stream.close()

                        for item in [4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/" + app_entry.customer_state.upper() + "/" + str(item) + ".jpg"

                            fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                            f_bytes = BytesIO(fyle.read())
                            img_4 = Image.open(f_bytes)
                            buff44 = StringIO.StringIO()
                            img_4.save(buff44, "PDF", resolution=100.0, quality=100.0)
                            buff44.seek(2)

                            write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                            filename2 = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            fyle2 = gcs.open(
                                        filename2,
                                        'w',
                                        content_type="application/pdf",
                                        options={'x-goog-meta-foo': 'foo',
                                                'x-goog-meta-bar': 'bar',
                                                'x-goog-acl': 'public-read'},
                                        retry_params=write_retry_params
                            )
                            fyle2.write(buff44.getvalue())
                            fyle2.close()
                            fyle.close()
                            f_bytes.close()
                            buff44.close()

                        final_buffs = []
                        final_bytes = []
                        final_pdfs = []
                        for item in [1, 2, 3, 4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            retryParameters = gcs.RetryParams(initial_delay=0.2,
                                max_delay=5.0,
                                backoff_factor=2,
                                max_retry_period=15,
                                urlfetch_timeout=30)

                            fyle = gcs.open(filename, 'r', retry_params=retryParameters)
                            final_bytes.append(BytesIO(fyle.read()))
                            final_pdfs.append(PdfFileReader(final_bytes[len(final_bytes) - 1], False))

                        out_pdf = PdfFileWriter()
                        for final_pdf in final_pdfs:
                            out_pdf.addPage(final_pdf.getPage(0))

                        final_buff = StringIO.StringIO()
                        out_pdf.write(final_buff)
                        final_buff.seek(2)


                        for item in final_buffs:
                            item.close()
                        for item in final_bytes:
                            item.close()
                        for item in [1, 2, 3, 4, 5, 6, 7, 8]:
                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            filename = bucket + "/Images/Proposal/Temp/" + app_entry.identifier + "_" + str(item) + ".pdf"
                            gcs.delete(filename)

                        self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Proposal_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                        self.response.content_type = "application/pdf"
                        self.response.out.write(final_buff.getvalue())
                        final_buff.close()                        

                        return;

                elif str(self.request.get("doc_option")) == "proposal":
                    rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                    if not rep is None:
                        existing_pp_entry = PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == app_entry.identifier)
                        if existing_pp_entry is None:
                            pp_entry = PerfectPacketEntry(
                                identifier=Helpers.guid(),
                                booking_identifier=booking.identifier,
                                field_application_identifier=app_entry.identifier,
                                surveyor_identifier=FieldApplicationUser.first(FieldApplicationUser.user_type == "survey").identifier,
                                surveyor_completion_state=1,
                                surveyor_completion_date=Helpers.pacific_now(),
                                rep_identifier=rep.identifier,
                                rep_completion_state=0,
                                rep_completion_date=datetime(1970, 1, 1),
                                outstanding_items=json.dumps([]),
                                created=Helpers.pacific_now(),
                                archived=False,
                                save_me=False
                            )
                            pp_entry.put()


                    formulaz = Helpers.read_setting("proposal_formulas")
                    if app_entry.customer_state == "CA":
                        page_1_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_1")))
                        page1_img = Image.open(page_1_bytes)
                        cover_font1 = ImageFont.truetype("Lato-Regular.ttf", 68)
                        cover_font2 = ImageFont.truetype("Lato-Light.ttf", 48)
                        cover_font3 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 62)
                        page2_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)
                        page3_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 52)
                        page3_font2 = ImageFont.truetype("Lato-Medium.ttf", 57)
                        cover_font4 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)

                        name_image = Image.new("RGBA", (900,90), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image)
                        draw.text((5, 0), app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), (12,134,193), font=cover_font1)
                        page1_img.paste(name_image, (800, 2220), name_image)

                        name_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image2)
                        draw.text((5, 0), app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), (93, 106, 113), font=cover_font2)
                        page1_img.paste(name_image2, (798, 2470), name_image2)

                        address_image = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image)
                        txt1 = app_entry.customer_address.strip().split(" ")
                        new_items = []
                        for component in txt1:
                            new_items.append(component.strip().title())
                        txt1 = " ".join(new_items)

                        draw.text((5, 0), txt1, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image, (799, 2530), address_image)

                        address_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image2)
                        txt2 = app_entry.customer_city.strip().title()
                        txt2 += ", " + app_entry.customer_state
                        txt2 += " " + app_entry.customer_postal
                        new_items2 = []
                        for component in txt2.split(" "):
                            if component in ["CA", "UT"]:
                                new_items2.append(component.strip())
                            else:
                                new_items2.append(component.strip().title())
                        txt2 = " ".join(new_items2)

                        draw.text((5, 0), txt2, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image2, (799, 2590), address_image2)

                        kwh_formula = Helpers.compile_formula("fx_Avg_Cost_Per_Kwh_Over_30_Years", formulaz)
                        if not kwh_formula is None:
                            kwh_price_estimation_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(kwh_price_estimation_image)

                            draw.text((5, 0), str(round(kwh_formula["fn"](app_entry, booking, proposal_dict) * 100.0, 1)), (255, 255, 255), font=cover_font3)
                            page1_img.paste(kwh_price_estimation_image, (230, 2776), kwh_price_estimation_image)

                            escalator_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(escalator_image)
                            draw.text((5, 0), "0%", (255, 255, 255), font=cover_font3)
                            page1_img.paste(escalator_image, (845, 2781), escalator_image)

                            buff = StringIO.StringIO()
                            page1_img.save(buff, "PDF", resolution=100.0, quality=100.0)
                            buff.seek(2)

                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                            filename = bucket + "/Images/Proposal/Temp/" + identifier + "_1.pdf"
                            #gcs_file = gcs.open(
                                        #filename,
                                        #'w',
                                        #content_type="application/pdf",
                                        #options={'x-goog-meta-foo': 'foo',
                                                 #'x-goog-meta-bar': 'bar',
                                                 #'x-goog-acl': 'public-read'},
                                        #retry_params=write_retry_params
                            #)
                            #gcs_file.write(buff.getvalue())
                            #gcs_file.close()
                            page1_pdf = PdfFileReader(buff, False)

                            #page_2_bytes = BytesIO(GCSLockedFile("/Images/Proposal/" + app_entry.customer_state + "/2.jpg").read())
                            page_2_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_2")))
                            page2_img = Image.open(page_2_bytes)

                            highest_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(highest_bill_image)
                            draw.text((5, 0), Helpers.currency_format(app_entry.highest_amount), (247, 150, 33), font=page2_font1)
                            page2_img.paste(highest_bill_image, (270 + Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(app_entry.highest_amount), 400), 1030), highest_bill_image)

                            average_bill_formula = Helpers.compile_formula("fx_Average_Bill_W_Utility", formulaz)
                            if not average_bill_formula is None:
                                avg_bill_amount = average_bill_formula["fn"](app_entry, booking, proposal_dict)
                                average_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                draw = ImageDraw.Draw(average_bill_image)
                                #draw.text((5, 0), '$1576.94', (247, 150, 33), font=page2_font1)
                                l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(avg_bill_amount), 265)
                                draw.text((5, 0), Helpers.currency_format(avg_bill_amount), (247, 150, 33), font=page2_font1)
                                page2_img.paste(average_bill_image, (836 + l_off, 1030), average_bill_image)

                                estimated_bill_formula = Helpers.compile_formula("fx_Utility_Bill_In_30_Years", formulaz)
                                if not estimated_bill_formula is None:
                                    estimated_bill_amt = estimated_bill_formula["fn"](app_entry, booking, proposal_dict)
                                    estimated_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                    draw = ImageDraw.Draw(estimated_bill_image)
                                    l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(estimated_bill_amt), 400)
                                    draw.text((5, 0), Helpers.currency_format(estimated_bill_amt), (247, 150, 33), font=page2_font1)
                                    page2_img.paste(estimated_bill_image, (1300 + l_off, 1030), estimated_bill_image)

                                    thirty_year_cost_formula = Helpers.compile_formula("fx_30_Year_Utility_Cost", formulaz)
                                    if not thirty_year_cost_formula is None:
                                        thirty_year_cost_amt = thirty_year_cost_formula["fn"](app_entry, booking, proposal_dict)
                                        thirty_year_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                        draw = ImageDraw.Draw(thirty_year_image)
                                        l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(thirty_year_cost_amt), 300)
                                        draw.text((5, 0), Helpers.currency_format(thirty_year_cost_amt), (247, 150, 33), font=page2_font1)
                                        page2_img.paste(thirty_year_image, (1785 + l_off, 1030), thirty_year_image)

                                        buff2 = StringIO.StringIO()

                                        page2_img.save(buff2, "PDF", resolution=100.0, quality=100.0)
                                        buff2.seek(2)

                                        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                                        bucket = '/' + bucket_name
                                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                                        filename = bucket + "/Images/Proposal/Temp/" + identifier + "_2.pdf"
                                        #gcs_file = gcs.open(
                                                    #filename,
                                                   # 'w',
                                                    #content_type="application/pdf",
                                                    #options={'x-goog-meta-foo': 'foo',
                                                          #   'x-goog-meta-bar': 'bar',
                                                        #     'x-goog-acl': 'public-read'},
                                                #    retry_params=write_retry_params
                                       # )
                                        #gcs_file.write(buff2.getvalue())
                                        #gcs_file.close()
                                        #buff2.close()
                                        #page_2_bytes.close()

                                        page2_pdf = PdfFileReader(buff2, False)


                                        new_bill_formula = Helpers.compile_formula("fx_Solar_Bill_After_Promo", formulaz)
                                        if not new_bill_formula is None:
                                            new_bill_amt = new_bill_formula["fn"](app_entry, booking, proposal_dict)
                                            #page3_bytes = BytesIO(GCSLockedFile("/Images/Proposal/" + app_entry.customer_state + "/3.jpg").read())
                                            page3_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_3")))
                                            page3_img = Image.open(page3_bytes)

                                            new_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                            draw = ImageDraw.Draw(new_bill_image)
                                            draw.text((5, 0), Helpers.currency_format(new_bill_amt), (247, 150, 33), font=page3_font1)
                                            l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(new_bill_amt))
                                            page3_img.paste(new_bill_image, (2200 - l_off, 745), new_bill_image)


                                            n_months_formula = Helpers.compile_formula("fx_Promo_Length_In_Months", formulaz)
                                            if not n_months_formula is None:
                                                months = n_months_formula["fn"](app_entry, booking, proposal_dict)
                                                n_months = Image.new("RGBA", (2000, 300), (255, 255, 255, 0))
                                                draw = ImageDraw.Draw(n_months)
                                                draw.text((5, 0), "First " + str(int(months)) + " months promotional bill", (22, 135, 195), font=page3_font2)
                                                page3_img.paste(n_months, (330, 930), n_months)

                                                promo_bill_formula = Helpers.compile_formula("fx_Promo_Bill", formulaz)
                                                if not promo_bill_formula is None:
                                                    promo_months_bill = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                                    promo_amt = promo_bill_formula["fn"](app_entry, booking, proposal_dict)
                                                    l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(promo_amt))
                                                    draw = ImageDraw.Draw(promo_months_bill)
                                                    draw.text((5, 0), Helpers.currency_format(promo_amt), (247, 150, 33), font=page3_font1)
                                                    page3_img.paste(promo_months_bill, (2200 - l_off, 925), promo_months_bill)

                                                    year_one_formula = Helpers.compile_formula("fx_Year_1_Savings", formulaz)
                                                    if not year_one_formula is None:
                                                        year_one_savings = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                                        year_one_amt = year_one_formula["fn"](app_entry, booking, proposal_dict)
                                                        draw = ImageDraw.Draw(year_one_savings)
                                                        draw.text((5, 0), Helpers.currency_format(year_one_amt), (247, 150, 33), font=page3_font1)
                                                        l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(year_one_amt))
                                                        page3_img.paste(year_one_savings, (2200 - l_off, 1105), year_one_savings)

                                                        thirty_year_savings_formula = Helpers.compile_formula("fx_30_Year_Savings", formulaz)
                                                        if not thirty_year_savings_formula is None:
                                                            thirty_year_amt = thirty_year_savings_formula["fn"](app_entry, booking, proposal_dict)
                                                            thirty_year_saving_img = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                                            l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(thirty_year_amt))
                                                            draw = ImageDraw.Draw(thirty_year_saving_img)
                                                            draw.text((5, 0), Helpers.currency_format(thirty_year_amt), (247, 150, 33), font=page3_font1)
                                                            page3_img.paste(thirty_year_saving_img, (2200 - l_off, 1285), thirty_year_saving_img)

                                                            avg_savings_formula = Helpers.compile_formula("fx_Per_Year_Avg_Savings", formulaz)
                                                            if not avg_savings_formula is None:
                                                                avg_savings_amt = avg_savings_formula["fn"](app_entry, booking, proposal_dict)
                                                                avg_savings_thirty = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                                                l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(avg_savings_amt))
                                                                draw = ImageDraw.Draw(avg_savings_thirty)
                                                                draw.text((5, 0), Helpers.currency_format(avg_savings_amt), (247, 150, 33), font=page3_font1)
                                                                page3_img.paste(avg_savings_thirty, (2200 - l_off, 1465), avg_savings_thirty)

                                                                payment_escalator_img = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                                                draw = ImageDraw.Draw(payment_escalator_img)
                                                                draw.text((5, 0), "0%", (247, 150, 33), font=page3_font1)
                                                                l_off = Helpers.get_text_width(page3_font1, "0%")
                                                                page3_img.paste(payment_escalator_img, (2200 - l_off, 1645), payment_escalator_img)

                                                                bucket_name = os.environ.get('BUCKET_NAME',
                                                                    app_identity.get_default_gcs_bucket_name())

                                                                bucket = '/' + bucket_name
                                                                filename = bucket + '/ProposalBlobs/' + app_entry.identifier + "_cad_photo." + proposal_dict["cad_photo"]["extension"]

                                                                retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                                    max_delay=5.0,
                                                                    backoff_factor=2,
                                                                    max_retry_period=15,
                                                                    urlfetch_timeout=30)

                                                                gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                cad_stream = BytesIO(gcs_file.read())
                                                                gcs_file.close()


                                                                buff22 = StringIO.StringIO()
                                                                cad_image = Image.open(cad_stream)
                                                                cad_image = cad_image.resize((910, 682), Image.ANTIALIAS)
                                                                cad_image.save(buff22, "JPEG")
                                                                buff22.seek(2)


                                                                cpy = Image.new("RGBA", cad_image.size, (255, 255, 255, 0))
                                                                width = cpy.size[0]
                                                                height = cpy.size[1]

                                                                w_cnt = 0
                                                                while w_cnt < width:
                                                                    h_cnt = 0
                                                                    while h_cnt < height:
                                                                        pixel_data = cad_image.getpixel((w_cnt, h_cnt))
                                                                        cpy.putpixel((w_cnt, h_cnt), pixel_data)
                                                                        h_cnt += 1
                                                                    w_cnt += 1

                                                                page3_img.paste(cpy, (1450, 2145), cpy)

                                                                buff3 = StringIO.StringIO()
                                                                page3_img.save(buff3, "PDF", resolution=100.0, quality=100.0)
                                                                buff3.seek(2)

                                                                self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Proposal_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                                                                self.response.content_type = "application/pdf"
                                                                #self.response.out.write(buff3.getvalue())

                                                                page3_pdf = PdfFileReader(buff3, False)

                                                                bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                                                                bucket = '/' + bucket_name
                                                                write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                                                                filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/4.jpg"
                                                                retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                                    max_delay=5.0,
                                                                    backoff_factor=2,
                                                                    max_retry_period=15,
                                                                    urlfetch_timeout=30)

                                                                fyle_4 = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                fyle_4_bytes = BytesIO(fyle_4.read())
                                                                img_4 = Image.open(fyle_4_bytes)
                                                                buff44 = StringIO.StringIO()
                                                                img_4.save(buff44, "PDF", resolution=100.0, quality=100.0)
                                                                buff44.seek(2)
                                                                page_4_pdf = PdfFileReader(buff44, False)
                                                                fyle_4.close()

                                                                filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/5.jpg"
                                                                fyle_5 = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                fyle_5_bytes = BytesIO(fyle_5.read())
                                                                img_5 = Image.open(fyle_5_bytes)
                                                                buff55 = StringIO.StringIO()
                                                                img_5.save(buff55, "PDF", resolution=100.0, quality=100.0)
                                                                buff55.seek(2)
                                                                page_5_pdf = PdfFileReader(buff55, False)
                                                                fyle_5.close()

                                                                filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/6.jpg"
                                                                fyle_6 = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                fyle_6_bytes = BytesIO(fyle_6.read())
                                                                img_6 = Image.open(fyle_6_bytes)
                                                                buff66 = StringIO.StringIO()
                                                                img_6.save(buff66, "PDF", resolution=100.0, quality=100.0)
                                                                buff66.seek(2)
                                                                page_6_pdf = PdfFileReader(buff66, False)
                                                                fyle_6.close()

                                                                filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/7.jpg"
                                                                fyle_7 = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                fyle_7_bytes = BytesIO(fyle_7.read())
                                                                img_7 = Image.open(fyle_7_bytes)
                                                                buff77 = StringIO.StringIO()
                                                                img_7.save(buff77, "PDF", resolution=100.0, quality=100.0)
                                                                buff77.seek(2)
                                                                page_7_pdf = PdfFileReader(buff77, False)
                                                                fyle_7.close()

                                                                filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/8.jpg"
                                                                fyle_8 = gcs.open(filename, 'r', retry_params=retryParameters)
                                                                fyle_8_bytes = BytesIO(fyle_8.read())
                                                                img_8 = Image.open(fyle_8_bytes)
                                                                buff88 = StringIO.StringIO()
                                                                img_8.save(buff88, "PDF", resolution=100.0, quality=100.0)
                                                                buff88.seek(2)
                                                                page_8_pdf = PdfFileReader(buff88, False)
                                                                fyle_8.close()

                                                                out_docs = PdfFileWriter()
                                                                for doc in [page1_pdf, page2_pdf, page3_pdf]:
                                                                    out_docs.addPage(doc.getPage(0))

                                                                out_docs.addPage(page_4_pdf.getPage(0))
                                                                out_docs.addPage(page_5_pdf.getPage(0))
                                                                out_docs.addPage(page_6_pdf.getPage(0))
                                                                out_docs.addPage(page_7_pdf.getPage(0))
                                                                out_docs.addPage(page_8_pdf.getPage(0))

                                                                buff4 = StringIO.StringIO()
                                                                out_docs.write(buff4)
                                                                buff4.seek(2)
                                                                self.response.out.write(buff4.getvalue())

                                                                buff.close()
                                                                page_1_bytes.close()

                                                                buff2.close()
                                                                buff22.close()
                                                                page_2_bytes.close()

                                                                cad_stream.close()
                                                                page3_bytes.close()
                                                                buff3.close()

                                                                buff4.close()
                                                                fyle_4_bytes.close()
                                                                buff44.close()
                                                                fyle_5_bytes.close()
                                                                buff55.close()
                                                                fyle_6_bytes.close()
                                                                buff66.close()
                                                                fyle_7_bytes.close()
                                                                buff77.close()
                                                                fyle_8_bytes.close()
                                                                buff88.close()

                    elif app_entry.customer_state == "UT":
                        state = app_entry.customer_state

                        page_1_bytes = BytesIO(
                            base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_1")))
                        page1_img = Image.open(page_1_bytes)
                        cover_font1 = ImageFont.truetype("Lato-Regular.ttf", 68)
                        cover_font2 = ImageFont.truetype("Lato-Light.ttf", 48)
                        cover_font3 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 62)
                        page2_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)
                        page3_font1 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 52)
                        page3_font2 = ImageFont.truetype("Lato-Medium.ttf", 57)
                        cover_font4 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 84)

                        name_image = Image.new("RGBA", (900, 90), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image)
                        draw.text((5, 0),
                                  app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(),
                                  (12, 134, 193), font=cover_font1)
                        page1_img.paste(name_image, (800, 2220), name_image)

                        name_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(name_image2)
                        draw.text((5, 0),
                                  app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(),
                                  (93, 106, 113), font=cover_font2)
                        page1_img.paste(name_image2, (798, 2470), name_image2)

                        address_image = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image)
                        txt1 = app_entry.customer_address.strip().split(" ")
                        new_items = []
                        for component in txt1:
                            new_items.append(component.strip().title())
                        txt1 = " ".join(new_items)

                        draw.text((5, 0), txt1, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image, (799, 2530), address_image)

                        address_image2 = Image.new("RGBA", (900, 500), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image2)
                        txt2 = app_entry.customer_city.strip().title()
                        txt2 += ", " + state
                        txt2 += " " + app_entry.customer_postal
                        new_items2 = []
                        for component in txt2.split(" "):
                            if component in ["CA", "UT", "TX"]:
                                new_items2.append(component.strip())
                            else:
                                new_items2.append(component.strip().title())
                        txt2 = " ".join(new_items2)

                        draw.text((5, 0), txt2, (93, 106, 113), font=cover_font2)
                        page1_img.paste(address_image2, (799, 2590), address_image2)

                        kwh_formula = Helpers.compile_formula("fx_Avg_Cost_Per_Kwh_Over_30_Years", formulaz)
                        if not kwh_formula is None:
                            kwh_price_estimation_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(kwh_price_estimation_image)

                            draw.text((5, 0),
                                      str(round(kwh_formula["fn"](app_entry, booking, proposal_dict) * 100.0, 1)),
                                      (255, 255, 255), font=cover_font3)
                            page1_img.paste(kwh_price_estimation_image, (230, 2776), kwh_price_estimation_image)

                            escalator_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(escalator_image)
                            draw.text((5, 0), "0%", (255, 255, 255), font=cover_font3)
                            #page1_img.paste(escalator_image, (845, 2781), escalator_image)

                            prod_str = Helpers.currency_format(int(float(proposal_dict["year_one_production"]))).replace("$", "")
                            if "." in prod_str:
                                prod_str = prod_str[0:prod_str.index(".")]

                            estimated_kwh_output_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(estimated_kwh_output_image)
                            draw.text((5, 0), prod_str, (255, 255, 255), font=cover_font4)
                            page1_img.paste(estimated_kwh_output_image, (190, 2940), estimated_kwh_output_image)

                            buff = StringIO.StringIO()
                            page1_img.save(buff, "PDF", resolution=100.0, quality=100.0)
                            buff.seek(2)

                            bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                            bucket = '/' + bucket_name
                            write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                            filename = bucket + "/Images/Proposal/Temp/" + identifier + "_1.pdf"
                            # gcs_file = gcs.open(
                            # filename,
                            # 'w',
                            # content_type="application/pdf",
                            # options={'x-goog-meta-foo': 'foo',
                            # 'x-goog-meta-bar': 'bar',
                            # 'x-goog-acl': 'public-read'},
                            # retry_params=write_retry_params
                            # )
                            # gcs_file.write(buff.getvalue())
                            # gcs_file.close()
                            page1_pdf = PdfFileReader(buff, False)

                            # page_2_bytes = BytesIO(GCSLockedFile("/Images/Proposal/" + app_entry.customer_state + "/2.jpg").read())
                            page_2_bytes = BytesIO(
                                base64.b64decode(Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_2")))
                            page2_img = Image.open(page_2_bytes)

                            highest_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(highest_bill_image)
                            draw.text((5, 0), Helpers.currency_format(app_entry.highest_amount), (247, 150, 33),
                                      font=page2_font1)
                            page2_img.paste(highest_bill_image, (
                            270 + Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(
                                app_entry.highest_amount), 400), 1030), highest_bill_image)

                            average_bill_formula = Helpers.compile_formula("fx_Average_Bill_W_Utility", formulaz)
                            if not average_bill_formula is None:
                                avg_bill_amount = average_bill_formula["fn"](app_entry, booking, proposal_dict)
                                average_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                draw = ImageDraw.Draw(average_bill_image)
                                # draw.text((5, 0), '$1576.94', (247, 150, 33), font=page2_font1)
                                l_off = Helpers.get_centered_text_left_offset(page2_font1,
                                                                              Helpers.currency_format(avg_bill_amount),
                                                                              265)
                                draw.text((5, 0), Helpers.currency_format(avg_bill_amount), (247, 150, 33),
                                          font=page2_font1)
                                page2_img.paste(average_bill_image, (836 + l_off, 1030), average_bill_image)

                                estimated_bill_formula = Helpers.compile_formula("fx_Utility_Bill_In_30_Years",
                                                                                 formulaz)
                                if not estimated_bill_formula is None:
                                    estimated_bill_amt = estimated_bill_formula["fn"](app_entry, booking, proposal_dict)
                                    estimated_bill_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                    draw = ImageDraw.Draw(estimated_bill_image)
                                    l_off = Helpers.get_centered_text_left_offset(page2_font1, Helpers.currency_format(
                                        estimated_bill_amt), 400)
                                    draw.text((5, 0), Helpers.currency_format(estimated_bill_amt), (247, 150, 33),
                                              font=page2_font1)
                                    page2_img.paste(estimated_bill_image, (1300 + l_off, 1030), estimated_bill_image)

                                    thirty_year_cost_formula = Helpers.compile_formula("fx_30_Year_Utility_Cost",
                                                                                       formulaz)
                                    if not thirty_year_cost_formula is None:
                                        thirty_year_cost_amt = thirty_year_cost_formula["fn"](app_entry, booking,
                                                                                              proposal_dict)
                                        thirty_year_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                        draw = ImageDraw.Draw(thirty_year_image)
                                        l_off = Helpers.get_centered_text_left_offset(page2_font1,
                                                                                      Helpers.currency_format(
                                                                                          thirty_year_cost_amt), 480)
                                        draw.text((5, 0), Helpers.currency_format(thirty_year_cost_amt), (247, 150, 33),
                                                  font=page2_font1)
                                        page2_img.paste(thirty_year_image, (1796 + l_off, 1030), thirty_year_image)

                                        buff2 = StringIO.StringIO()

                                        page2_img.save(buff2, "PDF", resolution=100.0, quality=100.0)
                                        buff2.seek(2)

                                        bucket_name = os.environ.get('BUCKET_NAME',
                                                                     app_identity.get_default_gcs_bucket_name())
                                        bucket = '/' + bucket_name
                                        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                                        filename = bucket + "/Images/Proposal/Temp/" + identifier + "_2.pdf"
                                        # gcs_file = gcs.open(
                                        # filename,
                                        # 'w',
                                        # content_type="application/pdf",
                                        # options={'x-goog-meta-foo': 'foo',
                                        #   'x-goog-meta-bar': 'bar',
                                        #     'x-goog-acl': 'public-read'},
                                        #    retry_params=write_retry_params
                                        # )
                                        # gcs_file.write(buff2.getvalue())
                                        # gcs_file.close()
                                        # buff2.close()
                                        # page_2_bytes.close()

                                        page2_pdf = PdfFileReader(buff2, False)

                                        sys_cost_formula = Helpers.compile_formula("fx_Total_System_Cost",
                                                                                   formulaz)
                                        if not sys_cost_formula is None:
                                            sys_cost_amt = sys_cost_formula["fn"](app_entry, booking, proposal_dict)
                                            # page3_bytes = BytesIO(GCSLockedFile("/Images/Proposal/" + app_entry.customer_state + "/3.jpg").read())
                                            page3_bytes = BytesIO(base64.b64decode(
                                                Helpers.get_pdf_image("proposal_" + app_entry.customer_state + "_3")))
                                            page3_img = Image.open(page3_bytes)

                                            sys_cost_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                                            draw = ImageDraw.Draw(sys_cost_image)
                                            draw.text((5, 0), Helpers.currency_format(sys_cost_amt), (247, 150, 33),
                                                      font=page3_font1)
                                            l_off = Helpers.get_text_width(page3_font1,
                                                                           Helpers.currency_format(sys_cost_amt))
                                            page3_img.paste(sys_cost_image, (2200 - l_off, 745), sys_cost_image)

                                            fed_tax_formula = Helpers.compile_formula("fx_Federal_Tax_Credit",
                                                                                       formulaz)
                                            if not fed_tax_formula is None:
                                                fed_tax_amt = fed_tax_formula["fn"](app_entry, booking, proposal_dict)
                                                fed_tax_img = Image.new("RGBA", (2000, 300), (255, 255, 255, 0))
                                                draw = ImageDraw.Draw(fed_tax_img)
                                                draw.text((5, 0),
                                                          Helpers.currency_format(fed_tax_amt),
                                                          (247, 150, 33), font=page3_font1)
                                                l_off = Helpers.get_text_width(page3_font1, Helpers.currency_format(fed_tax_amt))
                                                page3_img.paste(fed_tax_img, (2200 - l_off, 885), fed_tax_img)

                                                state_tax_formula = Helpers.compile_formula("fx_State_Tax_Credit", formulaz)
                                                if not state_tax_formula is None:
                                                    state_tax_img = Image.new("RGBA", (900, 300),
                                                                                  (255, 255, 255, 0))
                                                    state_tax_amt = state_tax_formula["fn"](app_entry, booking,
                                                                                         proposal_dict)
                                                    l_off = Helpers.get_text_width(page3_font1,
                                                                                   Helpers.currency_format(state_tax_amt))
                                                    draw = ImageDraw.Draw(state_tax_img)
                                                    draw.text((5, 0), Helpers.currency_format(state_tax_amt),
                                                              (247, 150, 33), font=page3_font1)
                                                    page3_img.paste(state_tax_img, (2200 - l_off, 1025),
                                                                    state_tax_img)

                                                    after_promo_formula = Helpers.compile_formula("fx_Solar_Bill_After_Promo",
                                                                                               formulaz)
                                                    if not after_promo_formula is None:
                                                        after_formula_img = Image.new("RGBA", (900, 300),
                                                                                     (255, 255, 255, 0))
                                                        after_formula_amt = after_promo_formula["fn"](app_entry, booking,
                                                                                              proposal_dict)
                                                        draw = ImageDraw.Draw(after_formula_img)
                                                        draw.text((5, 0), Helpers.currency_format(after_formula_amt),
                                                                  (247, 150, 33), font=page3_font1)
                                                        l_off = Helpers.get_text_width(page3_font1,
                                                                                       Helpers.currency_format(
                                                                                           after_formula_amt))
                                                        page3_img.paste(after_formula_img, (2200 - l_off, 1165),
                                                                        after_formula_img)

                                                        promo_bill_formula = Helpers.compile_formula(
                                                            "fx_Promo_Bill", formulaz)
                                                        if not promo_bill_formula is None:
                                                            promo_amt = promo_bill_formula["fn"](
                                                                app_entry, booking, proposal_dict)
                                                            promo_img = Image.new("RGBA", (900, 300),
                                                                                               (255, 255, 255, 0))
                                                            l_off = Helpers.get_text_width(page3_font1,
                                                                                           Helpers.currency_format(
                                                                                               promo_amt))
                                                            draw = ImageDraw.Draw(promo_img)
                                                            draw.text((5, 0), Helpers.currency_format(promo_amt),
                                                                      (247, 150, 33), font=page3_font1)
                                                            page3_img.paste(promo_img,
                                                                            (2200 - l_off, 1305),
                                                                            promo_img)

                                                            thirty_year_savings_formula = Helpers.compile_formula(
                                                                "fx_30_Year_Savings", formulaz)
                                                            if not thirty_year_savings_formula is None:
                                                                thirty_year_savings_amt = thirty_year_savings_formula["fn"](app_entry,
                                                                                                            booking,
                                                                                                            proposal_dict)

                                                                thirty_year_savings_img = Image.new("RGBA", (900, 300),
                                                                                               (255, 255, 255, 0))
                                                                l_off = Helpers.get_text_width(page3_font1,
                                                                                               Helpers.currency_format(
                                                                                                   thirty_year_savings_amt))
                                                                draw = ImageDraw.Draw(thirty_year_savings_img)
                                                                draw.text((5, 0),
                                                                          Helpers.currency_format(thirty_year_savings_amt),
                                                                          (247, 150, 33), font=page3_font1)
                                                                page3_img.paste(thirty_year_savings_img,
                                                                                (2200 - l_off, 1445),
                                                                                thirty_year_savings_img)

                                                                thirty_year_savings_amt = thirty_year_savings_formula[
                                                                    "fn"](app_entry,
                                                                          booking,
                                                                          proposal_dict)

                                                                thirty_year_avg_formula = Helpers.compile_formula("fx_Per_Year_Avg_Savings", formulaz)
                                                                if not thirty_year_avg_formula is None:
                                                                    thirty_year_avg_amt = thirty_year_avg_formula["fn"](app_entry, booking, proposal_dict)
                                                                    thirty_year_avg_img = Image.new("RGBA", (900, 300),
                                                                                                        (255, 255, 255, 0))
                                                                    l_off = Helpers.get_text_width(page3_font1,
                                                                                                   Helpers.currency_format(
                                                                                                       thirty_year_avg_amt))
                                                                    draw = ImageDraw.Draw(thirty_year_avg_img)
                                                                    draw.text((5, 0),
                                                                              Helpers.currency_format(thirty_year_avg_amt),
                                                                              (247, 150, 33), font=page3_font1)
                                                                    page3_img.paste(thirty_year_avg_img,
                                                                                    (2200 - l_off, 1585),
                                                                                    thirty_year_avg_img)

                                                                    bucket_name = os.environ.get('BUCKET_NAME',
                                                                                                 app_identity.get_default_gcs_bucket_name())

                                                                    bucket = '/' + bucket_name
                                                                    filename = bucket + '/ProposalBlobs/' + app_entry.identifier + "_cad_photo." + \
                                                                               proposal_dict["cad_photo"]["extension"]

                                                                    retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                                                                      max_delay=5.0,
                                                                                                      backoff_factor=2,
                                                                                                      max_retry_period=15,
                                                                                                      urlfetch_timeout=30)

                                                                    gcs_file = gcs.open(filename, 'r',
                                                                                        retry_params=retryParameters)
                                                                    cad_stream = BytesIO(gcs_file.read())
                                                                    gcs_file.close()

                                                                    buff22 = StringIO.StringIO()
                                                                    cad_image = Image.open(cad_stream)
                                                                    cad_image = cad_image.resize((910, 682),
                                                                                                 Image.ANTIALIAS)
                                                                    cad_image.save(buff22, "JPEG")
                                                                    buff22.seek(2)

                                                                    cpy = Image.new("RGBA", cad_image.size,
                                                                                    (255, 255, 255, 0))
                                                                    width = cpy.size[0]
                                                                    height = cpy.size[1]

                                                                    w_cnt = 0
                                                                    while w_cnt < width:
                                                                        h_cnt = 0
                                                                        while h_cnt < height:
                                                                            pixel_data = cad_image.getpixel((w_cnt, h_cnt))
                                                                            cpy.putpixel((w_cnt, h_cnt), pixel_data)
                                                                            h_cnt += 1
                                                                        w_cnt += 1

                                                                    page3_img.paste(cpy, (1450, 2145), cpy)

                                                                    buff3 = StringIO.StringIO()
                                                                    page3_img.save(buff3, "PDF", resolution=100.0,
                                                                                   quality=100.0)
                                                                    buff3.seek(2)

                                                                    self.response.headers.add_header("Content-Disposition",
                                                                                                     "attachment; filename=" + str(
                                                                                                         "Proposal_For_" +
                                                                                                         app_entry.customer_first_name.strip()[
                                                                                                             0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(
                                                                                                         str(
                                                                                                             Helpers.pacific_today()).split(
                                                                                                             "-")) + ".pdf")
                                                                    self.response.content_type = "application/pdf"
                                                                    # self.response.out.write(buff3.getvalue())

                                                                    page3_pdf = PdfFileReader(buff3, False)

                                                                    bucket_name = os.environ.get('BUCKET_NAME',
                                                                                                 app_identity.get_default_gcs_bucket_name())
                                                                    bucket = '/' + bucket_name
                                                                    write_retry_params = gcs.RetryParams(backoff_factor=1.1)

                                                                    filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/4.jpg"
                                                                    retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                                                                      max_delay=5.0,
                                                                                                      backoff_factor=2,
                                                                                                      max_retry_period=15,
                                                                                                      urlfetch_timeout=30)

                                                                    fyle_4 = gcs.open(filename, 'r',
                                                                                      retry_params=retryParameters)
                                                                    fyle_4_bytes = BytesIO(fyle_4.read())
                                                                    img_4 = Image.open(fyle_4_bytes)
                                                                    buff44 = StringIO.StringIO()
                                                                    img_4.save(buff44, "PDF", resolution=100.0,
                                                                               quality=100.0)
                                                                    buff44.seek(2)
                                                                    page_4_pdf = PdfFileReader(buff44, False)
                                                                    fyle_4.close()

                                                                    filename = bucket + "/Images/Proposal/" + app_entry.customer_state + "/5.jpg"
                                                                    fyle_5 = gcs.open(filename, 'r',
                                                                                      retry_params=retryParameters)
                                                                    fyle_5_bytes = BytesIO(fyle_5.read())
                                                                    img_5 = Image.open(fyle_5_bytes)
                                                                    buff55 = StringIO.StringIO()
                                                                    img_5.save(buff55, "PDF", resolution=100.0,
                                                                               quality=100.0)
                                                                    buff55.seek(2)
                                                                    page_5_pdf = PdfFileReader(buff55, False)
                                                                    fyle_5.close()

                                                                    out_docs = PdfFileWriter()
                                                                    for doc in [page1_pdf, page2_pdf, page3_pdf]:
                                                                        out_docs.addPage(doc.getPage(0))

                                                                    out_docs.addPage(page_4_pdf.getPage(0))
                                                                    out_docs.addPage(page_5_pdf.getPage(0))

                                                                    buff4 = StringIO.StringIO()
                                                                    out_docs.write(buff4)
                                                                    buff4.seek(2)
                                                                    self.response.out.write(buff4.getvalue())

                                                                    buff.close()
                                                                    page_1_bytes.close()

                                                                    buff2.close()
                                                                    buff22.close()
                                                                    page_2_bytes.close()

                                                                    cad_stream.close()
                                                                    page3_bytes.close()
                                                                    buff3.close()

                                                                    buff4.close()
                                                                    fyle_4_bytes.close()
                                                                    buff44.close()
                                                                    fyle_5_bytes.close()
                                                                    buff55.close()

                elif str(self.request.get("doc_option")) == "system_layout":
                    if "panel_type" in proposal_keys and "panel_qty" in proposal_keys and "inverter_type" in proposal_keys and "inverter_qty" in proposal_keys and "racking" in proposal_keys:
                        panel_qty = proposal_dict["panel_qty"]
                        if "new_panel_qty" in proposal_keys():
                            panel_qty = proposal_dict["new_panel_qty"]

                        font1 = ImageFont.truetype("Lato-Light.ttf", 48)
                        font2 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 72)
                        font3 = ImageFont.truetype("Lato-Medium.ttf", 58)
                        font4 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 58)
                        font5 = ImageFont.truetype("DROIDSANS-BOLD.ttf", 36)

                        layout_bytes = BytesIO(base64.b64decode(Helpers.get_pdf_image("system_layout_" + app_entry.customer_state)))
                        layout_img = Image.open(layout_bytes)

                        customer_name_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(customer_name_image)
                        draw.text((5, 0), app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), (92, 105, 112), font=font1)
                        l_off = Helpers.get_centered_text_left_offset(font1, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), 660)
                        layout_img.paste(customer_name_image, (230 + l_off, 1010), customer_name_image)

                        add_components = app_entry.customer_address.split(" ")
                        cnt = 0
                        for add in add_components:
                            add_components[cnt] = add.strip().title()
                            cnt += 1
                        add_txt = " ".join(add_components)
                        address_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(address_image)
                        draw.text((5, 0), add_txt, (92, 105, 112), font=font1)
                        l_off = Helpers.get_centered_text_left_offset(font1, add_txt, 660)
                        layout_img.paste(address_image, (230 + l_off, 1070), address_image)

                        city_state_zip_txt = app_entry.customer_city + ", " + app_entry.customer_state + " " + app_entry.customer_postal
                        city_state_zip_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(city_state_zip_image)
                        draw.text((5, 0), city_state_zip_txt, (92, 105, 112), font=font1)
                        l_off = Helpers.get_centered_text_left_offset(font1, city_state_zip_txt, 660)
                        layout_img.paste(city_state_zip_image, (230 + l_off, 1130), city_state_zip_image)

                        sys_size_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(sys_size_image)
                        draw.text((5, 0), proposal_dict["system_size"], (247, 150, 33), font=font2)
                        l_off = Helpers.get_centered_text_left_offset(font2, proposal_dict["system_size"], 310)
                        layout_img.paste(sys_size_image, (410 + l_off, 1460), sys_size_image)

                        module_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(module_image)
                        draw.text((5, 0), proposal_dict["panel_type"], (247, 150, 33), font=font3)
                        layout_img.paste(module_image, (980, 1975), module_image)

                        module_qty_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(module_qty_image)
                        draw.text((5, 0), panel_qty, (247, 150, 33), font=font4)
                        l_off = Helpers.get_centered_text_left_offset(font4, panel_qty, 290)
                        layout_img.paste(module_qty_image, (2020 + l_off, 1975), module_qty_image)

                        inverter_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(inverter_image)
                        draw.text((5, 0), proposal_dict["inverter_type"], (247, 150, 33), font=font3)
                        layout_img.paste(inverter_image, (980, 2105), inverter_image)

                        inverter_qty_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(inverter_qty_image)
                        draw.text((5, 0), proposal_dict["inverter_qty"], (247, 150, 33), font=font4)
                        l_off = Helpers.get_centered_text_left_offset(font4, proposal_dict["inverter_qty"], 290)
                        layout_img.paste(inverter_qty_image, (2020 + l_off, 2105), inverter_qty_image)

                        racking_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                        draw = ImageDraw.Draw(racking_image)
                        draw.text((5, 0), proposal_dict["racking"], (247, 150, 33), font=font3)
                        layout_img.paste(racking_image, (980, 2235), racking_image)

                        if not panel_qty == proposal_dict["panel_qty"]:
                            change_image = Image.new("RGBA", (900, 300), (255, 255, 255, 0))
                            draw = ImageDraw.Draw(change_image)
                            diff = str(int(proposal_dict["panel_qty"]) - int(panel_qty))
                            ptxt = "panel"
                            if int(diff) > 1:
                                ptxt += "s"
                            draw.text((5, 0), "Your system size has been changed from the actual design shown. The design shown has " + diff + " more " + ptxt + " than your system will actually have.", (23, 138, 195), font=font5)
                            layout_img.paste(change_image, (1028, 1730), change_image)

                        bucket_name = os.environ.get('BUCKET_NAME',
                                                    app_identity.get_default_gcs_bucket_name())

                        bucket = '/' + bucket_name
                        filename = bucket + '/ProposalBlobs/' + app_entry.identifier + "_cad_photo." + proposal_dict["cad_photo"]["extension"]

                        retryParameters = gcs.RetryParams(initial_delay=0.2,
                            max_delay=5.0,
                            backoff_factor=2,
                            max_retry_period=15,
                            urlfetch_timeout=30)

                        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
                        cad_stream = BytesIO(gcs_file.read())
                        gcs_file.close()


                        buff22 = StringIO.StringIO()
                        cad_image = Image.open(cad_stream)
                        cad_image = cad_image.resize((1322, 991), Image.ANTIALIAS)
                        cad_image.save(buff22, "JPEG")
                        buff22.seek(2)


                        cpy = Image.new("RGBA", cad_image.size, (255, 255, 255, 0))
                        width = cpy.size[0]
                        height = cpy.size[1]

                        w_cnt = 0
                        while w_cnt < width:
                            h_cnt = 0
                            while h_cnt < height:
                                pixel_data = cad_image.getpixel((w_cnt, h_cnt))
                                cpy.putpixel((w_cnt, h_cnt), pixel_data)
                                h_cnt += 1
                            w_cnt += 1

                        layout_img.paste(cpy, (1020, 720), cpy)

                        self.response.headers.add_header("Content-Disposition", "attachment; filename=" + str("Proposal_For_" + app_entry.customer_first_name.strip()[0].upper() + "_" + app_entry.customer_last_name.strip().title()) + "_".join(str(Helpers.pacific_today()).split("-")) + ".pdf")
                        self.response.content_type = "application/pdf"

                        buff4 = StringIO.StringIO()
                        layout_img.save(buff4, "PDF", resolution=100.0, quality=100.0)
                        buff4.seek(2)
                        self.response.out.write(buff4.getvalue())
                        layout_bytes.close()
                        buff4.close()
                        buff22.close()
                        cad_stream.close()

    elif self.request.get("fn") == "utah_step_one":
        ret_json = {}
        ret_json["items"] = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(['b006c39b0350316cb2ffe7a66275bc936e75a08e3809911aae57c8414a0a8a724ef403ac15e75f25c8049cab643f65350298eae8e309a886eeaf7da68485332b', 'db66af6c8d3fd52e7ce9297c742deab99e599b965f8ce3a4c0b75a1d4c887e660563e79ad5e0f8305502407b62d83402e09158baa596e13d0fc4ca16188f3364', '886493a4d128dad4829f5262a163ed336fed85680f014886536d9cd21e5a6ed6a2b035de6aae1f6c5db9cdfd2135a715703cd6d8307d02d1e7e58663944e37be', '68b75c55039a2ff5a905b4faf94aca61aa885f8e68f80ac35cd5da95eaf1cc0b394d8b07f8694d3c0e2372835e48702240a7670ad5c6f73f062ba7d361d2e682', 'd8f10b7ccf2e4c1eb4ac670f48fe44fb96f8331737f54fb81c763cec70657162fb306a5baa05ba60e32669906aabe157e53417fe34ca5ec1c2060d04dc243954', '75ae302a00caf529ed95df6d39ca658b78f2cdaefebd468fe4e6f874d1c483d7d72f944e7acb284898515706cb643c810c0253af6d2cea394827cfe086b030bd', '986fed05084a6e55db89d83105b7a228c072ba63af00f282ef096935757f610be647e6d7ffc84c4b61bd2b18b8b6a3cae71bddec3716d9cfbcb53dbedf4b6ec3', 'aa24eb6cc2ae94a5c1f33860b54aad4c1808247b2c322a437856ba8d419f0d47e3d7194759ac0a236b14f69d69d15a2e599e25cb39dc7bb36cc95317ab042a3d', '5bb74b42869b2a73b7575a392f6cc474ac0d7506879ab9c28d19ad7e9fa3b4166bce84dea730eb3ed9af5e251f42a051440b9e48fbfa59c3970d5d50246fd73b', '5b8250af8cc769078239d9fdf4bef1b6a401a8c38ccaa659dd91a8f914d61541855ef4373e0f19d8c210c44c76d9361e99e805760f0ffae03311867b7f47b474', '34de8de65bbad9e2bc478a014149d48e1058ee36168057ace8209ece6dd0f9476910a67a42e09cbf3901f1210a605d1e85b57d89bd1285d626120d44202bc807', '4a52e74b0a44e1b7419230fba446fecf8107071cfadb49d7c01787f1823680ba83063bf918d2ff102de1a6a64cfc70afb290555d80e7b924caeb31dafcda3e32', '2dc002d920444aeef8ac01f6ed8ff2a135e165892ada7344275642138a8d52a59cc1c7b15765d90aea7d82e2fcd61099f10d317f9c4b33544af43670ddb27cd5', '42bfb2adb06cada994abc92c5e55745794bd8748469cbff7ae0da92125b32219e5437bf0fc2b63762ba1c04fadc83137e32dd3d49783878981710710433c6fe1', '271925d80265d24662b9265b765807901a9ec7935eaf6d37189fbd52a6b807a292c057c255db54fa78bddd40a0958703c0fb2b7b60b996d1229ac7529b850259', '271925d80265d24662b9265b765807901a9ec7935eaf6d37189fbd52a6b807a292c057c255db54fa78bddd40a0958703c0fb2b7b60b996d1229ac7529b850259', '271925d80265d24662b9265b765807901a9ec7935eaf6d37189fbd52a6b807a292c057c255db54fa78bddd40a0958703c0fb2b7b60b996d1229ac7529b850259', '271925d80265d24662b9265b765807901a9ec7935eaf6d37189fbd52a6b807a292c057c255db54fa78bddd40a0958703c0fb2b7b60b996d1229ac7529b850259', '271925d80265d24662b9265b765807901a9ec7935eaf6d37189fbd52a6b807a292c057c255db54fa78bddd40a0958703c0fb2b7b60b996d1229ac7529b850259', 'e6e3ae09a3175af04e435c663f5ecf6afdd70d566f28a0bec9c85cbbbaead19f3e68c53f44aed7570ba001fa300f4a578c97d46308252214bd6ba29df6ff99a3', '745144a50d28fcbec7e1d4abccb4c09fe8b3c766fc9e6c645f0cef778e620db2757ffe4e7dbdc97940a9e27e8404468ba0210882f3cdd02622371f350d5c3329', '67a6843945a66cd876b890fa2c7758697090d2d20c4aa675b6e99e33a0fee1f1fb567749d7eacf84f3cf74c74db1289653642fae91e605ac2f138246fd73b794', '8ace2b71709613c73291c56c14f25b0d8dfc2227a97e00dd58862071b2c846beefe2dea73532302a0be76f70d36008d839460212f927d6dd2d7e50e85c18d642', '52d422bf1a033f5e7e88473f855b6d2b89272cdf2d527ac7a536ad2784bef2dc0cc3219a62d529b8e4a9f8c76ee54705250324337d3b6ec2e3fd8ca8352c01b4', 'aa0c459830e9fa7afe1be679e8dce2ba16934d21669b5084f2bb5583d2e9dc9a60ddc8ff96273ef0f8bdc9d51f9b09de09ee3cf00302cc552ecd5959d81569fb', 'a50b0502fd348dd7b9d8fb09798dc2246fb9a3139e584f424c8f472c00ce6961f23cdde67065a18b7f561997c7acc4804a77549cb7e5735a54c138dd92a3a229', 'aa0c459830e9fa7afe1be679e8dce2ba16934d21669b5084f2bb5583d2e9dc9a60ddc8ff96273ef0f8bdc9d51f9b09de09ee3cf00302cc552ecd5959d81569fb', 'ef2bbf0bf06f04ae1f22cf49c7c34e0e5776896a77218e18c43eebe5b1097ccead78375aded71db859ff5d804cdc39ee8fdf1b670244822d34ff36da572fcc50', 'aa0c459830e9fa7afe1be679e8dce2ba16934d21669b5084f2bb5583d2e9dc9a60ddc8ff96273ef0f8bdc9d51f9b09de09ee3cf00302cc552ecd5959d81569fb', 'aa0c459830e9fa7afe1be679e8dce2ba16934d21669b5084f2bb5583d2e9dc9a60ddc8ff96273ef0f8bdc9d51f9b09de09ee3cf00302cc552ecd5959d81569fb', 'aa0c459830e9fa7afe1be679e8dce2ba16934d21669b5084f2bb5583d2e9dc9a60ddc8ff96273ef0f8bdc9d51f9b09de09ee3cf00302cc552ecd5959d81569fb', 'fb8afcddd9b069267623c9271e5993ccf9505d58dd22b802bb29ffa234c6fe35f50c7ae9e099ffcd9aef20f3bfe9821fe49e0253f7cf553a0048aeb7be9d4076', '7e19fdeffd95401603e9c825f5d6e5734c188b6c5cf36f868158213284c5299f52589870d816118be299ab0616a5b9e17c9380fe04e0b1ef71457bfb0554ef15', 'da0d9e8fee1023d44fc8f19cad01041849fccbe763bac104d4dcf28e94f19fd11dad5a4a4d4cc51c8944b420f3cccafb71393abea519978a5ce3ffedd3aea58e', '370881cfc57854c24f1d2dd2be99e7a2856e304068062d6a1bdd5f06de9a9d81f9562ab11d5c3b828d463acb5814f77a66b1f61d93236aae169cd55b2d359c1e', 'a297b48aaf466b159d7a60953f0a4e903dbe2cdbdb2c51d255c8facd3583a82fcf6cf871469e865491fa0ee5ddb3d6ca6dbce5a9816769cfe81118852a496e6b', 'cf025e7f112d6ebc362a92546a65bfcf95116988fa9022a31e290d3395986561fd48d9f32330fcc64daf2c7c64b94a8c242274d51e43e45760452a60a2ab672a', 'f19a250a2b8c3b8cae914fe5fbe0125b4e4a876071979840a4c545bc8a0a583a7d1620a6aad81ef9d7d74c0a62ce87213de6fb5d6f3078a3f6c567e69e517de2', 'e26d6679c859fd42e4daf1acf0bf53c97f5e565b32eb18007787fcd7edcfd280c8f7913889d33248a21225cd430b9f71069127f484ee5ce08c0ea834951ab234', 'f19a250a2b8c3b8cae914fe5fbe0125b4e4a876071979840a4c545bc8a0a583a7d1620a6aad81ef9d7d74c0a62ce87213de6fb5d6f3078a3f6c567e69e517de2', '3699ca37bd7696f3d563e27df13703ff1e09ed2264e8b7572d5673d934095b3b47e8e65591ca7922b791f914c9220693035ce9a97ecccc6100cf8c5aeb5f7f9b', 'f19a250a2b8c3b8cae914fe5fbe0125b4e4a876071979840a4c545bc8a0a583a7d1620a6aad81ef9d7d74c0a62ce87213de6fb5d6f3078a3f6c567e69e517de2', '5d8dc3acdb5b346564c0aedbcb538b6bc18278caf440dbddbddd8864576da080962419518392d366ad127ce330c4edd155c9370c4a553449be35edd840d4a5da', 'f19a250a2b8c3b8cae914fe5fbe0125b4e4a876071979840a4c545bc8a0a583a7d1620a6aad81ef9d7d74c0a62ce87213de6fb5d6f3078a3f6c567e69e517de2', '4be3b7f0f3f250408703e3975817d5f6c757dfa3307b69d53fd80a80c04f3a71beb2cc1ebb5c3e884b1bc1778318b6baa19608731823f238d2c703408ff5c9fb', 'f19a250a2b8c3b8cae914fe5fbe0125b4e4a876071979840a4c545bc8a0a583a7d1620a6aad81ef9d7d74c0a62ce87213de6fb5d6f3078a3f6c567e69e517de2', '8f39a48d177a5de588ae8c55fafb0e0887bf73ab6f533584f5ca334b92c1acfd43e718b4e2bbd2bfc54fcbe78267e4090fffa19fadf582200b4aaa4e888566dd', 'c13f4de6f18a892186aafd3f4139310f66cc226ad151c6511026c683deb52ebfc516ea364d94574d16ea0d64376664809a7792eda75954c3decc4ad65af1f865', '04679eb74d8cdf44b837c8a24b39d604b6baef2b3e731f6a3014848f81c47dbf728662ab5defe32204b5811287abfb1bbebb8742a44dc0549e5be6d6e3303db8', '0800c4978f3c9b43625a847dc7be91612486ec20cfaec5b83454d772411bca594796e4e4ea9f81b07921780b7504d3b289d8dc90b0c55a86030660432bbef4eb', 'd02530a79605bc6b3f93a57bc6e8a3a7dfef089778a0e2e9da700016c03ac235f9f04c31da38db18b761a102c4eda5c153a5db1b5dfa16002f23678ad8481160', 'a367ba549d07abb16108735e2dc6fc970f30ff166427d6aef4fb85b34c730f5cbbd71d356976dfedf277fdac711b67f60347b090bfe82c84b1ad5be9a2034ff7', 'ea2b4d1cf524fbd46977f032484346cf10498d7098e06470455656af82b4b2b899314254b2caf9791532fc99a2fec1ee5761d0a6a8a9bfc97b42a4c366fd6254', '85e471a1982ee4fe5b6e0615f325f74cca7a728407b7c2ac70637d8a9e0eb3f6ca9adf65857ff5af79e4e950fc306bec94f58b512574c09fe698a5381df449b4', '74accad100da8374c39dc786a44d69985a17b601877b028e74fc4c7d988dbf786b8aa96b6b379b4e1863dde7c3c36459b1819d2b01cfe987d30a0d37c3add837', '74accad100da8374c39dc786a44d69985a17b601877b028e74fc4c7d988dbf786b8aa96b6b379b4e1863dde7c3c36459b1819d2b01cfe987d30a0d37c3add837', '74accad100da8374c39dc786a44d69985a17b601877b028e74fc4c7d988dbf786b8aa96b6b379b4e1863dde7c3c36459b1819d2b01cfe987d30a0d37c3add837', '74accad100da8374c39dc786a44d69985a17b601877b028e74fc4c7d988dbf786b8aa96b6b379b4e1863dde7c3c36459b1819d2b01cfe987d30a0d37c3add837', '74accad100da8374c39dc786a44d69985a17b601877b028e74fc4c7d988dbf786b8aa96b6b379b4e1863dde7c3c36459b1819d2b01cfe987d30a0d37c3add837', 'c4dc0650d374555ab115b22ba099784d2476608c79ffae95ffed0468a7e9fa8c2513d89740702f0758c744bcdd0d6b4e0e2fe8115376055a218ba7696ddd82e9', '5e6e17a1f6189679028717609d1a6c127fba23b2562b2c39ef06d21249942a9ea37f1369f92b5e2250dd73d4a9a1cf2b04e4cf50d25ef37f548c2940baec2a9f', '4d8b8e0a940575d9733fc29432f6e2dd64e04a0fabc884b3cc88c68168928094fe9ffcd9f5c44732813128d7d63f596dc13bafc5dec944279541da4f26951365', 'e59a1926929ed7cb939f3a947b1d6414ed415494cfb030e11ca01a83eba46a7694e1133d2dd6aaa656d13aee5a3314c9d3d83078102a5380ff9dbfab70e862b9', 'f263da75c3fdd8b9d6b9e8c0c4c2b0c6abfc56c9c5ab8efc620a7277e929f6bf4d51733c93ddc6fed2f8b3771135cc534ede9e86a166daf0a3834b0e0ebe388f', 'f263da75c3fdd8b9d6b9e8c0c4c2b0c6abfc56c9c5ab8efc620a7277e929f6bf4d51733c93ddc6fed2f8b3771135cc534ede9e86a166daf0a3834b0e0ebe388f', 'f263da75c3fdd8b9d6b9e8c0c4c2b0c6abfc56c9c5ab8efc620a7277e929f6bf4d51733c93ddc6fed2f8b3771135cc534ede9e86a166daf0a3834b0e0ebe388f', 'f263da75c3fdd8b9d6b9e8c0c4c2b0c6abfc56c9c5ab8efc620a7277e929f6bf4d51733c93ddc6fed2f8b3771135cc534ede9e86a166daf0a3834b0e0ebe388f', 'f263da75c3fdd8b9d6b9e8c0c4c2b0c6abfc56c9c5ab8efc620a7277e929f6bf4d51733c93ddc6fed2f8b3771135cc534ede9e86a166daf0a3834b0e0ebe388f', '25ee0ad31cf6bfe368fd427e2d2fc6a5bd17ca9eb3b05ad91c67f223646f8e42b2c118a333eebc011a2e1de8ece1214f3a7e14e002202dc0f45d5c99c82b3380', '8e9d60e9a52467e9416af938f9ef816ff17bc44a8bacbf07a40432226a605f75e4844563d71aa5e8d3c9a730ab051cb3b286adf30b9ef14c4939863ba9855944', 'a4ecde21e3086ed8b88cb42291862899999cd375e3dd4eb3d397723754347162339992ca72255e7ee4e5f98a562a31ae2d45949a17e7050577206a05561f2cfa', '5cd2365379ebef5c14d5e9c1dd1725b22317a18c1712e28638c1d17585b05db44f55aaab55b6cd420f13ea45027d7445d56353ab269d9d46bdcb97fc1d4ec54f', 'fbce081622d27ac4d0bafb67f58c0ed4c931e4034771f2bc57149530953443ea0907dfa81b8bc80b630cc91aaf9b1ddd7e86eedeb6485c7a428bbfa0ccbb0cc2', 'd27b1b7840bb2fef59f96f19f8f31f47df7292fb0e34834b6189a54f8f4abd1448b71032f036ab6fee4d0ba93748c35a42fe0e3713e8dbdfa9f91c6e16c0aa01', '0f4ad2bdca072faa4453886d5389e7cb3e4e08da2e4bf31625ce970ea666d99e60dde91eddf3933520ad31527bc665c6aad31b62fb314feb98c1c479fa635d49', '25b84b01ccc7226eb9ff4d096f3217190930fa98bceb4173c7c15a0dcb3df5642dd0cf5416383e1d5c6add73a9646d7785ee627fef70e477b054f5698f255a18', 'c513c02ec6488bd2fb8a9117c9227cdd4ac039b4fd4c644fd669a4fb85faa8469b9a2be8a041ad16fba4509d0ed145adc14db3a1b984314ee6f4b04eec553249', '431a1f20e964dc3bca2aeef372483eb429183f5350d9b725b59541e6a171a7a6879bc0a24572beee0dd15e876e49e38789e7677b55f14947ef72f62fed0a537d', '25b84b01ccc7226eb9ff4d096f3217190930fa98bceb4173c7c15a0dcb3df5642dd0cf5416383e1d5c6add73a9646d7785ee627fef70e477b054f5698f255a18', 'cc44ac6b67cf4aa8ec7bf433433a4bfa7615b376dc992b7d84b19fc86f42dca7b076d83ae946b581e74aa26f970ed218b4e82ba12fc2f4d0ef64c16955702379', 'eaa56cce8f74506e89bf714cce2fa860cd7a24021bd1a0b4953cea34350d67ac248c59570946cfd1e0d0c2229b77e7931ab79762f27735e0cf64ced787b851f3', '25b84b01ccc7226eb9ff4d096f3217190930fa98bceb4173c7c15a0dcb3df5642dd0cf5416383e1d5c6add73a9646d7785ee627fef70e477b054f5698f255a18', '892a2ac15bf3c6afb5b65847d07f544a41b9c90263565fcc8e74ebc49cbaea1caf7b9746266a561ad4dd48420b522b760102fc523f33e844b48bb5c36a16be85', '25b84b01ccc7226eb9ff4d096f3217190930fa98bceb4173c7c15a0dcb3df5642dd0cf5416383e1d5c6add73a9646d7785ee627fef70e477b054f5698f255a18', '441e87950c83ead9060e738ecb329028494a9dbeb2a1ef9b930ef454924383a0fc69b4adbc83120ec8917b385a2ff4d2b908b1e7f29c992de6629fe32c92a96d', '25b84b01ccc7226eb9ff4d096f3217190930fa98bceb4173c7c15a0dcb3df5642dd0cf5416383e1d5c6add73a9646d7785ee627fef70e477b054f5698f255a18', '62f693808974576729b19713ed638171571cb9dadc936f723d1cc0d0611ea92492c4538a6f446b0e741646f7ac981882144acbea559e121a5dab90040b31de3f', 'e7651460f070f7f51e4754400a94b1b6bdbf9864afdac296c5114d27100b856335257beb012d77e3462402a049643ed8074ffc72b90257e8040c3e0c9e562079', '81ac4cdd8358d720b1305f8bb6d53dddf7fe71741bd1ce1468dd012989c2b1a06f80b2e6f47eed321e124cbe8bb2d3b39c49d19dcf75dfea2b103312596b9ae8', 'b06a720013c4db262eeee057204abd95b26c0018e3e2a99558c64d3f86bfa08bed8c89f598ec6a2d62182430f78de1d78f3ac54823effa7d0078b2e1305538dc', 'f7d5854cd326d6ab8f48396966a3fe60509426d827a724d91c861153702230add6d49600e1cee7eb7aa4101efffec865c3079eb9760a38514bf3a0c3de6500c3', '1039529ee37cd30dc9b0d95c5855fed6e0dac5ad4b58e156064f0cda6d283125bff442ea5d85bc31e5ae3a2e7a888f172ba0d6486b31f9020648af9d405b1d6c', 'cd5c764e36ae23c791df18d6e4a4015dc4d1564f41750cc52e21a99bad0bff8a92cb417d54268f6bf7d87b2435f09f798966de5436c193b81e2db048c3370b97', 'd2393d17041bcd5551fee62be43feb933b832f7c73bc0848b58942eb061a7d49235cfd4b3def26cafb2590bbced69872b330f55dbca222eeeec2ff9e7267cd8e', '7f8f42551d99abf3dd4172bc5617e4b16dafad31b0056bab432e84c673bc1ce3d6fa12fcc442ac748d13cec11451960d645eadd4ca3ff868a781c19e3707d345', 'a96d611ed49c7d3be82992dd8c9b63ee59728bc94c7b1c8c3ad2e642cd98b6680d1e6516d88311f40015750a5aae14c52bec2455077a0aa888e3067b0a31b0b3', '0432b06f1b250b4d01d8947027574bb0a9acbbf247c103cc5b9caac8c851ca39cd024468e5b00f31f60585a13fb1bcba7a6ba043c612782f631be83036bd26a9', 'a96d611ed49c7d3be82992dd8c9b63ee59728bc94c7b1c8c3ad2e642cd98b6680d1e6516d88311f40015750a5aae14c52bec2455077a0aa888e3067b0a31b0b3', 'a358736db639ebc71cb6b5f446d57486866aa42c23bd30544e076e1c42142e14b11e8e3b5ca66341087605731c3e24b39981ce4e5e15842335375c0bfcc65889', 'a96d611ed49c7d3be82992dd8c9b63ee59728bc94c7b1c8c3ad2e642cd98b6680d1e6516d88311f40015750a5aae14c52bec2455077a0aa888e3067b0a31b0b3', 'a358736db639ebc71cb6b5f446d57486866aa42c23bd30544e076e1c42142e14b11e8e3b5ca66341087605731c3e24b39981ce4e5e15842335375c0bfcc65889', 'a96d611ed49c7d3be82992dd8c9b63ee59728bc94c7b1c8c3ad2e642cd98b6680d1e6516d88311f40015750a5aae14c52bec2455077a0aa888e3067b0a31b0b3', 'a358736db639ebc71cb6b5f446d57486866aa42c23bd30544e076e1c42142e14b11e8e3b5ca66341087605731c3e24b39981ce4e5e15842335375c0bfcc65889', 'a96d611ed49c7d3be82992dd8c9b63ee59728bc94c7b1c8c3ad2e642cd98b6680d1e6516d88311f40015750a5aae14c52bec2455077a0aa888e3067b0a31b0b3', 'a358736db639ebc71cb6b5f446d57486866aa42c23bd30544e076e1c42142e14b11e8e3b5ca66341087605731c3e24b39981ce4e5e15842335375c0bfcc65889', '5858841a423dd91a1087469fa5fe89d64fa326814d254cb549feb4803df5e6d07822cc2b45ec134626ffa4274460fb757e715870e5e407a97f0b1c06e423e2fa', 'a358736db639ebc71cb6b5f446d57486866aa42c23bd30544e076e1c42142e14b11e8e3b5ca66341087605731c3e24b39981ce4e5e15842335375c0bfcc65889', 'e573418a6bb0ef1542416f9544bc8e2849facb6715b14b01bf7ce382c9fdc433a11ff242bfa5f74405c80bb082029a8002bed9a1678d55a76e225d60176e7b04', 'fe142b232acce223a25f2a55408833e59c3fcb0d20a458e7ac19512d58466e465344e1645811087459dabd19f491de77f50681038c8a02b4054c877e725abbc3', 'f2ef4cc875f8d6f044593bae36eab2bdde32fa624f42991d85ba45c6aa460f04c386ef9524ed591febe5574dcc647438e391c1ccd3f3953486ebd80b45f0af59', '49cb411458a1cea2e4e57078d1ea3520c0c60f3fd5ccf89c27789fee4b11ce72f254d44417437129a69f584a16e29980ee28403f3799bf9f54ebd07b5332ec69', 'f2ef4cc875f8d6f044593bae36eab2bdde32fa624f42991d85ba45c6aa460f04c386ef9524ed591febe5574dcc647438e391c1ccd3f3953486ebd80b45f0af59', 'f2ef4cc875f8d6f044593bae36eab2bdde32fa624f42991d85ba45c6aa460f04c386ef9524ed591febe5574dcc647438e391c1ccd3f3953486ebd80b45f0af59', 'f2ef4cc875f8d6f044593bae36eab2bdde32fa624f42991d85ba45c6aa460f04c386ef9524ed591febe5574dcc647438e391c1ccd3f3953486ebd80b45f0af59', 'f2ef4cc875f8d6f044593bae36eab2bdde32fa624f42991d85ba45c6aa460f04c386ef9524ed591febe5574dcc647438e391c1ccd3f3953486ebd80b45f0af59', '3215cd17107fb477f86d44429166d4b929a4e6f0c41ca4a3a18e9a0fc6a59d2ede18e519e6c590290ee8df1a5b2406b63c8ddb9bffb87a272681eb6e1bdc519b', 'db5b3ecf14992ba7c81d0827182c0f451ef00880629c8af9fe1a8aa4e52b22542c2c186b27d9f7f7e6122f78112cf998df985197d498ee65373f7bc712a91a99', '60fc69e0e8aa2336e468abf0fa10b690020ee600f160decc20b912a3cb1eac587a421de53d1cf358dbddc66428f052a946a54510daec6c7f731be18ca72bbd9e', 'bfe5f577e5bef7689603c0582180378f631b34c9c5fd646a9dc079f5f5948a4072c5929def2872339d7f0416457ae565c6ce31a1279fb4d42b6594fc6132097e', '0fc1dbe8756d35366c535d7f0b1e845e40a8092b729e1a2af562e44924fe429f7a73aa51e34a364428992242625e1773fc5f6bac5807ac379b0a42f99a7fa949', '8dd61920767882a9c0b5826cdfe500bf61e7f96aa7d0324e11ec6b47fc10acfca2035f94dee778cb1ea9c9abcfacd1cc7ae5631b18dee114d602a5a12334afe8', '64fbbb9dbffdae3e2238ad6cfe13d4fe747393bdec4e1d873db578e9aa7ca48ad996c40978e2d698879b5c156a02e8380ad64dbaccaac32102c04bdc2a683c01', 'eec6d0a5588fa568a9abbd3914080a1d178606dc0ff42554670eeb3fa79bfd1e3eb6e8b4182af26f53f44c63c893e9d55e15159b6244f97be812f22f4205bdc1', '40c035e9411695f5d809746998ff4c343b3c4b187bc221517c1a34f9bfa5daa6add6253a5b4880ed0f2598cfdab8a82711514d78188a2b4f6ab24f8a81691b62', '1fd974ce82814c479c68388f0ebb2b028a02231d57079b8393593e9da60d72a275f20fc3275b5184942f97112ed9e9682e22b0400e957461bb69770a26593659', 'ad2403ccb0e078b49038b192536a1a85924ff6a2454da4593f1783bbdf4d2ed05404f147309b385f88707ebfc7c18980c596bc6f53c543f83ff7639c5c19b342', '7591876f5bb0658b6473fdfb4c9aec6cd0daf8e01768e7ea65aad6b26394c5881e10881533ccd93b55b9b1223775b19b555c8d474be182ab28331af9d474a1ee', '31f06b8c6a66d925d783df1f411d486541f86336e74f9f565a6e062a0e40d161dedc078066ea866fcf75e49258c7ae153f19a226eef42f930eba35f0b8df8f9b', 'ce6b746cc4bc463e9ec6ce2448dad41f95b1663d4f2e2c2783430fbd324bd0ebd28b3e41d79bb00240590dd326f0c78763bc20bfa15e078b1465430196315da7', '0548b6cc02fb45e383ecffc6261ea134dc1169b2aa107d6e7f536275a148924e46c3cec763c434170b737df66ed5ff96dc45131dc602a416b5993d0624db9ce4', '13eb703ca54702ce08df3acadbfad71317045fac3638ff7370256e5a42b646de797f1dd06e575b185773a21fb4b044dfde0e1152e2442aa1e773f07b35f1207f', '0548b6cc02fb45e383ecffc6261ea134dc1169b2aa107d6e7f536275a148924e46c3cec763c434170b737df66ed5ff96dc45131dc602a416b5993d0624db9ce4', '0548b6cc02fb45e383ecffc6261ea134dc1169b2aa107d6e7f536275a148924e46c3cec763c434170b737df66ed5ff96dc45131dc602a416b5993d0624db9ce4', '0548b6cc02fb45e383ecffc6261ea134dc1169b2aa107d6e7f536275a148924e46c3cec763c434170b737df66ed5ff96dc45131dc602a416b5993d0624db9ce4', '0548b6cc02fb45e383ecffc6261ea134dc1169b2aa107d6e7f536275a148924e46c3cec763c434170b737df66ed5ff96dc45131dc602a416b5993d0624db9ce4', 'de4523e4f92223136716216bf82e7b13a07de883302efb1c95e374ee12524105c36baee5f367f04504a4775a87484136e8b1fbe0e1c9e99a6ee740c3040e909c', '47c118375800e405bc53505937077b167582a75677e3cb59e6192d557c9ec4584d5b8dd7facab5d8360fcdc5dca11d5dffd4cba53d3758f995a7a23ee2766262', 'bceaec94aa3caec7f465a05e06467e1f84df31faf0457767437783f6c4286ceb823d0b35b876e71a40e0d73de207dbd0e9f2e374f1110a1b5db5a8e9da02022e', '3a4127b40623b75b1068bb07aae79283797ce5414f96324c17fafb03b1786b02129f32a69d8c8c678c1dbc8e19c474055cb5d0e9aa5bc52795bcc2cb07477931', '98a8c8f4161a99cbc3abcf4061f90c83eba27fb6eed32ff21ee30125182ba7fb9457b2123f11bf4fff07dd0cdad4c3359efd8292b02a53600bb5a0a735dc3c01', '3a4127b40623b75b1068bb07aae79283797ce5414f96324c17fafb03b1786b02129f32a69d8c8c678c1dbc8e19c474055cb5d0e9aa5bc52795bcc2cb07477931', '98a8c8f4161a99cbc3abcf4061f90c83eba27fb6eed32ff21ee30125182ba7fb9457b2123f11bf4fff07dd0cdad4c3359efd8292b02a53600bb5a0a735dc3c01', '3a4127b40623b75b1068bb07aae79283797ce5414f96324c17fafb03b1786b02129f32a69d8c8c678c1dbc8e19c474055cb5d0e9aa5bc52795bcc2cb07477931', '98a8c8f4161a99cbc3abcf4061f90c83eba27fb6eed32ff21ee30125182ba7fb9457b2123f11bf4fff07dd0cdad4c3359efd8292b02a53600bb5a0a735dc3c01', '3a4127b40623b75b1068bb07aae79283797ce5414f96324c17fafb03b1786b02129f32a69d8c8c678c1dbc8e19c474055cb5d0e9aa5bc52795bcc2cb07477931', '98a8c8f4161a99cbc3abcf4061f90c83eba27fb6eed32ff21ee30125182ba7fb9457b2123f11bf4fff07dd0cdad4c3359efd8292b02a53600bb5a0a735dc3c01', '3a4127b40623b75b1068bb07aae79283797ce5414f96324c17fafb03b1786b02129f32a69d8c8c678c1dbc8e19c474055cb5d0e9aa5bc52795bcc2cb07477931', '98a8c8f4161a99cbc3abcf4061f90c83eba27fb6eed32ff21ee30125182ba7fb9457b2123f11bf4fff07dd0cdad4c3359efd8292b02a53600bb5a0a735dc3c01', '086f4243e0c3074e39716d3516091fbe0e89062e8f7947b70bac8504bec3dac12d54343a6d10ebaf51d9b668c195672a2a0ca714d573818c2cfc6c82b4092fa2', 'd5cbfe3ce6082cf3fc1870afa09228827c1ba0fdbc22da9de409bf0d03ca80500f01583b274f705b0fd823b6189c7e831dd3e9397d21f11e1d78d5498f419a14', '23ac6ab155e4323acf92a5c199e10a2ef2381009a3d94e6cb470512a9180e35d06accc29533716ec30be644fc99e5bc470e219be7e761dedf30bbe06cd6c8166', '5c4886b7e4f5495580ef22ff71e52cc518bab36f8834ddf7a7ad5ed411ad3714d57e8d149043ffa8d862fcc0c21d0a979bba9b92ab1877272e13a82420144f38', 'a746eeb86ed28776ec976cd2fec3c368a1f96e5e0654b5becbce9ab8a26113c48b2666727b4a9817339f030dc59a377759164ce9e489da35c91f2027bcd99434', '696c2aec312df1420b437b868e235814c49e282b27a99f335af7d863a2b88529ac43d4499b69e971d3400db1a0dd6edf4d7b356d10790145b22f19380d6fd100', '038880f2e04fc484edd297d2eb6152260dbe5a9fb7fa43994ceec466740c1ec1a79a21c4c7fb033ef6b7a39bf48933f39db9ef0a4c46b83f83477358d55eb8b9', '51b6f20bf587871c13c23891482a2377320028dce972c6dec6bc11a6da376cd08e82a76997dc91a863437b1d070642f3844e991059b2fb8b75f75f75b9a53015', 'e048d99bc7285981ea1398a2b1b42c9b9792056b3b30de1b7c30fd404a190258fc4d748398f92ace791889f50385f11404b8abdd15823870d03f89a8b0cfd6c9', '6a1aa7f599ae9d85981cf0e952f70ca70a915c9c2f9e5eba552c6c9c25813569d7c4ad9a9ccd9cc07ed0423ca452191f3a53e77d25e11332a855bbaab9107f10', '2ea8fd87b871a5517cffff22bc111411a621bea250ca559fdc9f283b173b39640f8eb5c93f656535687fe2cb84960c9b8a9185300abf4a21e97bb3e5dcc84e35', '9ebc690d0845564b6f49bdffc1cfc93c218363b834da1d260ae2fd88a87471d8a040f2ea730485ef5a985d8d6696245cee513f7425f5e7157257320bb2725a4e', '9d7672ba6ca766a32761301ba8896300a495c5e5852fc471f98cac3569300ba111501b5ad23e60cbf8a2c8275f83509a1889d96cacfed0690ab6b349e406d4a3', 'cb11aae5b2e21e9e882a2d75216f216e062774f820481102eb6320b21d248cfcf782df406942daed7bc822ea31d79a2bcaa69ffde7d430ad1bd2e6dd0e766e18', '82a6c6bce453297408af3b0dc85e6e3912377073ab9bd6c1ba1544a745ce39d2d2a6610d8e0b030ea342425f919417031c353334a963981720ae1a3cb6bcdb13', 'ebb540e37dc3bb53c74ffdd415382ecdc76d0ed6e0a51fe2c41e2f128333310e4c6009ade5d130769b2c246e2be1f57f1b9b8c8655935f35765a2878a3c07934', '2dd14f0cddc9710562b39438c58db6c680c66e59c0ddb5ae28328b30f235b8a785038771a18f6c50f3e0f2ce539c519931cf27edebcbaa1d595a29d83e8f59dc', 'ebb540e37dc3bb53c74ffdd415382ecdc76d0ed6e0a51fe2c41e2f128333310e4c6009ade5d130769b2c246e2be1f57f1b9b8c8655935f35765a2878a3c07934', '7c9fdc7aa194d3e655506c45c5d32fb92aa5a59aa753d75cfe9edde9057fe8bb46b719f2d7b00ff02d070b55dc6b56375cdf2583859eafbfa777ae0fdc811fb8', 'ebb540e37dc3bb53c74ffdd415382ecdc76d0ed6e0a51fe2c41e2f128333310e4c6009ade5d130769b2c246e2be1f57f1b9b8c8655935f35765a2878a3c07934', 'ebb540e37dc3bb53c74ffdd415382ecdc76d0ed6e0a51fe2c41e2f128333310e4c6009ade5d130769b2c246e2be1f57f1b9b8c8655935f35765a2878a3c07934', 'ebb540e37dc3bb53c74ffdd415382ecdc76d0ed6e0a51fe2c41e2f128333310e4c6009ade5d130769b2c246e2be1f57f1b9b8c8655935f35765a2878a3c07934', '763c21a73d7eea0926340fa38b8785e6e9f6e47119121af47cb0f874128c8df9c150aff64618f553934b6af2598ec201236e03dcd22099e516859c7a6a2d6066', '0752d1984da484e6ee326428fd99aadfbfa31fd2b6bfc2a218265d3aec26706c7d98694ff92fe0c0097ff12a22cd17a4d1581572507690d1704354dfc067a996', 'eba5a99d6aae5a76b011006d3cb73d199024645411e8eb816f2ca07bceb7d87d065aa6b1a031f1141aa1851e4c401f8379a973cef8f7d142249281871daf54c7', 'a7eb5bcbe6731e0dc90279974d469e5a0842dcfd71a7e9a81f21f6ef425ebaaf13a0925e2ec1e6530a7507e261b2b5449c69a3fd919c34ae648d2f7d1d8e75ed', 'b8ede63fa4d1bc03ad765983f75804b8fbf82916b453d16c24be62b5d8dfd8cfb8f594a8788debc0eb97b56bbf0074ed27a4f6bc6b5b3e4e99a4effeab4c4a8b', 'e7f67e963e6ee25867e14adda6c754756c3f677dde1c75b6fa59554a908e2c72fdc839576f64891faf6d7d69c198443ad1955919d10922e590af6d098669ee1d', '9593c4306861136c159597d67b4d9a6018fa976f8ac4e12a4fd3aec76d62711c8a51bba5fa4b143dd4527d3f874d6e23a9c097cb15a90fbd808c25a3be531f31', 'a1f991a58ce248b63b2517130513deb29133e1d3d26d79bc452e7da71f45714fa4cb0f74f3f73d3d31617596192547c22d16a0e2bb7f01cec6bb27c1af0e74a4', '0f179a6c9cb3a0c895f6eea3026e9ca7cd816cef8b8c570f1169c341243220fcb1477c1ea509f76a5a07459464684f7a97fe73a8cd40ef7498b810ddeadb26fd', '37d5c3d89e837914a7a2dafba662cbb5e8b82bd43b50126b6768ba97c2c7db0bc1e886020f66eb0f7e95b22debd40d133fe6e5552b5385d1f8f3edda6fe5e7f2', 'eb3fd3aa8e0bfc864affb4df62c8623c23981834ca2940e4dfdf8d3b3bf72e19dfa5a71b7e5fc49e6eac8c5fec704475994d26a1f55f952be70d8b573f74369d', 'fd1d21e46c965fbab953908f724a6d96280d07da6ad81c70724bc55b17ac7aa5ede8c4db188928288cd885f38baf2e732cd1d11d072bb7b31ea05747f3a69d65', 'eb3fd3aa8e0bfc864affb4df62c8623c23981834ca2940e4dfdf8d3b3bf72e19dfa5a71b7e5fc49e6eac8c5fec704475994d26a1f55f952be70d8b573f74369d', '9ef5987cd8b816dcd11e66bca08d79975739994c3b125b5569db4e936ac36efa9dbc45bdc4c268167ac2aaf4a84feaf75b9c539d8539fdefbdea1db7bfd6a59e', 'eb3fd3aa8e0bfc864affb4df62c8623c23981834ca2940e4dfdf8d3b3bf72e19dfa5a71b7e5fc49e6eac8c5fec704475994d26a1f55f952be70d8b573f74369d', 'a8d257b0581e035f25d4e6e2dd5b1026bf3b311280bf5a332afdf0dba329fd37636e4957fcc0bb3a841ff86ce8b664b0cdf96c429da38ccc46196e81f75ef500', 'eb3fd3aa8e0bfc864affb4df62c8623c23981834ca2940e4dfdf8d3b3bf72e19dfa5a71b7e5fc49e6eac8c5fec704475994d26a1f55f952be70d8b573f74369d', 'eb3fd3aa8e0bfc864affb4df62c8623c23981834ca2940e4dfdf8d3b3bf72e19dfa5a71b7e5fc49e6eac8c5fec704475994d26a1f55f952be70d8b573f74369d', '1c3db50d71ff3f0c238496fe9f3bba07f679cc85b596ba05510ff2e7209072243e5b7d4e4eafd70a5f1a9caccd0aca58c7e014164f8f62826dad9d5084f4388b', 'c6caf027953d0f7478870af2c9b1b4cbbb37b4ddcf0b7933800a593fba846e3520e4ef558fb56d758b3b8e9bbcde1f51a0122045e0ed97c81570edd818a27463', 'b83d75532b9bbdf77186dcbbd36c651efc8fb14a8a0098b85400f171cf629e083430e325db234adda930f7f8caa1b2c231588a8cad0371ad78b0c69b8715ce3b', 'dd16c9769f80d71460a37a466b4be26f2bde64b752b5176253a20a45cf65fba88b9b1af85322fbf0dca3ab3ac06a8aa1065ae2f13e446ada0a522a0a39c31b95', 'd01f66811d95864c450f668de83583e17f387e65e756cb90b295561552641b03822026ff73f3eae4917e054d4151f4498a896fb761da31e12f15f493c6c449bc', 'f8e36b14feac1c634d4bb242f38392b7783e41f3443d1a7985f32da76ba4b56daaabf8ca18d6cb4cf77bcf2f7d26ae93a3fd08f9d2805f022f48f575c7448c1f', '566ee388c2547ba54732d494660a7837c465b396e7326f5ca9fa5b73986845045da5d303722f1410ae308906ddf2c9f35011553966c731c3ba753ccf29139785', 'a6c46798c8b627933bb5f9ed4a35c89c44d70a068145ce80c3b65bef32994904e41c203483e423ac5f583d85e4a4585e30497ea7912eeed1c30af3773c600138', 'e667ccec91aba2260a2714089e1d86acfce9ddc861933a20bedb49495761b025533fb739608eb3950dc620f27bc525de2f661d2f1a8333d003446949a8c4aafc', '6482d44fe8de65ac26701fd71f33f26711a261bc55ea493035f6ad7ed4e88e054b6514bd93d1a255c1f36d44b8fe04fc4a27041bc879aa491d74e127d0aa2df5', '89bf64f5aeaa6c472b709705352522b5982edcb8813f312f8b87aafdf9df709c819c0317db61d3a057c2e6adee16659f2229508f6be66c81a836adf570611511', '6482d44fe8de65ac26701fd71f33f26711a261bc55ea493035f6ad7ed4e88e054b6514bd93d1a255c1f36d44b8fe04fc4a27041bc879aa491d74e127d0aa2df5', '5b6e866c1a3ebe63827bec5692f6dc507a840be4be98ef552cf50bec49893cecaa1f6f58b85ddce1ffb533dd6483ea2db2afc36ee2eb7bf9edd16232b26494f9', '6482d44fe8de65ac26701fd71f33f26711a261bc55ea493035f6ad7ed4e88e054b6514bd93d1a255c1f36d44b8fe04fc4a27041bc879aa491d74e127d0aa2df5', 'efaa0ab6ab95c88863280dad13b64836427e8e9d0a1cd73bdbd67fe87e0fed68b27bc8b039caa017a4e41f37e3d4488a11a65063075ebef6c4d9f7ef0b5c860f', '6482d44fe8de65ac26701fd71f33f26711a261bc55ea493035f6ad7ed4e88e054b6514bd93d1a255c1f36d44b8fe04fc4a27041bc879aa491d74e127d0aa2df5', '6482d44fe8de65ac26701fd71f33f26711a261bc55ea493035f6ad7ed4e88e054b6514bd93d1a255c1f36d44b8fe04fc4a27041bc879aa491d74e127d0aa2df5', 'cbdf94eba740ccc41a7117aadb8d93c71590cd3de6fea6688931875d0ce30d09d12aecd70d4942ae6e79a321e12f69e662b1e39a4e5713490af49b0719c1722a', '5dfea90bf1e2a05222ee635fd749f40627a5be88bafcbf401d1d36989cb3b4b7fc42d85eed2a5c80e99544a62d9f775179fcda8517cec6196304c053356c3a01', '5010f0cac943238339b8de17d84ed498b1e3cfb076642e32214d6f98d59bc5ff9fdec1e7e55e48ce5fbbec1055ce8f8fe3bcb012d6697a8fb8d7e8aec079a756', '5dfea90bf1e2a05222ee635fd749f40627a5be88bafcbf401d1d36989cb3b4b7fc42d85eed2a5c80e99544a62d9f775179fcda8517cec6196304c053356c3a01', 'c2756bd4d9adec934e0a330f3f717c147f9421b54a5ced6e7e7b314b61dfc4d02adc211d2f78779c02457161122418ea4b62f8994d68ca0c4b7d04740480c511', '5dfea90bf1e2a05222ee635fd749f40627a5be88bafcbf401d1d36989cb3b4b7fc42d85eed2a5c80e99544a62d9f775179fcda8517cec6196304c053356c3a01', '5dfea90bf1e2a05222ee635fd749f40627a5be88bafcbf401d1d36989cb3b4b7fc42d85eed2a5c80e99544a62d9f775179fcda8517cec6196304c053356c3a01', '5dfea90bf1e2a05222ee635fd749f40627a5be88bafcbf401d1d36989cb3b4b7fc42d85eed2a5c80e99544a62d9f775179fcda8517cec6196304c053356c3a01', '19b4dfa832ef94bd2fde1ce28b3eb2afa231785048b1d88ac03f964e39bdf8d873c95a63076273fa724a5250f32d59c4c2abf2302e07255fd2e2613b8a045781', 'a9c781be77cbd4496520a08ff71ff079995f1af2dd1654ba5d4a13cb311c4a74af25e9c1439d8e06c76673783aa425c9c7c42bdca5f44c1c6ea8244605cc18ba', '462af7902775a4b8cb9c8a3f4748711c07dc9b2fdc2bf9ce4c0f91a86276f2216e5c3a712674ba65d3c0539fd2901cf16239246075a9f4f83ba300be8426ec3b', '46dfb0dad104a3692e3d9955f838686a246f4a191e7076ad4d0af1bcb5011a53484c129159bf495b4957cee31114fd44d05567f6d6c5fca67b474c10ecc2cdee', 'f74353fcbc3ae41329117dcc6d0f42fb54c6d863a06c790961a02b73ad8bc82e67f67e8a4ca1edc9627abac2b5c47172c55f963b5929004cb4e0bc2e53ac115c', '46dfb0dad104a3692e3d9955f838686a246f4a191e7076ad4d0af1bcb5011a53484c129159bf495b4957cee31114fd44d05567f6d6c5fca67b474c10ecc2cdee', 'ed070bf601fff87eb57a8d3ea9266fda7a7ba7cd1eca837540b22ebdf2e7e33042a274a968bef112176437a2c2a924a8417846741a47532a88c00e04ff668839', '46dfb0dad104a3692e3d9955f838686a246f4a191e7076ad4d0af1bcb5011a53484c129159bf495b4957cee31114fd44d05567f6d6c5fca67b474c10ecc2cdee', '46dfb0dad104a3692e3d9955f838686a246f4a191e7076ad4d0af1bcb5011a53484c129159bf495b4957cee31114fd44d05567f6d6c5fca67b474c10ecc2cdee', '46dfb0dad104a3692e3d9955f838686a246f4a191e7076ad4d0af1bcb5011a53484c129159bf495b4957cee31114fd44d05567f6d6c5fca67b474c10ecc2cdee', '0d25ed99cb34aa432e7c823550ff19896b30d1743a86afec65a136ba22ee828c914a4d06734f671db182d39fae0861cbb75d5a0f86c5f5dd2442d05168ec0989', '7ae23fc04315c742ec9189aea40c1c90e60b22c31b806420da2b017a898412db9f0cd652c163d51ac4a46aef0766904f2873655c6f930ffb16d9ff3e948c7174', '8bdecd365978232bd4fb2e49c3cc3f0b793364df7449582b30af46670ac3dabcf777564009dcdd2953a3bdc201e7a29c07f0e18e9e07d9299a3c0a2714b2d4be', '424934432b434541ab32bcb05835e99b466cac9e508aab5c13682aa10345cc3080a10fa77d72e6cf610056a7b4eb707c5ca06670afab40b43646ba46d5330406', 'b201024fec9f9d7fe3ed90e41abfc1be1f2270ed0cf1e40791051b9d727462130a2bece89127e994c6054c9ffd240f8c6348f953aecf55471038e979e3cf6e2c', '5880e15626cd2c368ed99cd62f7c80037d8c963d999eda52a9cb5c6bffdfc9fd5da52be6ca09aba69e9534843c90566fdb8e8ac9b89d6a3876b3ce188fe1210d', '84fc0339e70962dae3d435b6107b6ae465c58835e70f658547bed2b8fa3e75ba4a13f93bb379672f3c46aecb1452b5df59e337273bdb06584ce15df4608ade4f', 'c631439052aa87f9d9d9656af7d3b6fe19f7ff29387fadab6154c8edc8c5700e566bc390595183ba23e4d3116443812c365eb9a3cf45d34e33bf2f2007b3fd63', '83126272f036555ac329b3530641fb28980ccda887998f682e0931511a4bbf40818d58f6088c82aed2737f71d98d719f071f954599d59b9321aa5546018d1de4', '835446d68bc3bb8f407fdd11cbe6057c45f83cebde397fa5eb4c5119eeb4b00ccc199725cc0d9f713be642c3d97cd7368f6bc9f8108b82c401b718a390b0bee8', '508214e90a08561729159e156bcda2a0158a946694655e18cd59ebf8b43b47cefb038d535866ecaafadd8b7efcd434b6f3e076b41f46b4d1d29fef093f37d1fb', 'e8eb99626053c2d0874596b58382364af8eb462d69ee1a93f0681077d4078b04c3e1e73fcfa4b5f99ebb5b1d646a40a3fec69c1fbcff14a656a47150f95a02c0', '1f8551551b6f280f77c0ae2cdd3771c57d16a07453e5be772c16e47b13537bcaeab37509c15d7d65e97bfa02141f32150d26dfb5b56569a6ce4c3828c25b6614', 'bb455820474cb2ad7e99f1ba22257812ab7bc0176db0ac79aebac0a4706c96981991e7e469af796c08875b9a919aae7afcff37cb84040c052be43949a50fd36c', '9c727cfabdf45cbb6081da2d1cadc9abd7042ddc2d82a1c42fdbf38418b146b39f2b996071f0e54e9cf362365a5cdc364b2eb36de2fb3157c7ae02293fc3e911', 'afc8dc1abe295c2a6ed20290e3adc4a7b311ace142f2ca6411d0452af6a2f72f49aa26489ff75783e173cef11f967df120ef4887496479ffcdfee9b24e69355f', '8e92a45282cb7728c5cf1b9bba504d6caeb52c6cc452b67d806341564e7524236b731be5c84df847cf1c928426f49317e8db6d0f296f3f6cd9ca32a8fe21eeff', 'f2a92a62069a5ea63680badadee32be128f2c3b5cbdc2331c0c183a38daf5cfe9b3018e1a66b62c3687ba60b82156cd00cb00355cf155a4285634276822bd43f', '9fd5d54e672ff54820b63c702b5bc27ffc8fb1206c5b026f6bb3ad9b81c43230cee1c7461f3b550127d5b445a48ec02bbc12e90ee6f3a9ca2cee6dce373e5fbf', 'da7f1519377ebe3f1e568009080bdbf764475e6ec457fcadd1fc4026574730403936071d92c0cbe90d7af5628ea98b3b2fe01078e6269efe552a011202d4d04e', 'de94d407ca63d05ed8b119932eb6a6001eeaf838fd503834b2c7c575c4c1486251b1f223980c8ed8e6e2398ad515275c4753abbfc46598bb40ab36052d41765c', 'e05489623760517f04446738bbe48cc1c38c2f213cf22c99a2ab8d947d29516f947c4d8d033619ca3c2a0634e7a91afb494c7fb82d015c1ecbfd991c2a3543c0', '05bb3ebd2fc32e5367652bbf905ffa01e3525f36de111b327f6a2f54425c48eed552b219a1d4cea36a1415f80c09034d5b8dc4989c1446b866c7d4fa5e47af90', '228a2ee361634e6c7c653a2c7a93cf8198a3576158a55c6350a913887ce93e1e8a23c7bd4f84dee8f4844b163e6926a905f9a11f4153285d0a4ea98c19d34b29', '05bb3ebd2fc32e5367652bbf905ffa01e3525f36de111b327f6a2f54425c48eed552b219a1d4cea36a1415f80c09034d5b8dc4989c1446b866c7d4fa5e47af90', 'b8f25268b18ee5fae908e87ad2656af2ba450ddc94aeeffc03cb1ea55390bd0eb589ad9eb769bf199be27293c4fd68b066c642be91c01f2edc86fc177df8ca7a', '05bb3ebd2fc32e5367652bbf905ffa01e3525f36de111b327f6a2f54425c48eed552b219a1d4cea36a1415f80c09034d5b8dc4989c1446b866c7d4fa5e47af90', 'dd0bca72de6062a4cef2c2963d476fb48ee309b69f77ea6cb26139898afa3957abc4f2bed40b4fb9c919b41193b814270c50189a4509538a8f56564dbb4a6a83', '05bb3ebd2fc32e5367652bbf905ffa01e3525f36de111b327f6a2f54425c48eed552b219a1d4cea36a1415f80c09034d5b8dc4989c1446b866c7d4fa5e47af90', '66190ebc2da94d91d277cca961566f729affec4702acc0ad92cd434db68ef1bac9373037f0339c4d6a3254ce773760fb394d2cf867ad84b2ac00c6fb54f4ab2a', '05bb3ebd2fc32e5367652bbf905ffa01e3525f36de111b327f6a2f54425c48eed552b219a1d4cea36a1415f80c09034d5b8dc4989c1446b866c7d4fa5e47af90', '52cefc00aee0fa30b8626b6025606f49a8111a2adecc17f88cf38027ba3e59e7d1a328d1b72cb5e2357b096cc1b7a547cf3f18879ca1220e3397b6f2a3e2e9f7', '44eb2b5ec32dee9434d00b95d4d22ce3d3a0b0d9700385b24d8b444cfb7ae08863280282bd0e1041690c939b395d202e34794bbb9986d8a57eca93ba0c02fc0b', '657221d18e8e2f9088ab865522349864b30255b8ed1a7db4df95dca30833b4adc8e9ba691bd8f976037e0ffc8a410c61b36467cdc81d5fd31e0de616460a839b', '707983e6ed7301340a61cc221f3cdc979b5c4471feed2c765cd145c075b0d19a23167951ac7ccb4a2a1d6bc282383f0f67b756746b96fe0fe269aa9e9012832b', '3c2ac1329e111d968462d1fe49ce18e446a1cd09cd1c6d7b32ef667b865a61f0ad519879bd01a4950b5a919ef9cb3ad3d198980f05a99a4b32c6d23ab4cf2c6f', '657221d18e8e2f9088ab865522349864b30255b8ed1a7db4df95dca30833b4adc8e9ba691bd8f976037e0ffc8a410c61b36467cdc81d5fd31e0de616460a839b', '04dd291733174f17fe4273bc882fa9a5c46141ca2187a51591a0b8e5d52c1fd3e7fb2c6cc3f40d660b6e9306c1ffb2ab30064320fc5c32b608fd881fd3dca4fd', '657221d18e8e2f9088ab865522349864b30255b8ed1a7db4df95dca30833b4adc8e9ba691bd8f976037e0ffc8a410c61b36467cdc81d5fd31e0de616460a839b', 'fd35181c11b09326b859b482541adc5a494e7490ccc7e16a85a70c8a967a71deac470938f3c18c870080f8b1e18ebd54bfa6211f8447e47fb87a2656c74a7f9b', '657221d18e8e2f9088ab865522349864b30255b8ed1a7db4df95dca30833b4adc8e9ba691bd8f976037e0ffc8a410c61b36467cdc81d5fd31e0de616460a839b', '802051a9fab469b03d99d0639f2eb37e10a21278b9b453a8d4fee2b599415e06c64719f80e1732be349415289a3ff345b33d9178047660f9d431596286dc6b7f', 'b0b5e21f19abe05e279f10649e37ae1b67d9bfbe15cf132dddf00d5f658d0356775e536f63d81486e09691da8b818252afa8aa25b4ba4d6ea3132900c2e1b886', '012005475f2fc8905d93ac7d97029f0f35f17cec5651c8ceef0047a46adc167cc729045a4daad593505a601d36b62dacb2afc7cbe4d0a209032bc44e46c1d688', 'c4e898c0f2735b15d6f52d9d1de8844b1887820683de41a219144222ee093470af86ca8505f1909329e628c11606e0ca6d7b9baad6fe88f06b816a190dfab91e', 'ebcb0ee634d7919113726c1a7101f866cf883c9265a3ed1378bec3b586dbfd3916a0fa0f63da9ae23873df9587f156bdc21e44f292d94b26db31a46f6a905313', 'caec26e5937a19838ed0c578ff7e32e319e9d6cc2820dd653c9c15efb1874c084f9f6506df55859a7a3ebef78eda560510cf00ce83968685fc7f77d59b84d361', '9ff68339fbdb9044a7e2d4e794d2e46b0f2684e93f7871e3562181a842ab6cce64bb0af71eb49b29408172c4309855aad9dc8fa558071ba187507e76a85287ac', '07777593a30b48ef23e6e43663e8d48e1c8708e1f7392086f5b6e14f8558a07692854d77286a21c51c1b2119782390872d378d04c70cffe1929cb32d297e77b3', '9ff68339fbdb9044a7e2d4e794d2e46b0f2684e93f7871e3562181a842ab6cce64bb0af71eb49b29408172c4309855aad9dc8fa558071ba187507e76a85287ac', '07777593a30b48ef23e6e43663e8d48e1c8708e1f7392086f5b6e14f8558a07692854d77286a21c51c1b2119782390872d378d04c70cffe1929cb32d297e77b3', '9ff68339fbdb9044a7e2d4e794d2e46b0f2684e93f7871e3562181a842ab6cce64bb0af71eb49b29408172c4309855aad9dc8fa558071ba187507e76a85287ac', '07777593a30b48ef23e6e43663e8d48e1c8708e1f7392086f5b6e14f8558a07692854d77286a21c51c1b2119782390872d378d04c70cffe1929cb32d297e77b3', '9ff68339fbdb9044a7e2d4e794d2e46b0f2684e93f7871e3562181a842ab6cce64bb0af71eb49b29408172c4309855aad9dc8fa558071ba187507e76a85287ac', '07777593a30b48ef23e6e43663e8d48e1c8708e1f7392086f5b6e14f8558a07692854d77286a21c51c1b2119782390872d378d04c70cffe1929cb32d297e77b3', '9ff68339fbdb9044a7e2d4e794d2e46b0f2684e93f7871e3562181a842ab6cce64bb0af71eb49b29408172c4309855aad9dc8fa558071ba187507e76a85287ac', '07777593a30b48ef23e6e43663e8d48e1c8708e1f7392086f5b6e14f8558a07692854d77286a21c51c1b2119782390872d378d04c70cffe1929cb32d297e77b3', '235fac3079189c8343897764153f6758c8ba727a366b1e9a10abe55395773ed88d40789aa7cd8a33c1e4b01c8f7c112ec90d685b7f70181c5003f295eda9db09', '7a07e8b6625ca41c72ceb43d4ec0a3c0d384f4d117232f4fd050c24cb4916731dfed79866566560355efa9e53552b4515aa060e6e740ad991b1c2d93ffb7c642', 'd897c05b2cd462dbc8cea43cb752b3a0bc3f6b3c24a095f40b9ed1859f9b929e708fa71d39e116cc2fb9409e6ebb39d4e364bcef33eb5487af048fb66e3412ea', '4cb422dad7fb19de0847207038ad21019ff0f66092f3a96ab27c605b9bac024daa56b2457a06c18bd393a3d05f7db200a8d1379eb2f60c97857f7d550e562c08', 'd897c05b2cd462dbc8cea43cb752b3a0bc3f6b3c24a095f40b9ed1859f9b929e708fa71d39e116cc2fb9409e6ebb39d4e364bcef33eb5487af048fb66e3412ea', '768920028617562c9f5b2f5555481d375ec7b28ba841047fed5a7bb8b271640336f0910deb418e035daacc04c018bb917e0fa4773e9fdb6146807c78dea741de', 'd897c05b2cd462dbc8cea43cb752b3a0bc3f6b3c24a095f40b9ed1859f9b929e708fa71d39e116cc2fb9409e6ebb39d4e364bcef33eb5487af048fb66e3412ea', '0833c198e316fa41f239744b3d5a3bf30342d2368d5b7cf6c9df0db699423feefc44aff3fc0986402a949f8c9350c74f9bf32f712409a5cd9d294d22d51dca7a', 'd897c05b2cd462dbc8cea43cb752b3a0bc3f6b3c24a095f40b9ed1859f9b929e708fa71d39e116cc2fb9409e6ebb39d4e364bcef33eb5487af048fb66e3412ea', '86c156501a7c886d10946d7e386be9c29835bc7d17c0a81e3b3d93f02b45872dd198ad8ecdec6e1771573e8fcc7c85329be79f63bc564e75430016c4fb0c18de', '6ec280e5558c3e9e54eff279850cf4fc7122ca7c7f8d33fbbada2eb47cbf228beba6eca10f3ab9d0a751fc07774747409e1a504c1adef52cd9045d13e95a4c63', '69c8d8d09bbfc8e8296960aac4127133483e68ca3f7730623f0a903992a091403c569fac510982aaca8a56222463073ef6505d0eb65b2843c99acf68cca19de1', '6294aaeffe1ec8c7a00a7cdd4b2e63d0bc4db94848ad880bfad6673ed3900a8a26f54df154a18a988f3e75c864733cd3cef0863ee8c06b8eab45d347cc856a73', '99f17c3435ad95598c1871606faaff52631e22f46ca4ba1e98fa92b2ec4d6dcbad1f21e6444038af211bcba2b9e1b952173e6221d2bbf4719f9b241cc479b94d', 'ce26c44029c481c7006f57435491debca96069c3e9cbe6179b0913590eddc2e31df50b41bde8af4b17bb3023d29a990c22fe58f3322290f3b61e145b01b10f68', '6a0ff8ca187d3240000921d6e5486d3720b0c3b57183b2bf634c7cf1beec6de5cd7f4a53e7fb5110c807fc9ddce3c8b696ce153fa0d431b3fa29edae38704e75', 'afde9925be2042956bcd28b34d4c1832d1f28b4c75e7d1d66bff2b44799d54dd69c200605f8bf46468106e90bf7ea9a02a5e04ccfd126821991c331bec00d5a0', '0d92668f6e6e119c77ff028ad200f647613d0182cf7bdc0c12b48531ba09cdee7a67ac0c4895c59ece5314d491af9513a57764089db13ed7f3eac9434ef0f441', 'e373949e7e45a34a916451fbad960337f02780466d0ac62b90df5600e8b5cb4662c1198976af2f5046ac7fb4bb7c47ac8f07615f69bcb29e44282a7546b16eb3', '6da1a31ee9f02efd93cc070b3d92800105146f44c0d327aebcdef33fcb2c8b679f16ccbd07ad87a2f1f98f7c7c0bb57be7fb5fe7e55bbc2d9dd3e69a3c8307d9', '69c8d8d09bbfc8e8296960aac4127133483e68ca3f7730623f0a903992a091403c569fac510982aaca8a56222463073ef6505d0eb65b2843c99acf68cca19de1', '99f17c3435ad95598c1871606faaff52631e22f46ca4ba1e98fa92b2ec4d6dcbad1f21e6444038af211bcba2b9e1b952173e6221d2bbf4719f9b241cc479b94d', '69c8d8d09bbfc8e8296960aac4127133483e68ca3f7730623f0a903992a091403c569fac510982aaca8a56222463073ef6505d0eb65b2843c99acf68cca19de1', '99f17c3435ad95598c1871606faaff52631e22f46ca4ba1e98fa92b2ec4d6dcbad1f21e6444038af211bcba2b9e1b952173e6221d2bbf4719f9b241cc479b94d', '69c8d8d09bbfc8e8296960aac4127133483e68ca3f7730623f0a903992a091403c569fac510982aaca8a56222463073ef6505d0eb65b2843c99acf68cca19de1', '99f17c3435ad95598c1871606faaff52631e22f46ca4ba1e98fa92b2ec4d6dcbad1f21e6444038af211bcba2b9e1b952173e6221d2bbf4719f9b241cc479b94d', '69c8d8d09bbfc8e8296960aac4127133483e68ca3f7730623f0a903992a091403c569fac510982aaca8a56222463073ef6505d0eb65b2843c99acf68cca19de1', '99f17c3435ad95598c1871606faaff52631e22f46ca4ba1e98fa92b2ec4d6dcbad1f21e6444038af211bcba2b9e1b952173e6221d2bbf4719f9b241cc479b94d', 'f9b955a356ec7c26994fb5168a115b7ce6533d19d6c170e1842b98bedbc9ee031c6d34402be4e7272c5e916c4faa1a57ace70d50d4b4928a575a17af0ab0049e', '49bd5327b5836a9ace0eb2bdd0db695bbde8b2689d78f9c925f90c00137afd7c7b02a2ea1ee187f3db91f9db4c529731862af5f404c51f42a5ba85ae4acdee0c', '185a981123f1d907209da4be08c20614719c98bef1f424b2b56f483fd48b45bbf0f0a35d7cb6cc0e7871ee702b74e2990de061fa2a7d677a275fed3cf9d2ba0d', '72d738e281b8a8293d98fb7b9d12a66ba03052bdcc26f7f690273cf3e1a367e3c5c7a3ca39db323473cbea1ce3d7b03e552a60a4f22d48ce21882102e629fe26', '75c198bce9d07dcd5d08b66ac72348267685592ee7f99cbeda3a832503416173ca523900d0b56b4ec19bc5ec9189ce235dd9b85136de188815490b06e26d59b3', 'bb18e27eff0c3a901955f114694e976387fe9e1fe766dae72e9f1df65308f8b2012e139f9cc7f78c9c286e9834cb9528c924cc31f3258920e707f05666058b50', 'fa25dc1089d8e626eb2ca9d5205b718ec48ce0a8ecf57f0d3e4ea1af3f63d3b4035945b356006a70ff3d6f69237d245e760947e486809943802d12de7fac16f2', 'a92483516767547d261eaf369e1db868e0b5d5b7ec6a48a509dd991157b55eec8771c250b74d4778cc244c5cad482b60f612e795c4dfcd70b9fc29fa240f7ad2', '67c48afb5d381992ee7904e5e1ac51c92592dfedd8f4070d7c6979fb869a2465516c6c89332a0067c49ddf38d58afad4c63b861647e51f0ab75dab3963c95dd2', 'c57bff3296211b72c5520f7f8368b555659e3cb9908e34a3b972c835724538b1f6b054e54b5fa06ddf06579bb7512994b8389b118007547654e55d9f32a70d5f', 'f53920227862cc8442b62c24110a1397ec449c4c6b87f29e13719ec74617aa663b74a7e555d234ed83a1aafe46f14fdf44fc7f7a17b4264bc60349a97e7f3472', '1262d31e60a85bb0fc8cede6d147aab8b734f8630b42538166aaab620e226897f4d97699897e1b0f635cca9d558c1f4c2d1e490a2ef94aa600a93d66af1a304f', '1827d7d70f7cbb4901da639b0910fec877939344a4aa6ff8155f89d4a981a87d90dfd735970f117fa77875d37e45d508af1f3f708f0d13903d293035d5d1e856', 'c169dffc5015753710729dfa34603cba429d4ecf0f32962c96a8950278b62dde2c49844b2496b029867e3ff4fcb62862e33e2832108336136bf194599c17eb13', '6f185818019586dec6631fd85ad5b76d4da5aca3df8d4a23651706ce4555ed993540acd93c0005262859ca2512feb563188ddc11b96cd71a847f47d0d3fa9c0d', 'a95059e32f00f31e0c59cee543a6824b936e5ad2090f7a7ca3dbd11397ebfd7e5dbbab105f4fdb33f4fb38896916eed332cf836060123d6bb0bac8c6897bb962', '7b69499214aad12c43469e010548a112bbe58d592c1882c7e95b0903fdaeacb07066f3a31d6f0165f7b55b9d3e96e70734603a37b0b6aac6f854b1a0194029dd', '87ed675f817e6b3e22721a8faeb2740a61e6d408d23e258c36d32c0b3303692fc7bd87314689d86db628eb1a86b3572ce54c14ce1d5a7071af25384c4556b3ea', 'f4ca2c7c6feeff5381537851ddeca8e3d9c07dedd7ced2d9d2807e2c672159ce61b93a5fd1dd87e17f759d9b9ba7c4b3af72bdcdb4fcdbb6e13f58995122f78a', '37a8535090d872404448b48354ca60557c00a6864a8a5115cb6d1f3c99dba17b0e4d9524acb3035b64a21f969c5733b83d91433b922d96989e65c404973ade28', 'bc85b889ef98409730795d5c8d3d1fc02f2919926b63598c6c11dd00c7051b8369e34d5768a65e42ac4250fc51ef7b0d612b5a8e2e7ae5303ca8fe2b6756d951', '8a204b52c0345a53191152ffcb1bc2d59d4aaa365c872accde1e169d3bbb21b8a359c6cb946f762a8aa9875c4dff915f91c8dcf82f1518267bf50db006c99fbd', 'bc85b889ef98409730795d5c8d3d1fc02f2919926b63598c6c11dd00c7051b8369e34d5768a65e42ac4250fc51ef7b0d612b5a8e2e7ae5303ca8fe2b6756d951', '74c6b3a7be7bbe87a0555d5902cde46c7cb01e50746db2780afa84facbdccddec35f18c82a5d07536370640fc53e72a75b5390cc1b74ab4ecb4915877825da5a', 'bc85b889ef98409730795d5c8d3d1fc02f2919926b63598c6c11dd00c7051b8369e34d5768a65e42ac4250fc51ef7b0d612b5a8e2e7ae5303ca8fe2b6756d951', '90c54a95774be0ac3f9bdd1e5b6510043900f79d9033e267136a0aabf4eb578aa16a244bd5ad770eb586ce0d18fbacd04284a918a336433fc053857eb6653c83', 'bc85b889ef98409730795d5c8d3d1fc02f2919926b63598c6c11dd00c7051b8369e34d5768a65e42ac4250fc51ef7b0d612b5a8e2e7ae5303ca8fe2b6756d951', 'bc85b889ef98409730795d5c8d3d1fc02f2919926b63598c6c11dd00c7051b8369e34d5768a65e42ac4250fc51ef7b0d612b5a8e2e7ae5303ca8fe2b6756d951', '78398cad54d1a7d7eb46b56d47397621c6910ecf1a98f11faeed3fedfc38a23322e241ae95564a181c7421e82241606b8f74ab40b857600789c73f34396d1685', 'fcc9b29235b78a005f2ba3049397400a4da40d27c61f168f6ef4c9f279dec7f66688c3283bae1f39f70e2da17094d5f0bb4248da21a1f22c3b0ce0af64e1837f', '6ad43649a6e45de8ccb8fe9af19d724601f2f43559610de7c1531eeb8f634797772f2f3e1d05b8f24dce3e6cba162009479bddbbb8d66d75f3430e9777fe8db3', '89d8040adb4be143585f436659b8a435f90ae923e7b3e95f5677aea4613a0cf8a259d40f1cdac363c3cbb7d055b5a60259f6fc6d3261f80fe547b13ef8637588', 'ec6d4ed41366994a5bc4891787e89a611f0df1a84cf83da0c6fb50729dd9640bac8a7ad7936db7bba30769b4343c2dc5fc12b1487f08814165744d4f5f2aeae6', 'b0fab8c7c6701f5e7f0b641fb2679f7ff5841291b58bcf222f9df53d0c6f001557647347eb5c49f460a36b7a5a2e57a705b6e2ca09d5e12a6c1b0ad5efae0a00', 'f05de9fd1f2e9ad75a46d574cb3652ddf15c51b7856bf08a60aaf1f7c59a936dfa0fca18e9e7985e9f52b585798323df5540ab69f576312f79b1844d09bcebbc', '277faecf7c7e3152fbe0bb2b0fa5e92fa2067320ff35b66912199d290687eccfd9b3e1819f885e5477c4f0741738c8adddb809482c2686b05a6660a9ab5c5504', 'a4e3043802172e9142ea16f29ce61c006f739351fc8f1fbc39a2cfab3106464de4511c0503a189ebbc0793cd450b5b33cb42d07ea64b16b6bdd22fbd28b42cf7', '5fc817d3d55b4d9c9e36b9c0a7c2299fc5b40f23dae7d0680678e941835004c974cf5447e399f89409c53aa57ad8e86e3d78156259fc5dbd93b22f7c32ca9865', 'f631c1c895230cff4e0e1a838cf079ff77f1895d499042c51680703fc6181b56f63f2109c21cf713513dfd0413c1509cd2c62a46a507bc5b9632c148f6695ae1', 'e023dbdb90e0bdf8e7554aa5d8fc8ff0c3892d11c65d9a798c7329b3000fe6be6c8e67f2a515689d5896399b52a2d8657c5e4b04180012040793c3124247243a', 'f631c1c895230cff4e0e1a838cf079ff77f1895d499042c51680703fc6181b56f63f2109c21cf713513dfd0413c1509cd2c62a46a507bc5b9632c148f6695ae1', 'f631c1c895230cff4e0e1a838cf079ff77f1895d499042c51680703fc6181b56f63f2109c21cf713513dfd0413c1509cd2c62a46a507bc5b9632c148f6695ae1', 'f631c1c895230cff4e0e1a838cf079ff77f1895d499042c51680703fc6181b56f63f2109c21cf713513dfd0413c1509cd2c62a46a507bc5b9632c148f6695ae1', 'f631c1c895230cff4e0e1a838cf079ff77f1895d499042c51680703fc6181b56f63f2109c21cf713513dfd0413c1509cd2c62a46a507bc5b9632c148f6695ae1', 'e8d5a0b0d71c63c12304d60b37c50dadb0f4c7d9b94a3313ee09d00485a779f6cea41b6d5f6e87aa597e3bcddddad7ba0eeab58e51952576961975f1fab821d9', '52cb21aa6c3ec206cde21dce74786ae03dd33748ac190208779d07a04b0be262c00f0246cfb7a1691646e50ebaec513a9318b959686847b0f61aa06b180f9161', 'a9af77c32b05657f8b6d1cd598a3949b310367df586545e21b0000314c0399bd9a11fd20bacc6da150ce1c65371f6055129ed9bd0ac94ece5670d2ab16dbaf27', 'dc39a67971514f0fb3d9ae46a9d3bf4e576331439e06f3ee063ddd4a02bac073d3fc39b740ac2290b8b0dd7732469fcb389a467eb62e069884d176fc9c88a270', '49a1c40f49f112c7be066c9cb92bc9628c4ace8c17f30f4119bd91a779fdab4456975111f1491636ea4fca402039b6c6b5a7db79769ed86468a5b0347f7d7aae', 'e4c95993eb96615a78d70038089a2372ac59e1309703ee9cb51c0d4c0e428593bd3da83698153148490b115cac581fd4d24ead14de7f336e80f473bcca932be3', '16c90f6fa8b1d1737fd945d3e5c39fc62248c00d922c4abe414f74c81d97484fcb5a6fd68f74b85e8b907d34d6cc53f5982590bac4e754388171725054e5ed22', 'eb23b4f60e0814c42d25d616a9239d52f1d2ff6882a50bba4f665f370123df6c102984d03492cf9d31e580e8d4ff6ba02356b6052652613ea726df925f86fea4', '70901ecd8130df477804ca6ed35e2d948d5c2887d3e4c18c3e8924eb31a02f60d66787e6f8ece4d0afa20ba350abb934f84eabfec04e1c428de4b2375004e8d1', 'c3af9c0765e648834dfea4bbd722fbd3138a0a8d9a98a03a89f80632436ea08450ac86ad12f7863aa76e686339965e072fb17ba1a93cad62675992cb9a34350e', 'bfc054ca538903af18be906dc87a423d4384203610d529114afd2e9c97fba949c92f5ed0ce57126e35dc43634b6e0b4c50bce4185436bd5bf8e9c1f5df69afc2', '77dd2075a38c88c0e4effd9f9aa3f327cacdaac9fab71d58f259a58a503ca7e9dae3b40c623d76969eed24db1bbf6e7e90797fd76aa2608cd79fe5587e8e769a', '8b332122e8fc36ed2fc2a14e41ab0566e94bbae02e4b55e6644031ae78248d0d597ad19a86443f57416bb20370874dfa6ae0a5bfa0c515bad9dd4c54dff00255', 'bbf4e91b2857181309869183cc7ca7e5e46b7a5a05e94296dafa4ce044ca4942b52e30a1922664afab3380bef7066affaa1453f35600a734a6ab4700cfb72b60', 'd64bceab4b54ba8379179d0c199b0f3465c7c0d9768175c5fdae8d3355d921d29d5dbc1ce2d6e2732d5747a5a72929e7e3ec3ae71f35f3150d5350a265fa39b2', '3ffcdc4294758f1eb80aec9204f5afedd0353e1c01cbde1a24f9f434f7495a1f6ed531969effefd1685215d751a04a625addd9bb71106d9a480a432b2afbc6b8', '3878aca03c0c35c82fbd2d63fdded55aa7a0024d8331221127c60f28c959b5815232858694c11ecace3ccc6daa3a7299f62802e2460815e56174bb1fa9637446', '431a3274d9a036fb8e9504f5fdee8e755bc80b688b2b629c4e6b4912bd65bc95829a73792df330d7fdc27f5e978c191d1aa3e56b0a79b6fd3c7945469b25824e', '896dcfd123fa45f0804a108a9edde85711b194ac07eb2cc443e564f39d93eec7d5221360c98c09d8387d077e7eb6a3174bb7b7ef0d5c5aa20b526c982e5ef51a', '77dd2075a38c88c0e4effd9f9aa3f327cacdaac9fab71d58f259a58a503ca7e9dae3b40c623d76969eed24db1bbf6e7e90797fd76aa2608cd79fe5587e8e769a', '73438576d6425139ba109cb87166adae10d89f55ec9beb86ef01c3c532b3d9351f1b32c63e13acc943ce44780eb6d8418400300cc3d76d47c3f3f8fcd5d23163', '93b86a5e7bc41002526a7586f67c44f221d5c746f06a44bfb157fb2d947941502119a9e60b8e65d63bb6ecd628318394712a137f699994c3103fb3179f764d9b', 'e53a861d9bd31c0f8caf6c69fba7c5049259a4e4840a1138cab5ba48f56f9efc27393235f2330e6d49f88eb4f46a46e1dd330792c7037e9fc982fff96b0d3b09', '77dd2075a38c88c0e4effd9f9aa3f327cacdaac9fab71d58f259a58a503ca7e9dae3b40c623d76969eed24db1bbf6e7e90797fd76aa2608cd79fe5587e8e769a', '0b94c883ab27ba19d1ccbf22ea04c5089247bc544bfe8d1916fb369b162e68d38630fa0958dbffdf85c19f969cd0c9d212ce43cab9ff6c11fa2391d230dc88f2', '722def2fcde2662ae46ee7b602f416af0652ab53cd541d2c08b1cc52d3896869fbcc4a8bc7e522ba4d1a755546051cc52105faf91667ccc19ab316e603d93ed4', '77dd2075a38c88c0e4effd9f9aa3f327cacdaac9fab71d58f259a58a503ca7e9dae3b40c623d76969eed24db1bbf6e7e90797fd76aa2608cd79fe5587e8e769a', '77dd2075a38c88c0e4effd9f9aa3f327cacdaac9fab71d58f259a58a503ca7e9dae3b40c623d76969eed24db1bbf6e7e90797fd76aa2608cd79fe5587e8e769a', 'e3ae71bd778b118e33cff25d5cc44c9d71e67bd01f9663ea57aa99330be5f34a9dd72e45fcd8f28be34f102f1045ba1bb5affc7668d3d8b4e7a0b2288b34e267', 'e61915693d2c6dd65f2f2b9a7dedd817811f67cccfe6bbe92b971d19d47e5a20e1cc23e6e720604e7c8d1920cac84374ed0a4aa6227a94ee821d84bcb46606ce', '40cc9bcfd889654a32888ac8283c3ec206773a964a076161004b7cb4a8e19ad1c3a58f3919efb581d6f543356d465520e5ef211b2a7a501680a97fdc0574e967', '5d199e4a80d33a640a9b121b1e3342aa5dbfa8b3e95c7f3bae6a544e0b70255aa68e135ac597d87256770a5d7112808e3cb46df84e1114107879122ba272948b', 'c11f35e6dd0debc425b4c349ffea3587ea4e5d364df83daaab416a217a7b2d92dc0a2e0aa0be9db0c0e2d4dc8a783fbc3f0a74e4d743916a72a586bd66fc7040', 'b8dc74231964b1bd5e6ae12aee920c49d13ed496d9c32b460b94e2c1fb7b9b62b021752f901d58ffb22b8dd46a709e2cd264ae083ead22985af626b2990112a4', 'b24f87e66ff3866960726d89bce809297e6a6515f09eef53cdcba4a6581096d19e897c9b8094f51d920770771520e89a144a72cb50e5c3b94d806c96cf24eabb', 'b767ece6aaff43762384f52446c197223da009dbd9034e08ec8dd78727f71fbaba268c28797a4f5cd6d0660985438755e0ff0f023cd59268a6c7e80faffbe0b0', 'b302230a6942f92a7cd2929a3f4d767f412bea968a3c320dec0c69b3472c542a2e5268202875f39951b582d9097b0b66a2edde650c9a8b29363ef68b0845401a', 'c11f35e6dd0debc425b4c349ffea3587ea4e5d364df83daaab416a217a7b2d92dc0a2e0aa0be9db0c0e2d4dc8a783fbc3f0a74e4d743916a72a586bd66fc7040', 'b8dc74231964b1bd5e6ae12aee920c49d13ed496d9c32b460b94e2c1fb7b9b62b021752f901d58ffb22b8dd46a709e2cd264ae083ead22985af626b2990112a4', 'c11f35e6dd0debc425b4c349ffea3587ea4e5d364df83daaab416a217a7b2d92dc0a2e0aa0be9db0c0e2d4dc8a783fbc3f0a74e4d743916a72a586bd66fc7040', 'b8dc74231964b1bd5e6ae12aee920c49d13ed496d9c32b460b94e2c1fb7b9b62b021752f901d58ffb22b8dd46a709e2cd264ae083ead22985af626b2990112a4', 'c11f35e6dd0debc425b4c349ffea3587ea4e5d364df83daaab416a217a7b2d92dc0a2e0aa0be9db0c0e2d4dc8a783fbc3f0a74e4d743916a72a586bd66fc7040', 'b8dc74231964b1bd5e6ae12aee920c49d13ed496d9c32b460b94e2c1fb7b9b62b021752f901d58ffb22b8dd46a709e2cd264ae083ead22985af626b2990112a4', 'c11f35e6dd0debc425b4c349ffea3587ea4e5d364df83daaab416a217a7b2d92dc0a2e0aa0be9db0c0e2d4dc8a783fbc3f0a74e4d743916a72a586bd66fc7040', 'b8dc74231964b1bd5e6ae12aee920c49d13ed496d9c32b460b94e2c1fb7b9b62b021752f901d58ffb22b8dd46a709e2cd264ae083ead22985af626b2990112a4', '1e4a2ba08dc0a13d08a4789cb601b75c77f0e59d6ade3227612c91dec36ecd71d3f2cde5d6a6e94f62d0187873d8375ba75eea59778aee8eeb7b23cfc3ec0408', '41e9e68259cd1914026d6388928784024619f4f4b39f2adc79d250c189eb9fa8d8be55b0253286fc85fe6c5335c08af68555a5447923bbdd5b684837109afea0', '9169bfe40405f5582e8ef654e478049a645210c53bbce88f5146edda0cedcf1feb3b344a77d78560e5406bb461bcef2cf7d4b27d02df3650a22634390dc1d4d1', 'a3cc5c103b73c9ebf9302c8f017748d61e7d35d2b7a89943988095ed7354e3c63f51251b89eff7ce459dfe3a1c051c31263b9a33d9d1c8844f75d1873ba936a8', 'c4e9c328321f6a97b678aaf9479206390cd0553d60165ce89b9b66a76a09c8885aea55e0a24e24d34ab7825f57f958e5fd64ef2a50d44505f18ca1b92ac42d9a', '215256ee8ace4d28b9c9d6cb270a40abc4d0ad4ad1f7ed7abe430c260b2ea3e0ce55ce8d9f7d0a0c40b993d00f037911e2dfb8aac391c15a335c7d02ec6feb1c', '14dc2530e08ce9aa423d57b0372084d52002cf6fb6219870c3614926ebc597c6b9073d28b5f717e095e6378750dcf47c32430ac4fe11876f283412a8ecebae67', '56427fd71f612957c3628e6b71a0b2b8b4c0965eadf05215b3d27843cf1d11f483c6b1272cf2fac452b1f8dedde5071c365e6760b7f4b652b69d3ed7088777b2', 'e4b9b23531b3750153f587a06c4dcb0c472560278c36a9eff11c0082e8a403ee2d134803bf9a04b7a80beb3f8af0c51dc1cc1d7861f432dc1f66d36546ef67ac', 'abebe4d55c9f5673ce0fcf58ba9e882cff68e182062b69761e40bdb99a479a81291c22aafb8f680e515f5dcd9a4a3b1656d110e0f5842f08bcd8a70ed3526b0e', '7366fe28b1fab830cc013952e8d1b0bb7b8653a011732fd889cf31ec85cccfae09d25d1566e407fe1236d8a42e9f3e803eedd8b3a802954fe29504d2acf57989', '722f85bc89e1ef375d69800a4de21f3596812b96625501e2837f34740ef0aa0f69c16772f232aaaaed45c7fb6a3d2fce9871476454cfdfa3bb1c4a097d47ba04', 'b7d19c9df76801c1fd7bddde93eb25549a376665cefb059f4f1267e802608874846fd30a57a6c648661893debd8f316ec20963321aa93d0eeba4d32494b9e98a', 'fef66b38b985d5805bebeabdfa2cec5f2737fcd0bdcb16e14595c2b4b70f4250dbfd727804c3bae763d9e426452efcac492721af92a5169bad7ab6c68089e9f9', 'e6f312300ac2b4ca26671ac16a319e934af822d22e5cbbd696502fa4e51789eac0382a2cfe133005017ab050cb7ccc6d9e7697e1c3f7cb2bab2a5d483cda53db', '1fe6bc61caa5ee15ab2bc206de63b7b10003945d665a5375ac951f8681ad40c8e497f1a6eab7c842f0ba46bf7aca39f93b86b92be8ecc8dd4f20cfd7eef583ab', '3248cae4397c65ced84556fdd0422c0c2b5095c536532d468c9309974941ffc9da5d0b80dde921e7a15144685fb907be6a76809c175b204b1fa00d940f8df143', '0f040948333bff9ba9f4dce0620b727451cebc16c16f9b48faa9bb44f64b859b015d00c9f190bb29c836f4b029b46068f5a0dd0e7e7679ea6c2fa4a6bf32f5e8', '47535e51135bf4eaa527190d6ab2e673874b0359ca8fb391c1696393df0edf2b65a6d9552a717cd53944d0581526f959314083d784b683183526868f58fa0eb0', '5f32260ee5ceae038f91dc3a3deb2e1d4614a4b3d4c52e1fd96a9ee26908d63e4097a994b2c414a68ab05fdf9057a8327595c07a90a55e10b98b8b9ee754157a', '3bc7e66e75d1e3795276b11aea01b99d5df4eb3a0f749b30f42a41a5fd90f3a521344207b04e8c8c93fc899361ca21910a10dacad7e7bea807e0c5cbd5638087', '52db603237b07bdd6ff3559c79c3bd4e040bb15b9194f1389f0123bc17671873d3d8c29f8c7b1ac2a70b409fa0692136f6c69b1e010ca870715021e7bab30fa1', '1f3d5e79ca3d2682b233edc0fbf18ea69887386d884dbe4cdfd7a7d08edfa853cd4890e2ef194995dec86f282ee3d3a856e9b2dc569d7a162bf200d9d9f6881c', '41eb434b160e70d9e749bdf7c082698cd59da34877a604ddec7998b321dc000cb563af0c5ad2bec0057c7bc230a0b2dd09e0edfce7cdb33e81f34ef790421faa', 'd555bdd930abccd3d53beb2020c6bd5a5f9fb442dda698e48a5a8a8376769caf5aee337ec8010f2f1c74c7e5e1e64307cccee2647cd76aa49ac20efb443bd73f', '5dd1f973a108dec374d787ff6ed17b306f45dca8f94ee23e531c4af354fdcadf80994ca7e2461a9c143bce92cbeb2f0ba441ba1ee8acc1d80103152f3c732b78', 'a91fc6cfca141159b500c487abe3c61c5a3c15eb101aaa2b9df17750f1635ce9e80f1501ee0c3aa797da6560ea66b0eb5dcbc5208a98737b150e9d40b3c42eb5', '7e07945cb065f970dd2ea4ab70d5729a593b5deae2635e42229f28bcf20bcc6d8b6218932706e855d9ea95c10a1a301badf30257bea9297e94eb06d68079f4c0', 'f037edd3de7afe1f4e5632b179088dce4a19d068f5e8229d349db7b27c8bcb28556ce5c6e4563cdeba36f8d46303ef0589e75ae3c0113a8dfe63b9ffe2819a3f', '630f04d56206504da6dce0ab510f0a88ae29db76666dfcced782451f28d6c47616e8aa9bf682f7830df790dffa907e11a841158fc91bbffe3dd1b076b1030dd3', '1b899319985adec17904e0aac08239a41be151525adcb8c7b6bebc26476ba05638dbc05dc7378cb0e0fa95b2239988840cfee69ec5ca8e0ff75b684145aeef9b', 'b9e764b0d9840efe0324b73771f9c52f294f4fcd0fae046f4dffafb03b564ebdbc825e8d665b377c57688ce8064076cf3c43caf4b3febc633daaba4e63e5078f', '12712338f2abbf835406fc799e1168949e84710e67ea8384c120137a9cb0c2bbdfc6b2f2661faad97b6e34ea477491930d13767aef8162bdf2f9e7ac1172909d', '604532dc534aff5cc814f6fae066db3ac3a5e6073fb7d86eaad632b6b01e27a52425d00b384ec9bec903a3656efa22160c97ab976df8a2d6aa43cfad581f3453', '8abd23f06d1df8af589b2c28bcd2304b4f2beb17077cd0ae8b78d04994523c7be0f278822bfa79422f11de2949ad2e36b3a05ce770ef471739b8ff155ee107b8', 'fd4b4b2c6f12a91281f6c2ad9e07645bc0ecf958a27742564626d83da0906a0d1f55f2803e23b3fec4fd91de93fee9d504105b547486c38af13dfa0ca8626c23', '9c43d137973731f38550dcc3084ffe7f738c14f23ef3326284b0183922fe742af688fd39e8bab767e094ce7f5fabfd3f8d4ca5995d706d1a6711f23987618980', 'afb20ec6c5a35b38ae7cfbb86d02a618085f9042575301c632472e522075519fb5d5af3c514a6bbfd2030b2725cad5dd1e76c859129948afa608a925917a6b99', '8542a1a32bf16a79830a1fbfbccce9fd223ef427b35b7199f7b8aca9a39734a0e7eeb8f6985c775750a36b0a5cf7fe4b4412f5c7b3ba2097fa2ad10f00c50e64', 'ed8f58c96f34df62fc2da82aa9b9d4be6d7ba68819e508eff3753b1c8f50d05965b4d5d769bdc77697f4bf9391a2343257837735f7beabd53df6943d9bf34e49', 'f19e424c2e2e366ebc18a24169dfe86c662d3e16ceeaf2ee2bb3f5f22d38dfd02f9de2d6e25c9c495369bf9e22cb59da2d6d1ad1b16b03063ca50968aa499497', 'f67a8c01f782156d155a3cb55f93086c76f75df6ec39b04678800bcdd6726648d3ff89487a9b0ca97a62bb97037e8032ab7daeb7100988aaaaf91e77903fc132', 'd8121bf4eb1c66c1bc4a96e5585d19e95d7e97cbd500c53da0d3757c34b601460c6bfc238c7eea722f3b148522031676d808e89dd69e89073568e39a4cf31d1b', '9ff2f8806d5c2dd03f5c2af7d97ea1aa60a770f35dd4179583059a70cac44918e635bdb5afeb65877bcb92b19c7b288a5866d06b5a898b552be6e45bc568b747', 'f4e9f1b92b991ae6b59c3751a703f7004c0e6f1706a4b2fec019433de35442cd0fdda78238003ccd4122de0bcd5fc2acaa17d0759a6d3a365bbbeee0410a393f', 'a044e4e274159f8ccfb734ad996b196cd8ef68415e0d3fc11a8af07bf6e4de96d0a38c9fd231cb1e9608c4007c6397311cbb3e714d9f2bb6a491c8f52187451f', '3a9005312dda38da73fed169a9ca5ed95ef91c55d6d10facca21fe5248648a36bd859890385ddedad3b84cae73112ae388ded45b654b0b29e97b4053e11ff3af', 'cc4bd6b08ad2c0de6a0567859b074e257f164fece4185bde254afe1ee65b9c01a06bf9846c80db6d83cbce24266e63cf56aa83f058d6c217434c85f4f8ec48a1', '95cc3ab13af89097bafb4fbc7807873c6cc3398c05d5bc94de3dd3ccfe9c66f058ab4e43f280ac3ef254a7b1d0a969254e95e834196671d6fdb15646f6e0c640', 'a25beffd844a7eeceaaf23756c2bf6e02f69566d885f0a8a6b6dfc1850d2afdd62f73e54ffa2cd8a7dc3909aa131c6d88780f458b3b2e70b7fd3f41474ee3e5c', 'ee4c9add08127551b580cd1a0a1fd88dc008878acc567aaf1c1c492bda6cfa6a721ef25639e9b21cf700e421a861b75d5c1629c5ddd1160b0e363e5e2c337feb', 'c9ba62561df01ab9e73079f114e717428bc1354fa92a63346cb189c07726455c68f3cce3896f4e0a62c180f9089a77b2aea3b03e2097d64cc97c354d471046fe', '03a9f61d0bdb9d18ece8d9a949e264d9b3a2a6aa06b07d045e3b68c43bdff435f875d1b9c6b49fec29d88cf537fc611d148d685a214329599a241153e5daaae4', 'ba2fa12078dcd0997a58bd655ea591cbe46cb5cfe2432b71ef7cf0475409a4ad74a3571b3a92c3af70f0b80454782c0a992610bcfcb28561137b65443e862ecf', 'c16a3c2b137d2c054ae5be9929bcea249a85fd446e80b523c5ce838c04e8bde698799645427f5da83b5e61c283e7e77a3c4cbe8d42c49b5cc7450dff3372b029', '2183338e20f0e7faf8f38a5bfd52bc4731d122d6f028b7041e2639b864b804be9dc032dcf862adedd69a9ec964d636d24aecd1d06681c6f6849aa591c07bf7ef', 'd576c5003aae5bb577739d92c1f9740f3018f074531613c021f3dbeaa8e02119a9881df63a631cd27e253bb86485bbd849f492387e0476889eea562eca7cf785', '34c107b4baf6a075cb4e564b07d1245369cf9c23a7abd7b5ecb4765350479d82b97d1ecf116adef63e1042761e80ed5fbfe2332a36089307e7caf8fbf70f0e65', '84492dfc545fe3b6d7cc778b4f88b6f469171d0c4c29f39b670a4cd7f8afb6c75fbd3d811af00b6fb1d9a2152a8340a4d3a7a5460e4c071cd5cb59947a1fca63', '2d48a46c63964c7bb405e650a43ef3dce458b159eb39536c3f32862de95ba0d49e81de1acabde3e581d55cbfbe3789733e99456082f3b3e8a031958acf021431', 'b6cf5bba5966cc709c14dd5321319096105697aecba2fd70f3776eea1ac8759676bbb7a9b53838331d39a8962cb906d0de30df8d0ab5e210f6813d36b4fe57b0', '82b39beaf5652407c64329d86854499d9d315f49cedcf42a4a6611233b0badea894051bf2caf0fbc8ebc86769db559c97eb540805349123bb69e9fe5738219ad', 'edbbd6444a485576021d026a2684e424c4b6efbaad27c05829f9f2a09c2edcdb4eb0f8ca8a274a850cf445e7237b5975e4c9f520b9d9d5835bf84085dae5d7fe', '2f1b50b085ad5063bdc95d6fdaeb3dbb05777e5c289139d84191964d24395cee5066e64880178d4975f6d3e8786df8ad64fc861bc48a01202c036fb7a5526e0d', '45997a31e4539b9d4073e4f4390a2e07890c1db05063e7631083bd3c5c0067cfe5bb0d8271eadb51855b6a113f04660272d8798b7891e144301ee38222376151', 'aabb7d0259edee5f85215af8115253e85356a202f6f4c6221067f4fc597016792066b1163ea6ea72664a2865a4f0f8e14a2047400a4a28b053e6ba8375d7887f', 'fec027cf20f894f01a100f1cf526c8f1ef3032e55fe53d0213c5bda42309bc86a6218518232e9ca761301858336f8255d059236383b5112426d889dab2aeb109', 'cd2213320847eae1a6960ac66c9e88c2ce55f2ce1bc2b5b16cf0581f541030f3a2a683f92924a44da2443b86b7ac3dbea232d799da07860100519f0d37192d9a', 'c0082976d855e892d296da30f25b4488c1d5d56841652a4ca051aa84a6e661eb0192761032eef2e8e3e6718b6e9da024dd87bc5691dd92b81ad3b0f1fc084ea6', 'ffd165b70032db97ac753d27768f1a2f0adc52603941c19a870aa87ab2dbfce0e95e97791010b43441718604aed67f117cd8262c42a1ce22e4fe8f2182e1cb3c', '25af3e95eecaf39f6427d181a9c3b4d82312453ca830177b78dd00856190bbc69ec8f0485296c637d3f195157648227b13dc68b20c2128ab71ed175a53b3ba20', '880dbd60fb06744a1a8c732a58dc6e1e348014080a28c83f8caa31c4ddb3f7f50cbd845b8b1283c609a39005d20936fcfb3363a1ce2b99db26db6b4e60abedd9', '0979f8deb293f886acd1dfcb1365e10eac86f74a886229682b922a650ec5d74a807cb497cf657b39924ed138517e5ca2d61479168168f284aa20876e2f56d5e3', 'd993b2c99f65f67b49928eca78dd18053f1fe4456947ff262957c8abeda1a282b68f134dd3a1d447cd3d4f2bca871fcc54747b9c566ada436a60a187f98e3ed8', 'edc268940308fe7ca3dd043cad3dbda6e841ce9f4d37a8f93343215b5f07cca0a98af48ace4aff888feb8e8a6aafa9b784dc9c2ee3aac82ae4ca2b5f6079569a', 'b961dff4555fdcf9e6d4ace0cfc5d208804ea7e414496300fd74111d9290309c8a83bb16f00fc78a531ad1652c6245820b9bc1e2fbea6e410742c56ed1382162', 'd8e55fd7b3ee93f58d92a09c3d3ded69aa7b205674f1283fb2ff461eac05d75e514cf14cda6cb3b8630198bcb2452dde555e92d50f155034ed509a93e9a8f411', '3cd2d0eb23f73c008a9a689ba950a64955f5effb7f675cbffbc9760add4a8f1451177ba969892a197542de75e14013d2c0078f2df94f3dbf752bf628ee7a70da', '11303d174568e74f6549e41820ca5b26ce4a4b42bc94cafbd2d4667b3bb118c32da1aedc7c07a40d35ad7b02efa0242925880f1026787547f3007f792bfad88c', '6f5e8310781afc139107473c0604de4a4789f018a301d952d3c522a1033adca1d1be930f505f8c2b6d2814a87142a6a7235e52da349522ca81fff55d48660e5e', '9a34a58a9bcdbe8847d70d180d06b4cdaa6f866c7c79e195fb08c9af7df61706462e6ad073cc80cd8c07e5056f4ba9f4a669cdfb17ef8e08f4c0eca228339c03', '7762914433bd95bc71e14177cad83e14e3f3001c935fdd6b5e3a692dd502897bfffe505ced166b92e77461c54420dc306380e7e3a97081b3d209eb50e4c98406', 'c57ae3947af159fc60206a34ca7a01a36df22a501e1ea6e37a5036662e7e0ac0ec68341145ca8200ce085e6453b034f6d8f4f33d4581b96389595cd0a9511216', 'c154f97637f942a1832b43386aaa4db49bf7980d487fa0f7547bd7e7224c50f9a9213c408943f9b52be749c91ebe3065c8e91429e2a0c59a91a699cbee158f55', '2194dc8678aac6cfd52eee0c754fcf04222c08f581e167fea9839f671f0e8ed11e76bd5475e6cb436f7517672b68cc67737f1b971cd674fbcc07cb173347c551', '84646a83aaf664710cfab0c7f470a46ea89d206092bf469d637668a10cef0244c745c258ee2ad605710850bf09ef97dc01c25a6020d2d1968608ad91b0fd5372', 'f567529d0e09cfcf189f41e89e551162246ecd9bd0d76a4015e1667b3e3c7b646c38e99e326c57ac1dabbf42cf88629442aa7eb5f54cd90ecb588ccee138c40b', '6b75e78c9d1ed2925101abadc590e1ca00870ce2ec708f52ef8e24f6cde45c3560dbc50c5f4384a5643f230990c3be9ab43ef8acef8cf93d81c51aa05150ba3c', 'c232abd89abb08b7d843b1d7a80f2b9c5414d621543aa0a6073f63b7f2f9fce1615c14a145cd510785656f2a41ab60648051dfbeec6dc3012859ce24d875aba6', 'cf003a8ae1fac780b6335a240b43991218560c2be2bffef4b2ee563a45c2cdbe9d2e4992c6df34c2d984a75831644d5a4fde851ff050972a93c8fb43a0fecaf8', '73be8f74cb4ec4d721973c0f84062263d6c502d0f3833098ffe5724cf3c5b2cd7b13cb6840de89aac23d5aec300c2d986d7764eb9cdbe1ddca8657a5fe8e1f1a', 'fc640274aa4aa89e49bc51a3b6b0df65cc18d2f9fb4dcf284f8bc0e58856def2544322f28626dd7334088819cd62c86cbbfbbc3a676139264613bea99cfeae39', '4ff6ce7d8e46b237e3d7f0d4cbee8a3752623e4d565d747676c491c2d69c33f8ec0862ba02f7e5d8df3ff18eec59345e07ad0fa75efa4b9b48506c99349e0919', '8d2df46c8b51f62139215024f6e8603895c6d963eca19a23edbf353ab1e329d110db18f1eb709ed75f5306fafb507eb7c6b96c1ee2375c028b94fbf5f048800b', '1f554d5c30ff861104ed6bf1a6df8f45c06b347448c2a8cbd957c71bb3d306956054c126e6bec39df4354c5b56651ecdebe03c07984d22756fa534f74dd726d9', 'c0f06b2e1a0e84b9bdb25da0130e94892710a5836cc723d534d95f163464bf966a94b29c2eb4fed7b9206f90ca6f6f72800ce357e0998024775b498c729e1c5c', '693ae9ef02d0c7e2264ae0d58898ac606115a1c251309a5526a391374483b85b36d79690ac91a086d6a2c03f4621c57b992196465f999c781d8fbbc102d4dc89', 'eb77a9aa72fdb9032fb795dde50bc64503f4eac48439982b1360c8c9d388dded3b471ae8d7ff99b83f5be1c265b4c740723557edfe99f47185ca3639fd7eae5b', '27dcc6fd70fd1329528fb5ed00442902d94bd3cb3cd5c16bb5121ef20ac3cd367480cb24cb52c9208dac242ada3ae65a04d9cc6351b9e2faf2cc63b3fc8dc09d', '30bd77a8a8022a9458b5955617de89ca910c4e6537ed1242f9a8d54119010e1d2e1234dc4195c702a523e15ff8ad1e488a828a8bc7304394c2a3f692bf287072', '665c1a421698a7840153ab128b114cef2303725921f90bc178dbc063453365e7719bac443387244cf618f41f840871a54e27cc3162958a1e0fe2c906dba07122', 'ee7409d1b6a50d43b0ccceac4cc77a970b005997109f2b3112ad4642bdcbb8b01d3023db949f3700b7d477105f394947e75c502ada5c93920a889e23c5070d50', '076f42af84b26bd3db70c1473a553ffe63f5db76511facb80469d7e6f9f767396e5f50650655a70c1c6b4b4a81e4e6c57e2bb7b485ede55d768bbaab12c7b663', 'b1bcb3820ebfc09032d8992b88dc01d48da3ae9c49272efb90dc20cfa87c896c8cd06722ba708f0757803c5543d78a3adb1eaa503832d9a143e8e17b9d09250a', 'a508e340d61586ee6db17ccb8f46a9a31686c557b96de705c9b63f9711a61cc6cf5f60af6adf568af2ed0664498f75cb8047890dfc4c479717572511f923409b', '3ff7133caecd77e802ec38a34f4d5a2991822cfb97404eddac54818d85a59a09f4820ce8eeff4f3a960088863db2488eef5195ae748c041651ea71ac945d12e8', '424ec3e9bc4805b2c0d7bff019ca0511647d2067e7cbe2ffb383e9c436509071c1963235e5af4e3c09fa719552fea66a2d930efefb5a3068b08cfd96fcf6dd88', '0210453a086491d9ca4f967006d7dfc03fe7ad81931898d29619f29b226cedd25ac8c856867d500fecf81c97eb389c9cf85b2e7388bc4bd1ad45cb22a18c4696', '9ce34a0308ca2262ee5d9bc44e2230ada9eec8423aebe07837688b463ac55d543788ded83a6f512242a9c9154d235ab8b4f96753d7850d79e15c5e28ac439229', '327240ee027ec053866fa20eab8e8c8f1b0d856de8368df71fd5bc83e495fdf5d62e608049dcee0bf4f7a61dd71f2af9efb7488d4efc47e8badf3ea2ebbaa182', '976da85a1acfbed7a4b07310da538e4c35c3e4e68fc835398825433ca633e40aa066a26ec1f4ae684f293d43d7bee3fca130dff0c274e640080efb072910c30b', '7ad94a0b1cb33a527183a36dfc8cd3dee9cb5400d2ca37900a194da40b7ea4274d0e97c018f44fe9328000bae08b4a3991384f8fdfe7c0b2e53e37934988c094', 'b76e251665b10bdcab23988bae9d8815927c44b1d8acf63b8b0d1c55940501803aeb9b6532563676ffc32867d24435839992fe190f7624102b85c94515fa9202', '5049b55a14cc7d2914f25e5fe235f05d48a84d85f3ed5c46719a669e46485ec8a5f11479d8c1a78bfc775b5ce25310318b6db5f9f1454c4265f663d5b44b7c57', 'aadda0201ee63c0fa80fb3fab3fc233c7589890204fcdf6e858dd3dc82e5194e5f04a626323d4a6cedd1ed34a74ccd825d60ac5fbc124b4ab21b52ec0ae29726', 'ea3536368ff5e620b785b191894799471043b3a48d790d175379b8fa344aa84d62ad47f7eba1759d67c6b37c35ac0bb90a298a0ffa0e97d3a138cb8353ad89c9', '23a21275b7c19ece0dc53cc31fb77739675b656fe6b76065dc874098f6efe4c5890e941d57221c95ebecc7f317385deadb41925069b6a0e5ed3bcc9870aaac2e', '5217884315abb09fda47839ca21c30e681f89feb5dbd9111288f7ef600e3c6885137a4ed45cdb2e3e83a1ba0c18e05e22d77a8cac069f40f9bd0d4f4ee0be612', 'f4865943dba7b86d9916370135801a2ae186c5d1294e4c811eb2ce7c1450284bfee20314d6fe26536f8ea1ef86e882fa5244251373a06e96e7224edfc0cb3368', '115322878abb78bb6c9b1105b64037f10fdba6cf5f3c75d89d3fd554d4e80a8d5d97fc87c5c0f57c36f80ccb445ee5162738fdc0f998f16f1d9fdc34b2ffc9bd', 'ceb08110077746980c004b8d952b345a8cc166379f68c2a593930f85b30c42294e98e4dfd453b19dbb00748d6f6b3ffabccaae6069740872a5db84946ff957ad', '3d1f4e88098b00237878d6f0a33cdab64d8ebf6fcc14872eeb341d23095879728801708e2f912f4ff51dfbdf635b18a54a837468d7787714f5d2e0fd3a95ede8', '9178df3bb505cc63c2527c7bc0a5711a2c9c8ae114176e6841821782d5984f47ebdf114a2de26fa2adf7f4379d4bce370907407876d20deabaa6f68d6e133103', '431cee88c66e690d9afb1d615af503d79186e57c5e7843d37c3fd7029f1016c246f69892a3fd1773835b5c3975173238d673263f791efb522339c1f8d66f9826', 'f5df2443157269dc3c1a38f5d19b8d806b15500e85e8eec9fc423ef729c0758662ef2029fc474327a885461cb32d4a2dbb29f908c68d729ac6c536d62ff31a88', '431a5feea9186f01a2ca63b3c905da24682c3988139d7444a6abcf7fedf2b6ee712a5bad20fed5cf5a8a5e2b245d0e69546ce787b163dc1f47f76499f8f39f33', '90ad41217e697264e0c4c5160f973e2c741914056c56215c8dee16393798691364e7adc1e4fe405d4acb263ef4b55fb7c7eb4cd09261b3c6ad72c5d649f6b149', '22f74ab4082a27f28b853c8a89daf5670af8350648a8cd89a2311ce436b18e0865fa154d6495d780c27922446c4e709f6ea528b957495a0b517d242780565813', '9e8b63d20c9f60abb14c58a53c37b3bc8d1c4635184eaa764bf38f38548b78fc41cf8009946fee41d1feef45eca2f4e7b0b17eea9b1d88900b87da4e2bfb17e8', '17a413fde008e67b36941a025f13bc4d2c2f54104321386171bdc65f202e3632f9f702bac54220cbf87cc673bdcdc9b28476854e92ab1a4bea7249d10731ddc1', '27fd2fcac1e942e2326057002b8bea28ac8d840ddac821404015d0c98ad24b135584dc486028b1880aab03bc1add3539aff3f59bcbe3c5ed49eb7890c68d8564', '54e17d022a2b357845817e45b46bc74b02e4797d78d50a86ac33face3ba783df75f618624306676b63a8f9dc434ff13b8e54332e09c109db2adb6cdc812e98a8', 'e19f7c424e07e763782f405d1fb419ec29e09a67bf8822a3db91451b757cbdf22f9f72b51b64d4ea95e7eaa8c3c6d58b8fdd0bd1375508ab849023cb4c2be194', '2e3d6e75a2391ef4b2112aa5e9e6cc19112d18c6fe7f4d061fde3ca96309a67869e2c34b5c65b9e014661b22f0ce2abf67d38eab1bcb23e43dea922237dbabc1', '325fe3ec1ce4823ff2490ae88cd541b30af61fcdd5d9ba7572172ef700af2e32d271a9b6380a96fbca1d23c6e7efcdb57e1fe54fe5d6059e7436bbc99c8d4b56', 'eee3f12f8c27ba7101345aeeb60fec806ea543bd4dba75c555fbb5e326ae1d26e5f30357420bef770574d4b849232734c2d16e72bb3815c8eaa24f75cf0ab050', '6c3f8d8f2d511921e639a760f98cd875afe5b3710687062eebdce8a8bd1d70e58408eb8bab41b4c29c1eaf17d2757752d9c54c8d8eafebe9076636e4a0090eb5', 'b837a18837671062c7a9fdf0357ca1f338d5c3528b518befb399a7a4a2164f4612e8587edce702ad3de762f469a15e2150b160240bed373f3497e16456fc566a', 'ddab23b1b638450bc3cf8d67e4c18380f069a76bfa3f20a91cdf7acc74f0f56619b0297080bd6f2e242abd5403b27378e50b19450be3109865e63a80ea210371', '4839896670cd9c47c558707cec45987ed7d5abdeb0002a1f0ed5b653e7b7f21e494f2c07ea87f541f343c534faff1ad13cddc47e5fcb7b21c05e39ced257f301', '06649e402a868536ddd19c935701b57cf07ed9fa87aca4c3bcec2571308d71611a2e4971b835fb94028dd2777b39a2981cddece81ceeeca0a4cfde22a5187b58', 'cc23b278340bd13e14b8dec809ef01ba79500d5228cf2aa7105cb91b3c7619ed245760cf19acd7abe58e5b4e3a42ec8096d63d9d894d99dca7f0eb64edb550c3', 'cb184360793a821fa022a0a7b2a10edce55a357291acdde58458d7f2408edaddf7acbe71c7704994635a9ae310934ad935c8be9d7534068af807753bf59003c7', '46b66a99836444494408ca2fa4043fdb2d51cbf4cd20735478ca9cf76e990af9ebb1a6c74a2482e9ac8f8fed7efba997de31e8290026d4c6cb7e36a8e1be28b3', 'f7b15330f1d693c7ae838be8cc33b72c693bd5bb3bbf3f658fe0ea236512d16831da42397e1f0f21e6a1dbf4b93f3e8e63841ee9ec0bffbe0530574a3936f84d', 'c4c4d523822ea2d154129cb759b766af736f6f250f82c06cd31c86a9d909930ff74893a12a71c5abb9ff0b0066ce547a70beb4ba475a4227aa9d9f31a10578ce', '2993900bfcf20b4ddfdc4d32397c4eb71d8123c47afbe087710087bf818828d7dc69b23325e87fd83b4a59528861bd2f856d453fc636d7f42fbf8036a60aa033', 'c10c066ddeed0baec93557be22c7f4802e18e7955b37565507f57b0347d89f6c0631694730f9ee2a1111d4df37cf2cd5a4733e4dadaec3849e63827d477d70dc', '9c6b4a4980177b59d771ff0d008781f4a04ac040ceb7df499f716a88103bbbde5434085432ce3853aa05f3fc68b594d9dfb071c087cd326ed8fd70f87988b235', '0351eeb050842d7305f4e5e4ee77b3f18f56c257122ded6564e397fb9043b4e7b39b162cde1bbc0351e2e9443595f5d2ce59b3d01d077e30fa369b2241240e28', 'e1bbd4072338d561dd5ac6aad430c7786741debb1c80f1730e8028a7fee63698bfc5de9182c7d7a920b4fc85792bf4af59f6fa4c16f2f9a9591b963b54258180', '003a0b474611486b08bc72eaf20b834cc01bf4274e5c4356cf49429b88520219d0825deda19a76886e265ca17f53e1c172dbf7ea7a4c93a9aaedb1a3ba5b8e0c', '31e43318ed5fb76eba6239b9d7453b35a3ce142a51dd4ac0930a2835e2ec790ab8ac05b4436b068cc7c744c4cbd58f43f9c46aa66134aa6e6b4815d418e86301', '37168431941d7a87aa60bf35578625ae457306bd18c3722916a01fed57c270862ad1fd1f6e5c5eb12e9e797f85bf4d8c53d05a507d355c1c4a719b03d11ead89', 'fbcd86ef7907c0a8c8a6689d6e93b8ee7eaef3db3531d1d4dc2659bfab238e49d9405d4a17c4b09798dde3263b6ae1ae060a85d7c8b4305bf40073e9dc6b94fc', '0c905c25934e462e5d0fea8afd41f2377c0812d2c1898be152903d6649aed380fc715b6663faef9881d3a8ff520e74faa2c301313c4dc106ac067ce0e1e0ef2c', '1c87ef3d639a3824f682b35305d0bb2b31202d7d5c0e6cd79cbf7392090ee88ceb61c125ad026be5316adda17b56d6162a862042d47ab63028bbb9bdbeeba2e1', 'b2d6af68726c4fb59291d116481133de9675ef87f855ec5fb94d9e0ccf7b1764a19b25e36e12db599e9b57e463db6283b19a0534b4f0f3f549ecdd48bdc3fa9e', 'd7e1a3b09ec1e651551e46745221b7d9f1f143d647344577cb52c1636fb407930beb03e7de3fcff893011656909939dae926767198eecc72f281adadb4cd837e', '9b3488167d5dfb6d482b5b7480d82cecc0db68362829154fa765ca52de3c673f6fb6a65057fb2113d143924347fd4bac7a52f97f9e80402bb6bd64b978b18da9', '206ba488ee944a342ab3e7dbed8b01dc44547a10ac54fe47adf716a6a6ae289549a171818b17ecaed7ca7a1dc79a52fe351b46b73594b2c244e06c1f21d1cb83', 'f11cc3bbc16dec2377e400ad1a67271282b1a3b0934b93d8ebd9c8bb49fb93587ad5db0c157408975645b2df7dadecb68eb595e08704b4022dfd9b3d156894b4', '052bfd69f5e9c37b1e4f4990167caf7a24924114662857753a7d6688a7f22ea366859c0e7f5f5d6916f93962e4cb153fc7cbac53ff82f728d931bae8da036efb', 'd0ad8760397d7a2687d4e71d122201a8d0f92d69d1d193ee0d849342f31ca537088a02ce182e798dad96d785aa924b970ee7401deebe8730bf487d3a40cf22a3', 'aee26faadfc2992786bc12a109699698dc648d33d034dd5356d1d160d35b4075afd1d8f0d01a3383466d902c5d065c931974c0d753018fabbe7bd53393211fbb', '8aee144b2f72c07ca889bd9300ec8f1be9f4124c4b6ce0d8e2d15c0f5d5ca70588b3f60ed5ee7ffee0b38b8fd7dcc9dc3c01248dd003731a557a74d0a7455098', '8e1db884107e11b8d47707df9501086ccf76e2b77a32ce516c60bf0a2861a385e7f0267e8fdae1e8c27d90c8fc15cc6c81492ba42516da138e7689ebebe32e0e', '38c3f4fe7beb120bf8748d93db1a8b98583aa963c7b981579c745773200f5b2a119da5ede80245cdc756acc8330679684d240d7bb331e7342e4570877f1acd47', 'c340f58d6bb0348e5fdecdf74b681cd8af3c5adb565f0f7e85d7261a6964cf609789039922326add85faeb6f46ceb523307403372c08d59c47dd1e5b5c65fae5', 'ac1dbc5a85935a99986e906da3edbf3d820685f1870f7317ec59147179b08db688a4e9d0d261591a59836dab1975cd57013003dce67531fb8309ed270aa7a801', '32510216287e925fcb8d62b9bdb552532faf74a4c15b2c56b88fddc722ea15a6656dd213e82c073bfab7636a8fe37df17eb52cecd632f48cc092b92b19e517af', 'fcb7bb6014084b82d4d0b711a7b62e8d89b777815de24831f974c7ce47c635d2a1f6f2f67012deef3e77203eaa33d18d1de50b5621336b717c380c7f79ca9764', '40501c3b3adb28acc538b86f0f54808f5e140dfa9b0cebf7728c9d0536cbe8544db4cbc8f709f9278ee84b925cc113c186cc739fc2e4b729107600af25ea46bb', 'eb801fb59f60c728413d9d94ab4040085537d8ca685c3c9b4abb991d64620e47419ee0e5a80532bda31f5bc54f4d728c8fda795110efe7978f7787e70f0a4ded', '03fa73fc2936165a1986a7f3481a386aadb1460ac5713b9af99d870670e2a3b93d834ddaac80513882451ce65f76f2d2d93e21750046d9dfa5280526555a0630', '6a3a283a5f86758373154d4d89542bb6be19b14c752a5f2515d5ded797c5b473808d140cf95572efe7e6c5f4e986dd33a66d3d62798fa371086f4d54e8aee555', '665984d4dbaeeb73d3b9c78f397e41309df1f2f8daf5bb7624aa8c750d435d051953616538258d847ee4281eaca78a588ccc280576389b63312f4dc0a2ee1b52', '84e362bbdbf56f80d42f24764aac6464dba5b732bdf634f0a6d19ea7dc1958272b8f22306db3b0d8b8ecf80c6a1702bd730df8d45ac18bae11b175f098285671', 'dadf58137f989fd116a56fecbcf5958dbc40bbc9907a0eb311b571c68814d11c9c82ab6e51a67b2216d514e27f9f9c61cf852f851ed55f59e9bfbc6c2c9bb42d', '0e13ed1b9af878f5bcde87f6a3d8f65e137af24bba6ec1b4438e55e6b70f83f24c3b73560799cc9e797751363217147455e6cab3583e6e8114698dcab824ee32', '3c9d978d46eaeae55d5eb8da66650fa064a362f9db33cd4d413216e4b40ed87cd073807625d48fa3ebc88827dfca72e42d7d2c625348f7017223dff3c50c053b', '71cda060c3c2f0f019ca8e5fcd9fae4c6f189b4e55fbd38446d7a3da6740f382b47cf60ff0dc41ac6d0e51d54939cdb5ca616e2e988a937399da84d9f9965d30', '38372a8f4ec8fd7290a5b479949494e3c32f6cf2239b3e28528d02aa8307042b691f874800750c806c938e5a35fe990e8de3f03b9c152cab89bacc6ff7f79d1b', 'e2004521491f86b1f63bef13149d7ea6346ec655f53d6173fba2130250ec9fddba2b8cc8cd04306e6cc55785140a41ace6cdc66a3b0d1d11e308e2b2ded76f32', '4b63141466d33b3ed57373cccbb9dc4cddaaec73b3d05565624ee74b7f388adbb4e48a4aff2bcbb90e67ea119d82e9e47664c9212b6db380489796ba421ad078', 'a95934d0a5748f7532479220dd590cf7cd883a4d0472764f5c2b836be94ec6241f04403bc954163bfcb42f59195500d6cd5fceea5ad89239acbd55e49c1b079d', 'a9afa5bc7ece69dcd9c1cb7550e9b13a0318850d957cc8d71feb7f9b43a402292e62508d6b239c475f203cbf0d02418b26589fa7662c06933347b18e3f740d27', '1d1b7e7057b87ab889656dcb6eb77642dfcbc26b8d7d6eb088ae9cb2bbef61bc58f87ffb60fba8b164fb7d1733ad519200ceebb1735329aa7b95ea5c5cfb4094', 'a9580fd197d4c43672be0d1d578ac352fcc9409a2f3d5b5915a08b1ebde8adbcb8a0d78ab9a444409020f819dda7e47725711dc372c45e8532bd69b8d493cf0c', '3acb4cd8450815af3a60bd72aa049f5d39ae975b93ec06adc2031f3d230956e152ab508265c98f6e193bb64c65d2cf9cf43a8a6b81c49e3a395406ddc19825d0', 'ac794b24c359bf374f68a17a8e1e62bf0dbae44bc8d414e9fc8d53a6db57f2007bcd8e0167a0f4a9d99e7e80a30c96f182df1cee9e426a5b95e99de164055d70', 'a9b471178e4d3da84f9cf75a0920d246822f665c90c823f3d078b21889fcd358ffd30af4219e9010f092813bfeae62ddc852149e8162dcd44368706755126cd7', '91a5c3074cf87ce20fbeb56b2d1bae6bbbdcd3fa02271920bde116d379efbde4a6fd8b9506cd1cd4255b6bd919ce4fcb2c9ae89c2a79e856433e5516e7a21872', '87544bced26c84542098c21d7666ec00b5c6d9d0fff1afaced7ff1ced0c4eee840b68166f7fe6229904940f487a499f593cd3939cad8e0bbbe6f167994aeda7f', '8e4072bf1beff40b6ef261792f911746812fde0067ae7f9f21ecb3308a00ba531e5c37ac015e71246207ab78f3b7fc0c33f0fbf957da48a0e8e0ee04ef2b95e2', 'd237265fbf51ccdb45c69435d5c29327cd830c4ed93818bf6b43540ec4a63309c1edeb09e0b9c6d9329be9aa26b9aa18d05a59eb3e93a67473956f953b7d014f', 'b180113ca02eb11e3a75ab471e29cda5203f7ebfcd62af8dd024183832b5e09f7b0ba344e966cb0dda068b868fd1ba752ef4c628a3f8566b701c77aeaa1c55fa', '1c698369fdfa14f1b05c841d7dfc2e0656b373cf7263b228986208ac8c6f0f325b227930ac4a2bc43da0803a6eae10e442c76e652c85dd8a8faa1e6c91882c12', 'a59f12000fa16cc4575a9609ad9a9ca6e9876f56860fbdb559fd00b67e15a40b84b3ec5d69cb07d328b5b94f6a34305c1a47121f50e947d3a4383326cdc99e95', '37581ec47f53fb9bc74ca51a88253bde155e6689f37a5c833ea5d778f32d82d8e51b97cc0745fac6b61589fcc1d7e8dabe776f884576f345c25ef3ad7492ee22', '1aea2384931f05637de2255e8dc745b56a55e0f7bd8dcde92182d09028b282caaf692201e9e901edd60209b341f281592b0da78314de053771cd799e57f7abeb', 'ba9f6499fe79d309e8e35610ec12293449d8efa5ad9f67315e8a2cfa3a7032dc2436021d12359451c8408c61e9a90fc1be322d44bb267df81d18217c3a7b0aee', '3fcad9fa3e5e55d6557dacbbd99f018edd8ba774443cee100d58d8bc8cb9f9314810cbaf6d3a5f017747ce7ad6d4862200367def52c0eaf47997fcc411bb1a45', '880c35193aac605f1f47a85c25859a1eb1c95afb344264f61cbec0ec30a90270805dd7dec3e6555c228815eeb3a7be195909298eb05a8a401cd19ad0f9671e9d', 'b5e86bdcca0b7dbe77975b6802abba2a0e50ee8055df1c28f48cb60ea04b6b54eb7c1e951ce8414850767b00218ecb901295d6ade8cf7dac3af27bbcc957d505', 'e96848cca1a5a21566e5d107b966b1a25d973f343baacb6dd6275c9ec43aeb6bdbf6196fb1955b9939d9386434b24535a0618d15b10569358de1c65c20cb2265', '9d584dd95cd3c2c747f408629e929b8be862b078ab58c66345391eb33ed22673c5d24bc10a60d102caa107b5dd389f19d715f06c26de9d26a4c3db1d6cf632aa', 'd6e7b25ba3309ca61d0e36d88f90f6657a27362dfd91378aa30cf593fff7c61e4a4a8cc974457839b989642cced67832104da5e9216de69dea5828a04b749515', '77c4f5fb220766b8ead4cadd7634595888fce5c76d23f66c4a4fd0fa777af52abfc1b165ce944e679eb5f97badc0e40e1223830ab118b73d90a51e51d74851b1', '60eef8b48647f529348f30d44054a8b62bd172773568254856505810f60cf4197b4bd572ee9893fad06320b595bca1a3002a0390de84da34ae6e99fe44b98f5c', '60ef924ff602607811f0e3fda535b5d96bf62c3851c35b6796394bf6582891aab2dc8e79c718674023555d5d51aff29539d85c2319aff4a4dbf717be4c880e68', 'd5e963b3da82c530c89cc6e1642674a3e786e033dad0c50d8197b08855e5ec942d8db60e7f5dfa09e9f81af71709c1abbd65d6d3ea27d8c9ebae15e5071f0c81', 'd942a4daad2bc739ec2018fffc40bd0a4f375b3cab09cc86692fbd6545ef561b770afab4654e068b23ef651f400ba1af2289a93b816b84995d141e5d36a867dd', '96f7a70743575ceb4d7ce64dcad215758682c262813f3d19933ec2fd312d8f06b16120030d198d282c286ed51df7df54f162960100705c5acbf27544d8bfd1f8', 'f1240e29d4d3d709238f842f4e5ddf36f53eb1ef6be32fa4e3ae6f9a2364a4adf83166daaeb1bc841cba92a84d94cbd3b04b3730b9c3e2172698d0bc1e77a05f', 'b571b5131ad2a2648ff73955b09cf8773d861be58e4f5fea28535f64f153946062d370c0b6d68611051cf1330fc94795d784253e97dc3370d3bbf1514d1b65a5', '25cae38461fcc8b1db43ab3501b713c2c76adc81c41f91823597047425484db9b6d3ba54ef7d000fcbe8eb286453b5d3095a7550fdcb720b9aa4d06bd668a391', 'a19add30a5f1b53f64a2377e352986b4ab7da9cf900ab36e131904035037f6bccaf09124f8cdcc3810ed4556a49ce85940c8531a70d8e3c2ccea5b3df223dd12', '0fc22205530b86e26bac250e8bafc751c5c79fa4d14b995af75a0c0259ec00fe25fc980c575456a60d77012a6c37e1da4d62b8620799d6b306966b76cb38e1ca', '414b254ff7cbffcc61a5ee5c3ead48dc43d2e6a15466c96e8fae9d2d741b8dbcc51c9eb925474982f546a1f2bdb47e5369df4a3f184304bd2c629c26394bb4df', 'fac3af3a8be4df6b615858601daddcdd0ab07b10bd79be0379247e1f63d10128372e4f888ae67f97a38df7e31c3cc2d30227902fd14a61caf8ef94b6a9722d61', 'ec4d709fe386b5e8fb7aa4493a25f6c2bff0e204d3387bb1ce3c7e3fef610ef83f2a6f4ada85b542e5ffd8d6d33169d717687465381e618009eb790f656d3eb5', '83bce02207edf8ea827802458bfe4d24252accbb7cc82247dd0206a86b3f7b1d9da6f159023296e446801d0e5c6d2dba4a48027857ed50b48459b4adbc71f7e9', '86db7f4d8e2ca51927a2266cc0ebd3d21e51d78fe6814af0f32f3f91b1750799ee519b7cd1352b171ffd95cf1a21790163479eaea163e261118f6355215a451f', '8890f61044a25c9e2a252c4be432c94837d97fbceace63dc555c1bf8e71d481acb555e4f9f8e327d67b8e8192e9b4766cbdeba8dad5609bea2c9aceb77db4458', '4ee56c833a79ba0d23c5e70a84ea6d0e19f6467f7be60335f7c6006fffaabf59660984bd1d8c5664e85152433b9178864297d41cd1c50f4ad0703458663fa466', '28ff999092b31e29d6e6f528694b4ae4ee01f0df19b8bdfc171008d8e81dc0c81c1058fb7e253fe17ea93f25304fbf14fc945a8701ce641c17cf754d18e14b2f', '1768a714e7880a1b07186a4552962482dd52d4dfd3f1995a7a94664656bfa78c6ed945b88b98f1e055f46652782f792e0bc57c42acd9253a3acbacdb2b439a3a', '4eb39c75dabbb7841e98018cd22011a46b3c0fc1a0a610dfee8d8527905111bb50645d7118caf85206962e26477aa29cb94d7b6625e1b6189e07dc9769f3ebf3', '7f0879cd328c5706322794b765c7f7b42c57c77d6149e7f1dabaf6aecd6bf68352733b403a887cdd5d9f10824fde7193e226c7d51018a5a7a542a3cf517d9a3b', 'e87b6f89298b05fdb4caa2b7ffb9cdbf67e63e7994404df50f488ca948b9ce81b73eab87629286d48c6a108d46245ec76539c3e532fd89ac888813c253c6c168', '8c3fb9cc1dd7b3f3faeeaa561e369e6d663bcaa135316f836f92fe31eae32cab681e0e7bdc24627e25a4f1ab78cb897d3ee17af248b314d2362930d0256f0846', '332818d30c143546d819f41e74429c439d67e2affdd7f1dd86da73d340a43060233db6fc8b832552dc62fa95e09ac15165ae6a300ba64daafeee2814bb943280', 'e248d144531d1efb61bd0c7e235a46ad5b622759ba580614c92c6623a33136642b2d3ca37a3d1c1601caae3d68bc76059db9c663e9c80820e4a4367109f1ee1a', '8e7447b705969ee9d54e0d94ab80cbceb75264044a562c265bcea97de2f67d841d90382ebf9770a3b0b29e0807003073c3571eed5557e3e19b711eb5b2595f71', '73d4153ab210ef2abe9d05ca3a1b8206ad7bed112ce2a4db45018d3f1c50b55fa7a09588970551d90505d35f92c13d7592cafdf527577ac22e6fe46f3e0a1e22', '2027de823ddb2ba5378fb46909e60355fabd8101c1c50ec75163c7d5b3eaaf8e91475749079e32c8a404e9e78fe3e68e6e2ed8cdcea1813b429b08866d2bc23a', 'bde6ee1d7732faef54ee2f5861628a45458cb37faca26f1fdf3d9a10a0d6b9395b92928b978e09b42f91953064693add302fb5acef4ac31f02e90fe062d77418', '439c774c3e6ff19de7aeeb62b3648d417fb9f586d25ad838d9f56dfc38d8e17ad4aa9071d73903be264bad1189441182f913b3ade4ee60b9ae0f02c290d2e32d', '9e9106590f856afeff24de6fa9ec0e7b56e94506c5420ffb43c2a52eedad4b72a3073c9da562bbba1c01cfbc4d09cc66979236138903c60d9415ae95c870e064', '1f147aca21a7ac74249abb2dfdb8d4cb31de3abe33cb42edbc34bde884ed12957554c2d9792d2ad30de87dd0bcf93f86fb047d8f432c972830d08343b6605d0b', '69bd51ebe1d0211bde780c6cb190ca2df5f9b33cf63a39b98126fdd410f8e27613deca44d4715e471ebcfc51cf4500a199b4ea1b6c7d936312541d33253b565d', '6406d4a1dfdbe8fb3c5608475407c78506ecd7d821efbd159ce809b8964fce473686ca78e88771f3321377fdbf8f7c29f7aa29bd686fb0502e78aa3f2c582969', '7347a9448fe0fa86128ebddfc0fdf1391ebc1e635760cf9b318dc991513ead7f751654fc39b8eaa981ddc2abc952ea0291d79782dc18ab4a57ef130679df1247', '67bc473b9a18872ae602dea1b9d27221cdac0f090f470d9d2a14389816204f2c9b32c5d853c39245b20d7ce262ddbd1efa9aff1951236c11e1ff834680dd0d94', '649f6ecc03fa6a1b2963a60abbc2c776c7ad962a11e559cd3dde9d863f24c584a3c8b0a249891afc75d7608d288980ccc922e53fceca784993304ce87aecee46', 'cd84e90c5435caf1ed3ebcc581d39485cc4a034db317c349bbf26323f10377806c4ab968687c98104885172afd0e50cc4240416d97d60c6de6c58206f9fadc57', '7cc095ea8c9a7fef4ac9e3ee09f57c14b0069d3470507b45e2fd0c6a5fd38d9d9e27cfcf24c19d4b97d9df3b5c8e8810f9c379ea59606715c9e17d4bd7de603f', 'a489683338d04c0c39189f08fb53e4c7233df60745af2626c9b8f7d362b6b8f82f9476a5c58e42401c79adadf491eb39ca05cd47c2d2a892652d1a3627a8ee70', '6735dd46ff1b277aaea87cadc9498ae04f3959c44154f44556577e611058a72299a3bc31553eaa940b18a4c5d7f7886429e6f79eb0d4583a4d9fa1548595b031', '159af569a2448f199c073a4e9895d97f548e33de624d6dbd371a5213050496c9e7df355c977d16d88961ddec2ab313d459b7dd01009fff3efc0021d6b0fe3cf6', 'a99552769b48176dd0f5894712b8a40d579e0837a5af18c700efd46d66e7feb75ccd40bdc487b85dcda77c28b359cc747c29e0daf20c5341260ca8f0479ee385', '613c90fe72d0a00c2ebe672de9f309f1b18fe01636894b2fb1dbf33b23f52de7950b81816d79221e1ecaa029e180d832f3e3f51b7d4e55c05d1579f50b657859', '8c6ff593ed82780020db1760f793860caaf213d95d7e31d47d62c7683294e337614fd3a46dcf5c96b049cf3b6135767aed8ecaa13a17390c34fb7b0d1f4a9f71', '070f2c5fdfa2f115b9b7142d3f8767bd0a603c163f6135d6830a57c2b3c495351113c836aaf3b896f6dab4c6ae230390b65b621aac5d46278d75d11719ddd652', 'ecc1a68d4df38045773fd9138fca7ae99ab0a274606ad781e873055136b3d12829506f73cbdcd828804f0c93bc61bff8a5567f80ed2aa1ae8c109fb1ad04e842', '3e01ded4f433730fac7d41f0eccbe00d6dfa7c30c7bcdf4a4aa4dd618671c4f651b08a43c36c83032f6c0e7c91a935140d2f6fae86dcbc04110dfa1b43737c09', '3c71a6cc43f2d2921fc70967ecbc887830da99ad21480c9a16f3c3eea46c8c77f15d2a9b59c79827e9ebb038181c3201e7b9c67a7734387d7a61cdc96a0c4e83', '1caa7453e3f3cb3ff205b82caa5a9da1e91decf6aa01452037688a661fb9c553e1680698407618edd10677dd20dc14bcd7eb6fe7e07830d2813bcd0a3b0fdd6f', '4afb3abe2131ff1e273bb0487e29ac0a37c30105ccc2884217f79495fc84c0464ef5e233419705d1f235322d063bd4138f07ecf42e70f7c39fc56c7f1550457d', '2a8e5a60257f04db592a1be06f37e2354c4000294c4b1b3f3ab678456c738d507e846ddb66011939df57d6902753fdd9a0d1c7c77c57095f040d100ebe23ce05', '83658aea1c6ab1c4923365f5c4f165e61e09fef4383f279ff94ede6fa281254f444b15622c16d226b9730608654159adecbdd00a1c9875b6ee6dfa9fba8d4aad', 'a36ec2a9e43b41a6e6d1698eceb586d7fb7ae53046c0c2d443ba667b0f25f863dda425c2a85b062008d33623a92e4bec00b3e766d5b1c8de20f31b6298d0bb9f', '5890a6578667391f2e0fddb084624b1bfb7845376d8d9246c24960428d01e460d902e7bd1fb2c18eaa5ae6b31a616a14394a6c32f29b7b4283d4d1ce77695ef6', '9b0ca2e4b0d048f156bf689c167fa9828ba52fb5c2cf07497e65abc430b3688f86f5bdf73c2f36553ad54dbfc7ea10cc62831084e0d57ff4f275c85c492c0495', '62f275bcc84b74b8aa7645de298c8db15093119a13bfdf1bcf83f4148371c7d85ac0fff5c4c0fd995c5878fb50d672f76470cdd763258b9dd6729a2efd782cc3', 'ff8b4cd7d903d740e6435ca9526ed64f1be52f92da8ece0f66897cbe0f03c21e3cec1384335ccf9176bca20d6966ba5e660bccceae1c543ac440d5832160bbbc', '0e30a2152ba51976a9df36a71ac130693b02964efe03bb7ea6831703bc2d930a23a66999590570e2b2ce318e036fc1fd99653def8430f537a1610a9b33aff4e7', 'd4ba2887f98387fc4af65d48af43e58a5cebe3d841c59058bd322467447bd71be8012d3fa5d1a2c6c5573127478821c60e8de27abb1d0344b9ba0ca7d7e59492', '490940e0d52baea83554bddefbddb30f7e623ae617c24fe4195a4f4e9f63dd97fd20bab8752b0a1a070c154c40b6557da37e3d4fce9ae5de705a81b02e70ec7f', '693059485c3036e97ae0fe5488f4eca58bf64c24320f9ee27c54c42720c3386ca8d6a43dd9cdd622bb83bc5487c2f86135255fb2887a35dfa6ab111f9badee3e', 'd655224092384e4bc9bdc361cfd43777af1612c61983659a60441512db46219418c92a7276b69e181d9f8c04f43eae26d49d0fc4b1da9b3233a9e5c0afb2157f', '037375b93587eae80ee555714b3df13411d80b78f1b364509059b5cfab6463667e88ce8db4c685eb6918a420fd8b2b25bf4daa9ed1fd5cc81371fce8481c39b0', '959be9753b1d4d398669d5ee39d378ac676a7db14059f5c1c4f81e02ece3fa7ce3632c3f6abdc898fc625650657280fdc5ac20df0d56cc23b1880943be47fe7f', 'ddb6aae63de6b85146e6909fafba54cf55ce7c38825e84eddeb52c595e3897cd63542d2c47c1ee202694286519d238711198f2f8830ea24f3e55cbcf4304a992', '427c760695d32a4f92b54b695cde88fc8e2fec3e208d562d885a60c81e9a19cda23f4206afc31cc0441c7d8581e9340e1c92d2a9a7db9ab171c607788b34f458', 'c78a130d7fe9e02d832ca7b54715f70b01a5edcc3d3d6fbc6576f42fa4450b8edf8f2d86aab395d832c43d16bcf355085d2935518fca28b3208ebe7e89dadba1', 'e2fd8e8db5ddc4f3b85a0a3ab1a5e9ac7d1e9ada091a9606000872e4ade010830e5d7ae92f88802fd6451f128648eb89d69a6ebfe79fe40cffa3d60e46980619', 'f55acbdeb7853fc9612335994255bce9dde6ee828b72aae77bb6c4b3f29cefe1b8fa2cf0a9290c31f39e10ecca75a231d1b050537f92d86d173af86ddddf416a', '4b69d60f7f54de267f2469d52276f3819c763da084319c514e412fb756fedd219f153d7fd2fc318a9751b29a2b6619b535d395a54ada8057cf752bad2ea8a5f1', '2654bd4f41a5e7faf13fe039e6901269289dc66141e71e498894e180282614f108e7801e8519ac0c8d62db23717b977eeadcd15feb998cf5558cce520f889a53', '974efec51c2d281c02a8555252238e9e3674364f48b28c4ae2e074217b545cda8668a74bedbc9f8393c49ed4498cf90da052ba24f3ade10518d7a04f2f6e8a1b', '9181c2b05340cff8004484466ee6b19c7205501072f7c5088378774e75edbf2fe46760cf94ce2027ed67609ca38fdeacf181935be94557dffeee700656567151', '20e78f8482385de5fdbf041bb0dc941668f483cc0179b96b3167a30e71a21e6af343b43e6ca35b4a07a8ff648e31193bf51c0dc028b4f81440ec6cff81d20002', 'b09fa95b4ab2c183dbb48aedd6fca1fbe47232b4485d6713591a1df3974422a2d62f5b551e1f26c9c962ed0d420fb7b97d3d699d0fa9aa364bee421dbd28dd05', '2f7d37edc41036cdd576baefe29a5a4e5c7e5e9c9ca23074308ef324069130283b547f401d4c1ab9c1165def9c839d9ba2c5af00ab2780c6567befcb680dd7b6', '625ae02174ee37e72babc3c3fa555afa3891ea92c3458d70e08a05e1807238361af8dcf2a8c8f1f66016d66952d1e30e579365994f9a6e1728866d387935de31', '5acd994942d68e998477e8210e86bbc601bc6d8140d355d60dfca35322f57ba862209e2790d1d39e319c7fa17e5b7ce29d2ad13817fe0769e90d61df083ad4df', '7ec0e16e4cec74395e98c27d8a354b95f077524fa44a1f87fc950bcc22bef34a30a5201593ce5d3aeac60c6b8de902bd96a217c40f6801d123a69f9d3156d8bb', 'a671b8629f60bdbcc76a3a1453c9a06c79519a1398506afc9119eddba9eafd7fab311d268d3b69776e3fb541a1c41cabbec10590c674b6fd2819ccd25527137b', '0a915febb5acaf34fe26e7e4a063316cb9692aae1ba75d389b818abd6b2b8a40caa07f60b954cd53e706be5fffbc8872e9e61b4016c8600e1013658419437595', 'fddaa415af6e50987ad88e31eb4049fe4bba5166b5f3c29c820f92a3ee9526016112fb0a7e0fb286aec0ab18ff07101c56ca42802eb1a73eb184b6e62126ac9b', '0b6c6162e435cce220e597b0c336bcec1d2ade2f56b7004b8df5d15eb6d18acd4b45657c72b72af1e2d0de99ae3a994d8755005962cc4a1d7e7f33edfb0f5ffb', 'e9b46b680beb9d33b094eec3e174596e9ec0c368b7ad50fce4aff2fc84ceb037cbecc48c34624fb446855e7d77a965aab0e47ae44da5bf232d52b5ec89c7e569', 'fd7540e58d0d491b80496b9bb1b91037a243eb58b2c14d2aab12054e521867dece8c779e8c49ea8a65671108e954bf3f034854ec1a7d4aba36e57503613fcc50', '5303d4de79f47f4161a053cb4b971e1e348ed5280d2451e868b8f627c74674c11c23a8213487f5f05fe8d803e8e331a705e0c9700e4c4587ca999b99813f3303', 'e1fa524359ce40d1375789b4c6af4a7d6eb61abaff12ab339818e7b6a2f534edb53e144f315f3755c3c7c57e0a5af126aaecab36e006e04ef7b8cd8acb9757ff', 'eb9bd214b2596dceda3986b31e79053e3f6c50f786113f68faf130b19ce6e2f213922e40d6a6866e4496a56ba86e2f52ecf725511338e271d2fade348d55486a', 'f637b7d343dcff286a239901355275fb376220c82558b0ca0c73e9acf069078f2a7aaf69327286c13502d2fcea5e59a3d223800b22308f6c02f051ef1e75ff33', '40171f2a36482304481129be1eb0b66873fb7fc954dc7bc9ae597eb02daacd4f64bcaf33f9720b2416774248dbb02a0e99e37aa0238d3152af61d482959a4fac', '31080c8b65add78a0d67fd71a00b58c8b35fdad38e0cf2effadcdee767add589fb0111c6a5013774ffdad730a8e1af942fb5e9a69ff1cbb0a6dbcd19e65a2c0b', '22a2b9898224e0a6d2b1ecd1dfce2312772cafcaf959d679d3c986b12666af9c39789e152a7b21966b55524219ccc53ba1f1c02d9b7c35b24bf5d2cd45ab5a8b', '2459f93b66dcbe149c37f0af05d629f938899e67fc650bcc32c93d8751cc4d28bfea1db14fcaba16e7e93909e5ea4662b994f5062e96f3fd44aae38aefb1f3f9', '99d5958cdea025c4f61abadc3d7f10bebccdef797c2ffbd239680bb5909aa1faae94c01d3859154ae4d051c28c2ca559bc5dcd1b0e1305290872cc81d00dd395', '2e4e4eee5eb9816d837192670891f2185ddf524ca0807a18b0c748059dfc3274b0c00fe8f85f6b1cd9eda95692805ebf3617cf462e064bb75b04fb9896947918', '8456ff73c39a780c42c1dd91abfba4efe70ca7158171025563c62c072160616c1bff07a77decf7fc7da07127e1029f80a0a526d9507ef50d9be84c1f263c95f7', 'c458b7746d066b1b0461a68365da8c7903ff13c0d50317a5ddfd6840b17e8e798232395c817b00c20804d174ce8b61d848c27780b9613a6056b2ec6bf986c864', '9122237afbff2bea81e08635468f816ce842dc64e0741ecb131a20aabfdc42b9f10bb96a9ca5f59575d4773073bf42ab89afad6ea00ec52ba0303c46ff0740ed', 'c1710c17219197190cda203c35e1dd067d604715a926bc3e215db4d06bcfb0c45cfa279392c2c629a5037803216199db45ceed27ef85da28b2a8e96b8dccd2ad', 'ebc39bcd0943ff53824880bf8ce12f88c73825acbe49545f945172a6f4e7ef8375a5d5698481b651495b4f0da9bceec92f0de405de0dbb27d4a611f051b64f3b', '6d5eca77f728033c5187d5c42baa598908832bc2c16e232bd7c852636cc7bb569d6ce42205d85c983272b233c35b88f5ed772ee43fa94fafc54e168d84842515', '7947b998dce4d8baadeb020d737b179a4728e23bf5195c419eaa80a6295699c9e6a26ca5d8e9fbde4812081a9080281f62810b1ea9b613ef49e91d171d506ba6', '7927636c5d80d5de0c59da192abf7ac063726ed6447313a27331dad7b0fd32a133cc6fcccd27d74f28690aa65a0aa306e5cb91fb7af36bdfc7bf8912954e0d02', 'affbaeff75353acdbebe9141d9929692d92c9f4096521304306f1c1eadf1c39eada6f3ff38f98bbf9f5cd65ce0223cf839d12be4952ad97c3e9bf1539031a3ba', 'b6723c66fb49f2044e27b513ed04928b5764552876f472a41d76e31f8c7482abfed661fbd2a9567cccc4b84cb55dd1ee8396c5854b21e1570837c15a672b6272', '389f508b6db9bf200b56e8c1ac64a9f28b02ffc6ab54fdb6e02008fdfa754dfb272520f4c318ad959c38d67e408b5660bbc2454d40d21e86eaee89d636c090b6', 'a0150246e97c8b9846660da0b363a61e00d642f8f38d236eda8bfc1aa9ca02fa113a72d2a550b0dd4231fab4ac9af1460ab49ee6c01decece7f04491f213b82d', '0a0d3b525c0d9206334e68ca704f9f12e2a6b579b02d1445d8092e7283dedbf42f4df6b727515a39835aacf0591ce253e0c212af2922f6dcb24f7385c4f11097', '460bba7b988863cd6dfc6c82df17713a59c19d4455ed84b9b6e59008e3df696cafc8db19fa52f59c1d68a45decb9bba7499bb3e0a19af4da8209360bc0914ba3', '7d943cb252fed280553d43b585973ebd068a7041c2b9db4bb9b3b78c134eac2782c4a4602a16c794a6e288562dd8f7bbadfeb8ed25f50868b0afd8954976554d', '415730bfefc05468abfbc4ba5f488e75a430f58a0d1e575e37abdbf3fcbdaebaba272ed2234340f7da309bdd28db46310e155571bdeb48b2c5836abf94b25e8d', '75472c1795968517d088e1ab1ee8ed5fb129103c950b4cf5fccfe83d0ba74d92d823db501edabf7a69945e26402de47e6b14fa1544439e3acbe6260c276202f7', 'a146d9f07f8523c828f21801bfea3e9d7696ccff10b8591a8d93c49fbd702318451f519f24902516c23522e3191413a349edf1c504f3ac392b526a7c4d635633', '3e8e6f2343b418cfeb66c31a787b589147e0bfd988bb079b4b64b3c75b289977d28c6911a6788bfa369b1558b780d518f3d5ed14cdd80877b580555e7f0809b1', '35b3e4258e2818aa2e7ecaf88da9c6faea2c38e814219c12a7cd94b6298d59f45b22b575024dbef300d6e59b73bc40c8380faf8c66650ee3abf91dbe0be764a1', '169245a133ebf21165cb231715511554700156d254bf02913adcc13ca9d302964244d935db219d4d793cf0b418a4550615420fd4949f743bc7168a2ab1485fa6', '23cd4e4661e1383cfc35f2458d38dc3434226e738e85ede1cfa489536d744b1fe00be443f9098b5fa27b23f95aefe383e43a97692eecb88922fff31194c2b59f', 'fc0bf2e80816ddfdc3eb3067f8dddf72828939592e2e205b6cdfa1e575cce615c75cd93cdc338c165739ff0858d23b76492f0e43f5068b628871f3486e4cb579', 'e90554cbefb3224cf27d8302acf848bebaf428b84470622962089632b7fa05edeea3625490d880a81d3a250e72916abf0af84a7353e2b26cee5c9fdb2bb6df5e', 'e473e38bc31523c919fd535ca6ec7636d38f5055de482a9bbe23e745b24a2aabe14f3378aa20d4971be634f16b8c9488aae855702249225c5c60bb1f60bf3cf1', '115a8961c4fd3ac423d7e7654bcbcb07b73d69d75af8797015452ebd4634387d37176280c4ad0fea4476e6ee165a4539a7153a578a7869f80e43911cf030a3f2', '720e7271a6185586292eb4d5cba671679fdd118f9a21a7c0ff73815f3235580226839eb79acfe0217d921a31f74f5c2f3c15e6860de769d41a175d4daa435945', '2a679d85efffb384b9db84c7aaab02a4d455bdfe2f32ddc63f3905c915e48286e3f72b190a6b93f62ca561baa7aecf25a0028fa50f90805d6898aa0dd2a58bb9', '780684f35fdd80565ddb2a8a820cfb9e060eee1da55c6247965e10f70802d10132a3ba1b9d6cd04c1c2c00d3428fe5f7103004e7a6f5ea9af77fb72c5d481294', '7b6bc7e4d1cdbf9b6b3e81a246be687349325593f1183692ffcf391f98cd592faa7fa2c94e5ec0114a55397fa6672804a4856116d9293992338f146ec76c00d1', '696192148185e5dba285ad8af448d7ece76b884f6e44715ba44af0a7c2089f4e404bdf0d1e80f333c40273a28ffafe1e2a4135126e0e5ac1688c36c4743ba448', '50702194fbc824395c53dbbbae4966e3eb04078a1dd8445a92067a4996b76e8bc08e56deff0b6d348fd8a36f259532fd759071c6fb42c07642a622e96ecbf278', 'ef54002039eecc8ca8bf41e4e5ead1b854ff7d11387dfaa134259b4ac478f760c7a99bab8dc76c1a67836b7ea7083d7195159d8084d241fe3eefe4b85c8ca59c', '7e1dfaa10e42fd27a9f402961c1d6988e08185b0cae6f18764eb86fc44d554beb920bc267e652808022cdef475dc2d0b3f8f93b91320c3aa541550ca777562c7', '5e57a2db921a113776e83c7c9a9d9197452655c06729ee12d7e33ab27f98b8cbcb7fb32337bf7e3591154808cd4048b655e4e58e561263b45e66c1d06c4244f3', 'c3f2e885fc3a541898572cd5694ed99dc6a3190390b53d4a74e4cb705935c37c6e47075f05af8c2d4719ba8162c6fb086f74a3fb265866b780aa6278e122b97b', 'bb5f860349626d111a28b41b95c587c8c8cf0f3af65207ddee66ba74100a02f6d25d2581c42e0713313b364a83595c71ab43dd7efe0fdcf533a1eeab3b0ead7a', '6209a41b9674fe563b6699c1a23762856ea8293aaaca061231d446de842c5603cd1056369e35c4b18c93ed0ca4c2fc2aaf973ec316d6a054e63f5b9f0824084d', 'b99925375f214523aca051eabe21fcb0230c813804950b04dc64848acd33009661c448f70f035c1f684a897aabba9e67b2092397924f9523808f8686db41a9ef', 'af99b8266da5a9c515d0fe0bfa56ee6131f99cd18b4a2da7d0a7dfa6dd34f86c6a5323ac1f6a7274095e351da4dada369e29dc7f6e22f60e07203a88a22d6463', 'c2fdad0b757dd0a2ce0f9454ffc2dc0d770c097484aba74d13f3d8f50eaba72bd08995371cd47964e8ad5e760afd9a479edc3d17064f76e702efd7d0997bfdfe', '42cedc3905ff600c9f3735f07e2bcf70df40ec5190dbf984a13f97c9c82934854d1b10cf552d20143df949ffa38d7cef74666828e9c0eea1ba9dd389622d0e0e', 'f15d13f8b5d29f84187a9c4155c8c447573125ba250fa05719cfa4eac2bc2182b48c519a153f5e8793ee9a40deb0786d0fc3321c88772ed4464f00b209472211', '97a67a732938553935dabe5bb875bc2cc3ce54ddd690226948147d9a0d3614a0103d9766de89cb34798bdf181e1a3cecfa9d9c5d962d7c3afbe11dfdfebd4ee0', '07b04e3e4b22a6a5e7d18c674ae8d90e3337c3b15fd5c0392f18063323fc48a6fed5391af746bffc3aca4a8c600b19bcc73475bbc7ced4f7c308ab0ed1f9671b', 'b06bd30665bd2a5c6f48e21992c1fadddf720a5cb157dbf41930e8bb45474d386ede54926578fea7522c1d10979d3a81b7d3d3b226a634335c82a956b712dbd6', '1ed711973616b87ced88164c0dff44c9c08f992a75029c02c5f0b45dacdf10bf229fbd4b0b191f991a0fbc96e9e4b265ea51759daaf9d88c4f629675a7469ecb', 'e787fdd2ffe25988b1166bbd41a6418799d9f80872764f0aee9b197e5bcaff65cfcf1734c924736dffa1323d7c0cc061d6ff93737ecd849cc3b9a39cacb8855b', '9a8851573410e44bd7d66be8badee6ff3a206a0136b6cb872f4d5dd29af2a9a9a30e05793e84b5aec858b7c6213fce06e462bae129d734b5f0dd4901c12fea25', '0b564f823274bba95df794a1e854737a84082f5163fc2b7fa308b34c1fcd9acc9c684d809b9c2463bb4af8112b708660c2ae19d5e7f4da619cc4c8d59e553032', '2886d81923837326be2542a47578075e273692a4156cad9d04a926628443d0bfd6bee02f329085bfad821d730ac63ff4c99931ac2c958de536d9a4aac4f4eb80', '28d71fee78c221b2d3adae35873dc318dae572717af391b19f6bf766670cd7f47c7fd14eb99cbf494e66184e3f9300ec6bb39ba6be0d15249cc0e5c52431f1c4', '8f7cfa3da2544dee50350d99d9b09bfd66dbad69a45a0a8d67bfda6ffab96d47ea66d15a955b25dca8314fc4094109097420c692d07405194468e50777349287', '916a0201885e50b6856845875aaef02c56bb28e77c8a5ad560aa25fa1ec78430ea6a0985c0dd86a02ebb0973952eef92fc81c9cbf4b6c3a0b6674a5baca89f38', '238490eba8e57df95cd2a7b79c260bdc2f1f51d508ca768997ad7aa25153a19499ebdd68b31005ce76f2e924d7e479b283731da141224110510231f36e414773', '61ad5af84ebf8ccbfcff78861be0225fc16d10e28649ac9e522fcedbe2981b621a85118c6fddea4badd7d5528405cf6d1f5f081e9a234740531f118e2eabb80a', '3a8f9067a921f6a7034c078ea19fae02951a4986cef919a84ef9c9f28b927ec3623fb3bffc6d72042a0744bea24a06969d9b288418922750bfa99c47e5a7cd7c', '298dba1aa59cdd5fd8f61c221af1b47ac7f659faf66dc3a76c5a9efd27e91d95cde1318fc397daf84a91647715570aacd8117ef9c2853b8d4624c34579931e68', 'b79bf3e4d78c12a0f759b54003c6bd25016ef36e799fb69bfc36b5a864ff3562356fe47ee07f1b8d0204014b543630e31f891283bfff799953562ef4c0f9b013', '166fbed7fd93fae046611dbe15b02fc13f4ed73608d3fdad9aec13132720766e2602e9f5e63973c816b687050bd7132c6b652180f10dc76db6fe802991be10a0', '9214ad3c2843a73d6513618fb44347be8881c508dc1e613773b4f201f9cdb6dd52c60205d5aee3f3386199fcff5e90e0f65c7e469664ebafb516409401ef97bd', 'ed85f281acadb689b70743f5465e9f306a8bbe800cceffcf3db04d0cb48f256cc918b8dd78f6f6c0d05a578b502d0525076971a22d4d7c3542f79932a114854e', '66a33999139980cd629186d9195935280614a92d061db7691e7c1f5aa49e362385afd7c1a0e86a5dba1dd7b042a5c981b58ad79c49e748dd8252ac20fe231a6e', 'd87881e2f0f859e8842b88299e24f21d9820ee821338af60e0bd8e6040d7e1a7acd23632023ecd153a0aea3e8efd4fc66a75b3d35c43d321b3ed595cbb4d8106', '14544a34fb48d8cf93484f4d8135ea7542142ff2b2e877ef4130b6f8c5dcce513443930dfd968544858eb75c1b38652f912e59723b98c0822c5364b2b5d3abb4', 'af2ed3afcd37f0f42724b4db4f44d38d7f99c2a88ced8537651cc779653e3a9becb61952ef6a64f942249e6025d12b9328c44beafc6cc778002c292bf7ad171c', 'ce06f66ad4e851f318cd3250d703e84fc465d2aeafdf2babb406ac24d806666d6167fdbe2f8def7cd7c593b06a76ce889e8cc2ca0775dde2273697b159a32940', '777fbdc5eee627dd52ff71e6bcbdab9c25140fc50057f7d741b20fa4f67b40675ed8471486faa52f1758f5d71c0ce932fac75a608acf7c723addb52fa179d7ca', '89ce40c55984d2a8c679b68e9fa17eff5af0c36e3799a3fa22387b5d987936b431755837d65f99d37b78664c7c7ad8695a21dd821eb613d8becece7752f37215', '4b72a003ea257a4f614033d11bb13679e138d3e5aa4c98807e6d413897ebf720580062f729fa21fc5a9a5635db75bd4f420612b0682cd8cbb528fe0a8bfc15a1', '87575d8955ba702a9680c8412a4bdbd2334a7fb7e86eee215eba221bccd2701d022195ae87b13ec8f998caa4ad26561198bd2384ccdcc23f54f6c8082ef7f621', '53773e7c8a96f0ccb7358516059fbc52bc9664365c2afc3c3fa429f3874ab4be98270b90c5291fe1258a281c9e1d6ca7c289563088ad748d8ed2e4c140ac65f9', '4aea240c5300cbb314f2216131ad982030f452b6b7aac7d9087bd7fc9b51a54c94a144447fedc06b3cdb4643cc9f28490cc8430c9305f38c996f29b4e499d6f2', 'eb6d8182a7053bb658e5421a668573ef3b74a8a9e27bc36d8b297f931dd21a124fc7d63b4feae2f0cd2e95dcb96987452f857a51468322519a8fd87ae1a0e3cf', '2a1a9853b82c4aa9d6a06c5991feacd22649f5e7b082707d44ab311734002a58e8925f695048571dff8132a8be33ebe60774238a9e1162c1f49923c5f5ab1f6b', 'bc8b2a6af588bf5aea9ae884ec33f471e877711fc4cc5b2322fc4825d21480104669675fedd64ec3e9ee29d917b301a0c70df38bdf10be0e118560096663213a', 'eb9f2e32c5b594c3afbfdd1e4b62ae428927000ecbfd23f40800637a269ba21eda0159b59855542fc169136060257080dc26cad7811ee3a3ef604a5a67a8da6d', '7b84f1921b38efe24ab1226b7f12cbc515c3bb38c881a83d6e1845ce4e97e43310d011d385e3b123594b9d630d63780c9941b4d32b6b1ed41a41446bdaa994c5', '2ee47b1c2e57cb3bbb1fae5b7a2338db513d47be3717f40ae85bebaab2ee6b06177dd53660109869d549595681194db5a2ebde00cba4136700efcdfabee52a27', '24bd8af582f3da8405e543e093e6f1ac553f9ece880a608870aa8a2070a090063ded993ccdb40f220e40fd3e6986a7892b460fb877cd3bb60010d126270516df', '3e408a543e439fe610cd4dbd1f9e7e6bf867919c60151b19fd1fcd44846d3438f476ef586c110bbe30123b5bcfb9c37de207aa97b9b1b72af34acc1294070c42', 'b53df76e7d09c3508e6a4ad525e61e933ab8733d0b227e0d991a67cac49906fa6e20ff44f0d3aa96315a713ddd20a8638941a9c55be1494445598c4fdc9e1457', '1a48ae8ffeb76ca2ac3448c520bd8df4f0bf9e79d3a27e32aaedcf7b11c3fbfcaee859290e70452f524f90c3365123df4e8d7b3b3cf4bbaa5f9cc7c0fb916f14', 'dfdf8401b789b34fa498aa9e2483ff2ec52ff973dacba09bcc8ca7884854edd7ab94b0490a29e49cdea48c8837b324885a76f00a553a009a2ca2eddbdc4e56bd', 'ad59fbb6731bbcc244ed3ba266a9889da4cbbf4c506c8a3257c6544fb4800460ab12ec70e9747838f163cca071f35c3a86d7bf9eebb9e39f4ebebde52193dc68', '7e11750212aba19ace53b4df7ba7b509af5f797b57b55a9cdc7f4b6054ab7da094eba55df01a3d3af915a4f8c6e87ee07763907c294f8d4f064fa9749505f089', 'e11f0ddd484703c204854524d7c62c45605a725a7e6e32ddbbe0b186bb7c5ef373dd4bd889d806396fa495340c1efa70fc6b408a9a768424c2a05c4bc52bbc10', '7fa969e8904fe23a047c9d6e2119d7ca413c2ae2ffb4b13aecfc23dc878b6fd8309196b6c4a8b68e055410fb52a8d738c168f54c99d63c620fa6e851b8d4a43c', '8b5918863c1d3d98f029d8ab1c3e44cb8d339b7e5978f86ad4388e160b471920b1b18ed1e33cba390a0320943d1e0e332ff830a5bab2e8d6a44de4ebbf81aebb', 'dccd36e953bde0f4950eeb287307e4e97aa0c389ba834b73be6254a9eab14504c47a058946d01328524d56c326c545bf146a7507ffe52f5b80c18eaa2985fc11', 'f5373d87d65bf35a6b0540611bb91937b155f4193692efde27632e80deb0ee41d722c858df84eb9dca6b9a3e7a33194686d52f3dde1f65ae902086096302ece3', '0df75ad4fb962f90d5df78ecc29a85402358578071482e3cbd5ac4473e014c9e20a9186179aa87fef43c7f9daa403d254438975458ad76bb8a323a45b66f92af', '31a9a792470472f269d58b598b07f940fd5286c5e19a5a0cb3a11be911946a2fe6f951ed68a52910349a5a5936831840796c0514db4f1ae7313ce586ff957aca', '7dd48df389f4c5945b486892c0e351f99d1ef5b4c5db0056e83cc7a8c105d8e33762fa6706c9bb4381708a2a55f9569a2cf20070dee8d7cb9569d2250d2061db', 'af91e731672c3e9c87ad283110d5cf500f0a1c758a1a110065e4b2a0ef839870809c2530953512247a042bb0d869aaf14f1de9eefe878f62ccf48c3c801bac75', 'a983c7a67080ff34e9421bb220f63fd5aaddfc29115ae96b6d5ce7e7280dbe9961a19f800defa6639951465ee642f13361773bd454f29956fd4c658f84848939', 'b67d345396a6f54ae008a38b1d72cd33f803dd9ff42a3452dfc06588c3e1002611e0d8daedda7997ca2acdeaa3f5511de21584b536839941b8dc91a5adb436a4', '64f3d0b04c104c4ed825646f07837b6efc572107b9ddb4caf227de6f07cede0c093b8aa089c1c7a73a49c30caef8d0720c95255386a13c024f258ae96a50a4b4', '49d859cf96713f6fbbdd0f5f140989a76a6cf10708ba6dbfb86d306f0d71f108cd2d804cf9703d8a1fb7e9dcbadeb1c1ea1242733bf3812a645b16080f2b4c61', 'b35fe259aee814c366a9fa8a495a93c688c0a6c0323ce1b8ced74bc539bbfed3fc6ec58dfc4aa4de876b4c86e77a34c172666202239ac0a0fdaf660e2702af12', '77336ddcfc409d8b44e4f86de94d63a23e116422467b0e6c58b597055a5df6eade1b13d50f873f8a7faf0c7157ec26b5e9ac8e1ae31ecff6a161c3fe1900c2af', 'c5e9dc18ddc2f4f22d8d8865ac97e1c24be8b7029322439ad461555f2b0cb50ecf0465951afab0bcf2a72d3d099fcb0959f063175b0113532ea8dfbd5ef7463f', 'bfcaf0d7db3369e2cf2f753e4814aaf5f6ce3027145b618f3a3631c4690592ceeec3125917af8e2b2485c89c594d9e031b9625b6da38fea9423568901dded3e9', '1ba3e87b9d1a4a0dbfaae50464170943ef946ff23228ccac39d47efeac55508815d0065768b19b7a74dcf580eb6ad4bba238f3cb1ffbaccddcd4ae3c3bb79611', '055562caac7803dda44f30422e95a5119b1d856bd261e2fa0dd067855d7e5af258ed27bab4c4d86915631138768b33c828e5dae22db466c02ecfec52c66c7c42', '52f8b244a19d5b62e281ef46a19886dc4d042ae826618a7f1836013a534b85eb2721ce0126b9b3b6c16e278c6784c176d7f53fd3d5e5fa2101eda6a33dba22df', '0e5def72ad330ab65ee24b57e739298be1ac8774ced4e06439399485a356abc606a9cb13ff3d0158f2179b55c725af3cf9287d683f01c0b9517058e391c86184', 'bc5f52fa9a7cf0667fb276ede09837cff19817487102cd852e1f4543cdc49f044775cb5d0ba39d03a4386b67e6f5adb3f4cdcb5c6dc5edddb455e5b510ae9681', '4edba2cc501a4e6b01b97f56a6f8ccf89032a70903ac1682696ecfb9abb16073d3a725e58483a86f5ad0059515c1c4aea0f13a0d6f7d2b4b7b1815ae430ae299', '5d1cf82ff4c887ad1271b8e3ae01c2a0e284ed1b9fca198d059886f727e5b4b7bfd9b9a7af7ec0fb84cc8b146d27ff1516c552bb5ebf955f56837c99b558d42b', '0df160b0bb8275edd246784f4449eb32f4cce6e793aaed6695454af6a6f483a1559b33e2766d10ea980b1094c63d5f4e9999997f9e07bd44da0482bb4c0a5b21', '824cc75e20ebd1f41d7fb05c95cbefc947c9971acfbc547f52faf579ed2234f3e2480bbac16b5af9fea33b8ea72ebcddd1fe348a01623a19347fd36a87e6a199', 'db497a9824d24f1884910643d86b75d3b66403c0b564f08d33e1c287c260eabc2deb5510a076967a8fb5120c3e3aabb6e05a3f5c42e785e36d34663422085168', '33f1f6d11a10e42b444b55e1f43c822d681a82d3262f8cb9c5ae9b3f0084cd56a8581f5bf022a3425fc8117d218fde438b107671d636cb097cd918d8d0b9ed68', 'd037117a0bdd7b8d0a48ccb405229711ff880facf911a42ab73281a2391954d6366c43c0656658bc895557025d26cd4c73624a7c21790c0200e56fde982354e9', 'd4ebc43b64a53d3028f73d3b06b2450191d9451dc3f85185fa99865b6263b8c1ebca0ad68955530aa78703e974d0c0cde3142080dc07103e9a537cce6a3ea803', 'da2c10e54358df780336157f6900a4dd6d12eaea30556a7c36fb9b11af1bfb218357261f8656d6b13972bafa285c2d17209c4020269b7936f1502c45507811f8', '5a0298f9f9bddb0d01f4accf4287088f47f033f81f317c48ba45129dff4afc64b878095a9a8c74beca5e4b76ff4003d1be7b7439684463952c8c7c9ca563ffaa', '20055174a3116cfbe1ca98f4463db9b7e7fd0c079a5bf5b353c3f04d9c3c726d4a230049b95f6aa84723218a6a5fca51a84c27f9b0eb3eee7b61226c0ab12a96', 'd89b5cc9f4f79ba121b404ef3f2b0b612443e951cf038c34c7394041de185bab48e1ab7d2d5c5d999698b936cbeba51bb46bc026c083c94bc2434f7e5642c25f', 'b9bc06d59e1be786011eb9975d6147061a3ffaf84061763791cd6efc0c99ed2ea3f0d90b512da3f4473d0618caf31ba4faa087d2a5cb5831559a5f22f7debda8', 'ec5ae8b78052706364453542a63c5c2d35a5b16bef207bfbb57cbac463648ce9c614cdcffef74580fd95b441dd7e1426fea0738ab9d499df16f2e0269b355ccd', '3d8f304f3b6e9de2cc90c1357213b1c1829ca2bf4937ab3c6ee3147401feffe42384f506dcdc06568eb773799f89550469dffc5a2387343df6b3d525990f796b', '03e4172bb4602370e1a1070ef1bbf44ab46fb692804067e6fdaf1aa5ec75f6d79c4b0363c6d5c6c57ce15d3991a6e4b4a2f0733bd67d7f5ba535e4df4ba9471d', '7592ca383bc820cd8f82382a402779468354ffa108da7863b0a09b0cb68ceaf541630b9ba12486f6565d06499a094272ee963c7bb53d3f5bd5a26ab978581abb', 'fd35f41e8e2c27bd95fb111a526d9b513a6a2a268260c75a50ddc28f9d663f56bac3e59271f0da53663f8ac86cd7a9835b7d447ba8196465679156a0c80cbea7', 'bea8b4ae3a17ec52957932e7104c156352ecd8dbf57f9070495a4f96a1579aeaf3a3eb4cb1f82415a904af9ff5ba64b950d3620f04b00d75e8ed2d8e3f294f6e', 'd3ec8ed9b26828281b46c84cc9d0672c43e46d59e3366c12a95d53bdd73da685b7898ebe5de1528aad450a42818bcb180b538175ac78adffea62eeb20ca9ec59', '0eca6ebf5f668d343c2c3f7464bf9b5f50fd26744f2d81dc862bb51768007701c9d092ea36e24208626d18819568e1a83ff2f50a5bf1631ab9b13094813d34c1', 'f48611532d8a6966ff829be7e81586271ba0303b4cb361e39e4ab1b5b84a1704727fb29f12831ae9f8f05f391c02b121533413fc0f3ce84c1d8340b906ec4755', '951a27d8446a746dc91aebb07879e90febad17934bccc97a1f396f50acdcaaa2ca0b48c6ae8950fb1a75e1b99fea320a559321ba3a3aae48ec565835d0ff2925', 'c38921b3cdee0d4fcfdc33ea8da7062c943b510f3a3072f12a8739a340330a812c2618c895c41b1c38ab168a3b183367f9609729ffa2480ccf4829a5b2cfb8a2', 'b4444d0b1b34e1cfdbfeffe278bd33415225340c502e531cf1861bdfb7439c3b81af3de2b07ca71910c92375f2e097303ee82ca9ce1a2a779a8a1e32194a229b', '9a33d9a8f6a2347d4b30894248430a18cf4a1a89bfa7be8595dffd28ac8a201c73b5fa254dea128f503038386ab79689fc3064b5737e30074b9b3cdd4cd0746f', 'c731eb8811f570ba6e222bcaf99c4a2921065982b4ab8f72475b48949066e96c11f9884a120e5537f95ad5c14ccd63cc454a8f9b98c8ebb8a1c8641457c1343c', '2dd74d33c2475cf0f90306405ee8721e9b11801a834f42904c2daa43b44e1e0ec7506811531cc48c6bfc1705dd14d788acc6f28b4dcbf9f17316edbc3b27b519', 'de955a4d2945c081ea8e1f619742d1cc9d901f501283eaf3bacaa0a3624786452bb267f219a674a9c85cf1a0d6cc421c26a64346f236644ab7b6a02fa2094413', '24d458fb90c557a43ef2a9438c3456e7aed5d8354e000f7a768c5932ddeacfbd925234e9d6ad0183a7be1c79b6e19a3f6c4a2fcdfcc00e122a80147d372c6443', '1826a4ebabdd7b5d09addbcde73a22f8ffb8a6599408b9435cada3b6dc90d194915030bc68245559f826afc94e2a6fee8c756de59be6b7edf19b068950c5cb70', 'dd9e90689017d8e4c692a02aef7f0205b0108076fcb9eac26f4e09a829a5c28ab8d2a59ded726c32d74a497748c92693d86cb9a64d5fe1ddab311a741e8dfa0b', 'ea42bd0b078025ba4c7d1151d2f7b5896bf3502d6a470054ebcd1c5a430dec21e8c618addbb12d06c93d024168a65fddadfa77b2db1ea10de78d44c5dff7ee92', '4613a67fb89d6d12daf5ed4914c2464f590abb0265cbd5351166b3820e8ea1b484d95f38e6eadd08b61e3a691350260e35d6f41f0e30132513d79cdbdf3f6622', '26232830b7994c79b9cd49cccf9941010c245da5826e269a325a95059127d173bce833aa2aa2831653141c5b94ab2d4d4f47865a00f7e67dbdd1130349f5ba8d', 'a5a6b40b9ea6ae7117c29eab5cbd869db50d9655794aad25c9efbb317367e1e3473abc3a293af9b0a51e42ba21976000445ebb777441043ef3781380423fb5df', 'bcfbd92b8264f3026161debcd8c3400511a8ab8ee5c2c290849e1bd6daaaf3268a17dbf7811aa91a3ea3cf19908d7b309861a30aa70349244e77749612df9fa1', 'e7d0f146b92b392f55f5939917fe336bd3cccfc85361c631ea1f9a66b6539c64e47e9d37d99fdc7dc08f9c3f7771c9284f12e9212b289def830a9fa378e313a9', '30ca24a44e67b69d9362dd81d5b68425a325d68d869c11191444c1d0647c7d76f7922a3ce5fd0ef28f1b81ce4e4c57bed5b6840dfd24b913ce4a75ee67751c54', '4ebc0bbee2c1ad36c5011f09eb77fbd4029848607e86f33aff20f53ec60d2f37f8af32aec1b177ae41ec12e52ddcf730637a6eb6aac1c5c9e2d1c23fbc9bd1e4', '6b319971946131342c7e8753fab9e044b0675a933c4b9136898242fc1b3a0f3b9ef163c9ecfb8601d021afd6cd5334f3d794f7912969fffe9d633280ebf3c6c9', 'fffff51eb5c580853a8e34cf683fefd2f48cef47aa9add4df3390b14d0f0e15a4b694f03526bab8a520880061fd9afe3b60973ab554c8248be0b8581af96abe5', 'c65f006b79ffe1e66ef33258664fc8636f33ccc55eeb00d4182f7a6382a9476ba84f9481af748939ce4bb8ba5d610290e3aa6d6c912ac33b117c94541246db35', '9fa7248b517b9e73227c5e60a99091b8e674b5390c8640a52aadea233631c81bdcbf54425682bbf092b428bca6606a3af4bdce8aebfc0424e6561116f2493142', '09899cece2d356a8d1b9ac4eca2a40c33c9efc82c20919eb765e7cb0a1ad986546f9e39738611045b22bf0d482e7cd2dd1113cfcab797e00a2d495d9fc1b3e9d', '23a49b60ac52d857003e045beea305240fa574e82c1b4967b02db03800f10889ad4a1de0968254d4d698252de10b538dd6907e71b1cff43a298ffcf28d234295', '5739ddabfdf3d8b5feb3c1c2186b504b4abc208aac5c86b57c80d9fdc51a9d6a98dad631c621c56e25b290d9d9109322f47f633f8b60e0de826b9a4488250234', '29d75c179dacfa4a3bcc9c721a71ad738991b3fc5594398d66e6118f7d544245b2bc7dc33a278d72ab9db9ff476f4b5345cc0e91d57ecbdeb0a2beb7e6253c84', '86beeaf324c1923d0655e95eae64dda4a6700c4eb88c48584bcbe302675c89c2eb6e2ba543b6b7a9e880c3b9029c064b4bc8557ec76e63528062a162454be762', '46f1c4858e397bc3256ef5d7c9dd9e31b56063f9a02cb72ec947b21cb5884e10af4e6e75528495b116d3fa87e5345fc5c962a952a34930dac4d59eba0fc09672', 'f9878419c2a7b8e823638343c7e621f55a1c7681b009bc6fe9acf4b7e0414daf4d83bb21a16d5443d6ff401ee2328adbb0f8620d7abc88eecb79d2b7bdea31a6', '3ad3e3ce21ef3fe95eb22b21aa2ad0b951935e7b549b22a3bbb333a367e91811a88173e79eb2cb4af890547772851a16b9d5a6b06c5bb4b05742de47018bcf13', 'ccc1ca19694792efe7b85541b5b2033cdee9dd777a68f51ae1e0443fbacc17254fb29c90a76e119ea922314344706e5663ee8343ae5c7076cfcda368a68f37b2', '571a7af3c9f1cdb71aeb588dd939bdcf760358e0b3a823260ac55eb8f35480b1d017cec91a8a40e4d0f59f253cefa158725242df7a0a1f78f6d27488d5f136be', '3ea29b8db6a3618bb94cbf6bde26899391da67f610c01619fc0a48079e1d83b2921b869bb21344c577c63d8d40e7cf1095b578120435dc58151b3eda10de4303', 'daf421cfce7f59a329443f43cf771f9d575cbfc6f3c4536eeb6cff5440921eec9eb3be41265d4a827e4eab7532875198d0f73394c27394f836e3da955b028b8d', '0499fc71d5dc80d9af7ad4e1fbc339c8223cdb286508e680f3c18d551cfdd42f4af79c8cb782eceda2810c297c20717ff4f16f786773602069db1909f9d67404', '9a17da75e7c759038d2d69d22ce602e23892916dd74ebfa6f692ac3df31b1fba82cbb68367c8c92232e334ea7e318a5bf15363c99736816453cd73c47d22ac38', 'b31461a5edc531b16d774df9cc973efac6b9a184cf8fdeba4f3b3ef5720dce668cfccc253a9eef58426bda6089079e0c8968a90385314fcc3c36a96eae968072', 'eec66695743ce83e88d46c38f81593a3c08cd5d3fe46896a25df6258b2b604b22119523fbe3171af7e76fb15efecd2e3c33b2f4a285268c123637c1a79a036c3', 'a20397a1cbb61d573399ad6e2fd57de8cd48d0d809efd0d3b961a322931d2cd1fdcf213514641178aea3e3c8c739ba6e16ae0bb14fa24b8a863c18cf19e6ab3c', '04cea306ee10fe8c1f9e49734a6297681d28af9594f9c39eba902bfa3a3aaf05b1ac2bc2ae30de17a29b64bdfcdc7012cb66cc48466fee14a19d812c40eaeeb7', 'a5db3cedb64a7605017e9b3281c5a7be76f1ac056c81d48288bcb77d6e410b44d4b997afb8b6e2e81603dc5a4b3bdc74ddb7a025554ffde03e197936f4107905', '71af1334c53666054bcb4fad610b2564997d48b4ba36275e96650040d53910ce6e03ef6f527d1be3b21fa68ca4169225b7758beeb96890b97491310b966a84b9', '5a3b9f90b39a3efc75e004024c92243b6fecd4627b63f4e47e7fbfde8cf9160cbf85ed43d9e34a320d9edf8b6ebc51b033264c912b9789cf544e34416390b7d0', '7af1da6caee1a2af17e03fc8f42392dc7fdb85a48af39bcffe7d65b340600424edbc6ccb690efd821f23612fc7bec0876419b656d59695fbeed48f6c8c82078b', 'd0208dd579d8bbe08d3c48d4e592db562a25cfd264baeb6f3956b7a4ef4236924470950cc1dbbf38e85eb255566a3ecc5dab87c6f5966585da9aa660c4374d6e', 'fe3459dff909a31ad128a373553f570381325aa576c9d309a412d849abe1dd483b4c4c9ca64488dcd117c1111516f395aa33c301853ff07e2ce717f046ea4e35', '1b30f03911d0ace3cb0e8d577db83844ab4862c74bdfe31eb3ab276f92306d92d8809b038364bccae1c6d7b1b904f1e270c1482e6e421b8a6278f6838ee973d7', '86c1286fda40377966ce00c60e17da5f60724cf6cad9d7e94f5b156d442a35bece7242555a49416da4ffcf01f747cb17f0a79ac2f7953cc617cfc362d99f968f', '8a6b30f4baba7c896fa0703ccfd12007285626473bfdc37c940614a4ced4a543c981ab844ca99d0c3a61a79edb2852080a8f216785c9ed74b7cb02056162e813', 'd4cd0b6119a8701b90df84e2b9c5a2c1e6d720cae6636701aa9e4c0eb48d8b4e404010eae2e5544c81ae54324d93d39216794b8cda93a5530a50a6a6ece1398b', '58b3a265aebe31986bce81a9e8bd92c1a59e00411b012b9a68b63316d939466b01b298994bcfb9286fd1be814fbbe6c4dbd47bac7bd9bfebab8fc7a6e3cfd8bd', '78a9c042e49b25f03951587265c01cda5cd857ee8916a40677cf8487012d7848f0188398f4f9d8d33fb60e5ab40430bb88193b194cd7d66aa48e7361e5130be2', '794e3794788dd31f48fcbd614f1c8fe1761a665729b8b44ca8307eb217e66729364d0959bb2631573a1d0ade673d690206caf7081f27c58a909a8e8da11c4a4a', '74cb76ef8f5ffeab834c18fedfd011273e56c9735cfc53d3c17a6675623917f605a459e3db84a0400d72427ee4b8032396180bf29fe9094b57b7dd579a9c627b', '33a0bfe9a5ed6a37477df8edea08ebe12fc98e498d9379ece1945863065bebf208da34f349d3eee1ae57ebf4bc510bc122c5a0be3eec1e39ebbc01a59dda6b26', '5e75f8db851c0842fa38981d412fcf784e0b61a5e4d66a3ac78f60e59294fd8a4b8676ae15de378884078cabbfaa24a87ec6543d03f82d684998c487cdd1bc84', '854ce95f19b6057e69ed809987a732d54f7d7885dcf1353f20fbf8ef3785f40267faadccf0a035231a19982432d778fa4c3b52a66860e0507f69889e5871bbac', 'a212b182371c91e66610ad3aea5dea8b6b4cadea932970cfa58086b8c8c69f3b0d6a92f7b904d93f3c3147a1cb39637d095648a39efe410137da4ba34807bc47', 'f70881fc45a95694c2335a846dcde6574c88371258501229cd44c9864ef540a70c822440ad30b9113d1fe1d100d96ac18ded383a8e9302099cb52a49ea808b38', '459828c5c476fd858bc79d7ba5cffa91e979dda8c26886523ecfac1d7e938974be0492bc053d93f3f2ae7aec563066a8dc2a10cfde52026cd1ce23bb456bcfd6', '1ce22f671bab229790cdf5da34b74850c2f8cec60030e94ca9e27a6e043ba148845470b9c257265d77f37c005c3849d2a6e53c1ae78e9ef6c99e0b23f31c47e8', '48e8543cb071af90730b3fc24f3704eb9267ce9d18623da87ff51ca7c039f51415c3e7e7b16005d215554d93340fcf4d6e58ba4dc6e885f12f6bfbb79ce01126', '1236dd5c39878406330263ec7f1fbd6cdaee7e1a901f52f784b9153e58b847ba3f969683eb8b655fa03a1b04c59629ef98223a5ed3d8d10466a178f42c00380d', '573b386216dd59394f8e772f65bae8c5d5d5eefcda2df5027f4a2b25b7b8dd83a88cd04df669ddc365740baf19629366e91f7d5e4dc046da58477d142d8bb9ec', '4235ab23e2b97719df3a42f4cd884814d37ca15e59dc4088111b43ae330bc10cf11bb58b8b53fa620a924db232528ae1c1ff4a949fa0d67080ea4c20a6f9d188', 'd218387ab9176993964fb7f0959341121d546481437f4efbdcc1a9acd1d0f390f9cec2ee9b488108d80ad332fd97181252dccf6f6e74c7d0f286772b8475104d', '92cae7df1275bb83d0d97a293e006d1ebf47122401840e3088de151be911fcc0f83e448409919ca85af100359e02f002aadbe66821710b0eb88ecea442dc67bb', '18b0b26a5da11258aaca26d13807468df00bce8784998a77400efde6f3e207ced02cda14e65a047489b9b2867470b553f2b9f45e38a82eeca8594b4c2f35bd2c', '495b9c6d7cf9db98e21f35774f7fe029f2c5db5a13772bb071d1fdab0c11fc4f81d49537ddfeb564e5aedd2182f4733a8528e82ab5e5a3ed21131f082dd1de13', 'c1ce8a82622d1fe200fa0695cee0442c8e3fcdd34700223af444323c3302e4a1d95be0f9fff692f049798703135da325ae0b4b4bc69d67ac8520c51d95333c61', '935c97dbc0a22aedb8e68e81488a1a82d7c049dadcb8eaf17656159bd91b19bc16c689d036d317d0be3be11cec4bddfa93394149b109e0bbc78be819730d4ef6', '1020f22ca101979fa341b76e2403524a3e6f3caa92c73181b9df869c79d8877daaf44f24939ac49903e138385baed1c2b1b8cee5d4352607deb07c1ef84c2441', '19eb9c9d6697aaa31df6ece010115458546af10f892d6bb35dfceb9396a65b140adf146f20507bc00968b12a254d207f1d5bc8e47abe4a5c084916e15174b404', '2cdd88cb13c1ad72dc66b0051b56399b824064723f858d23ee9a9b6f5dd6ce9b446664f2fa8b7ae045a1c651f3b743090e790a044947cd6a9ed81daabe85ff88', '0a00b951b119d13a509e1c753136f7624d14181b9f8908abf86a35c162e06020b28cdb95fff7db9a4f138e0dee9dda27f12a3ed45816cca3f383fbfcbef47f7b', '827b6e59829a729d5139437b0ab054bc343ac7fb97ea5103c410ffc77a6dc2886a4532a5fb51de2705429d88371c0f1935565e8aa5e98cac3d7940c16cdaa39a', 'a818f311e06cd20c8aa4c87d4cb65b0f22e04493cc6daf7eab39737dc6cfbe90e0e57de9bc0a6d0ced98500f7a7a75126953b0d95fc9756f7a71798dd4d89c31', 'aea80afd42233bcb5f2a7db42df4d5e533fa893a7dc7a39a46a08a480cc5aaaf062001b8c2cbe3612c6aeb303523f422201c116208e6d43dac0014f97a9a4e39', 'c5c9b9f715703af11ed6321667c4f5ea8540e9e0ef65520eaeab996e63e34b7500cd411f1d4bc173680e2eb425c8a5ebe1d8d0e8b6c39edf36b541c787a4422b', 'bc1d736c8845e53be45af17742a202d2dea1ec18f2cc50228b7c9037a2036b8584629d84ddf4e7f3635c042ccbb28b242c89bf1fde303d6a7e2d5082625bc1a3', '42f1c8f74bcd017fe72b646b1c50675ba9bb4e6d7afb9acee351962d59d5fe03761a0f99bfb8a7f274cd4112bdf87e4c87653307d637d624950e67b3aebae7e3', 'ebf2050df782ca05964e881ee223547e4ef23959092a143b18f1cfa264c1215753bf3040157374d78f7f977eec00d645f6942df42d91eb195fd29dcaf62c3885', 'a179cb7ac87517081bd721065e8e29008e160a5e7123e2e7af32baebc69931994a333d5c6aa05eaa2e397a5a6229ece9c493f795e35c8c8637f914f736621b40', '6715c5921186e120fdbde213ae67ba92332d87594117b5cc2c2a7df6c0e540fb65cfa3021659bf24aa7e82593678edeca7806b324e9937b3e7ce12e2b7be5f8e', '180d7459f457613b63dd65a030dfd3073d9e4428a98ea902d070152e504d7d2e83ffff9994aa31d95007cd7a371a7b0cd436cc44b42c0f8d7a46d69ca636b794', 'e32dff4587923fa74dcec217b0f9dfd3ae61753d1eb9e3916e66bdb9d80907d907b4ad35b826b95c00ed8e1a22394223449dd3341f0aad19e3f3e711f36fea72', '4809d2074bba48dc84a39b16e261205e751213b955c2648e2594f0a02291369c24899db2118f4c9296515316f79d4d8f5d2f91a083b07336a537470dd44acaf3', '0fcacd01d77b3b193f9ef80db8ece76c29068eb275fef2ee0c97c205096c5fcf57299870c0be247c58fdfced67b1677d3346b17874b82786c10f590dc475c441', '05121897679baf262c152ba268da366bdf6a484edc29f18bd3c8815dc532fe46bdb78cb72d282508e75d2a35da2cfda740c63be9bf5fbaba7058058135bcfc09', 'a1ddacea712ab4041e338abd2287ad266bc46ec5f4d370a43895952c52a3f40c38f3cdcdb6416daaf08c2fcd846047443a01c0fd07ea8794024e38d26f49903b', '05d443d78ae1a59e9c3dc1fdc9b59ca2a473bbb2267163bc918386acc513d87ea8e06a8612881485b54432a0e82a190ce78700e5265621ad3706a17203206681', 'cd72b73846a4f07348b970043edb84fe164617cca7d2008a52a65e64e4107b2227ba8cdcb2da36f289bc46a7f181874276941e309b68e2e284621fce14a88f14', 'a1c9a4d2c316c5fb971a239f7cd7bcbc2a673841dc05b2a9a498e1a8ac045a3be74242b0b329f799a8390ced7732fb90ad2652b24761e24153aee00d5debf90a', 'd6ba68fb00ff1cd7367493c83544522793a78cafb70ca4117cab072c629bd1e7d730fc9b86eaf966175b70890fa4d2297b698a647e7a7c00e41683de36c9beeb', 'ac84e12bd7e1ccf2fdfe9a5f1da3d1aceff3ff50cf31c4fa9e9f7354ae0389686760443ff0ee6b35db962be7939fe87e52d5634e6458aba69a30b86fdaf8267f', '159926971baa6fa3822a03e455abfb790bb7fed377d93b12077034d86ae89588fdaaf4d1c7922413bbf2bcbac2fc6afef95eedbde80e8e974faf13c00a9eb32b', '280f94a0d2c252a0f69141d46e1aa44242a0cadd84c08c821685254335fe71defeac106b08c5a432865e5618956446de7ff07c5f4c04c3c38a17de52afb6a6ed', '23dcce6fea9ffc9a7dfdf91ea14ba96a6a8a0f1ecc9d71cd4d4af777be9aece47d423987b8a92c08c5c742ebfaceab17574040e26faf62c13625b7ef6b174304', 'a0dc89d2574c40772006dacfea034b34c4c4e624165d27be05168c8bbbd3646d2eef4996d67ce38c62c0b5ba6cebbaca95eaf4d22ece3de4253f34d10c03d946', '42bdf529b571cb72e9993c9c7f6b39c1ba3973df67c716ac38130ea588159972101801db1501b73e2d14e23359b65c387584c7e6a081a192defc513e35fe5772', '6b7e28161be631b9e964d18b6c30329010a2d1818ab43ca90c764edcac397c5108f4bb68abb22395f05a0a1578b385c2a11e3d45203c25dfdb30fef96c9cc05a', '1920d8a93f21cbd39f451c0fe8087e8fa59e49996c96c1e00f86b8416726880a96efc0a694bb8ba61488b4b5f4366ec33c10ed14bc752ec76e801e31a14aeb57', '37837c173e4f11846864856c79beedea58ff68fe6febc0ff3f4b18303f0244a4a65bf9cbb9619253df7ebecb0cb0e3769b6e6223836cb25a602efd1bdc71d5a8', 'a5321d7c99de9920abdd4ec35184abaed4930060954cee5a11bb82efaad46adcdd7a49be1300af6fd8ea9e24c70f8708ee200d8f8a97c45f9a00a0f014a86b59', '3307fc7794397d8b104d3d3f5448e21f3f1fd00f8d9c4fce262b03943e05d51ba58a8eb205f16fa361b27a53e309b2874786ccaae5e820cd784d1e82e979763d', 'e2d6f06062d560fbb0ebcc149237b0f05e86ed1c35260dbf47b4c288bcb26382c35b6cf771043b63a167d270a84d1c1d1aec8407b0bb198ce8f77e792b8f1569', '1b0c1a71dd3be646b3abd5d9e2b158bb4dbb6e841f42ce2cb987f0d72469f0c1a4ff6b4205b1766b795677376677e8fbb72412b5f519880d5e8422102ea898e0', '25954af91b662434abbd713e10ead71592733bd103526a089a8c084cb51765fa87481f177a0c95c401905c65c57759d2c369046bac941e04d4a29a7a2fbf9cf2', 'aa75b974df510feaf088b04d06f2231d34dbf72f1d7dcb6628e33b5c59bcce3254532ebcd290507049570ed4750422da82682682274f548ca86b380fd667fda7', '569ce2d9f37548b86c565c42da48bc71de9c4bfccf7fe1e58144e79d8a8c14ef91a7e75381ef9e5e5449bcc68d7d9d738d0f280a14d8685d2fff9ef5aed26458', 'aa0ff4e6979f96553d5a9847bb74d396c853eb447b0475a5d44fe57df906e4e172eb2ae674b0ed70b7a6fb3fb156fad5f7e0f994c622dfe614133c9019299c5c', '09167eff937a8326d4f509a3976a6eeee122e21e82126bb947155eef568d1d2123db1057501d47b16098c83211528d4ff89f477e4999c0c9fa43404c5cb7d072', '51a1c2751b270b25780d604e29173e3d333758eae7698e17284772346d3dea414f0746aae7c446c37ef6235c31c43ce3b50e6f7fc13027356543e49480bbca49', '1a3e722c3235792f188e48ce51f5f94d4b9079516eabf543dc585d21774246413aaf185f73e2c0d57ed3ca317761ee53f46038194edcfa9b9e80b804d0e3eba3', '1572221fd46390e61bce3cf86d075314a2b2f8accb39eeda11b52f3cd1761178bcfa5cf977c4a5d4e8e101eab3d70506d940412d75880351c9b0b756e803e97f', '526a6c14d1b00f9c125de3878f979065d2ada73a48bd2e3f8e838aa72f2b71ab8cba48767815fae67aac0e94f9a581d06f611866cda97c50fd53173443ce15ca', '8b67dc0e85f795836eb912f05087fd713134a9c79c16858ea5b7b449df3c339e8ea36eb2f67401cb480d103875e65fb2d990c06b7bf558edcd2227bcc100e356', 'c0228a38e54e3835603e3eb144d98333173fd6256d65a6e9224f720ffbe45c906c861d68c23164f0fd62a65b485d1f9f79cdc54ae12b21a750303e555c344a92', '9c47fd0c282f6c7166f4199467a72af42155be0c7d25affc7f5f0b086ebe97d6080ff7ab6d29dd59830ff4bcf97c6748522a7d554f88774803fad7c6f30c8fd8', '53061ec43bcf7dd8ffc60403659834b9ce52e7a7a766a15b01a3123d9679bb3deae99784216d64faa8046e15cc7fa8a4f1f2293087fd9c3b67965e0e49602f19', '9fda45184323a28c19a9235f6a52cf39a240515fea6853ddc8ea0a6630ad96aa23725474abd55f001b4fcbeda0e4ab0c248b65e72d0bd0b7dcf14b4bb9a911ca', '14baf3eeb786a6979e122012be4e5378d52c4d8c26dd5f5eccb5fd1945d8ecfc1b38a99474d4b1d13cc6b30811d27e5a74af0b23105e00cce8937fd0259579ee', '1fd396efe7a3c76432e2d927f6fb39652e25804adb746c22771a094bef9230d3f16de326528980ce473a59fc4d45abc163167d238f5cada740977fe17f5208e6', '4f968e72cb2f911e097c1c6a04b0618a8f64e40fa6410793b7c11f77d440fcfad2eff424d9408dd2957395b4e554c78d3346ee84d9877a40ede8670097e76553', '58fbc412522a6b1296517860310bc50d57861eb027e868105d5d573adc3b0d7ad4b7258884902a4cbdb7d4e50720cad50c4029e6629d56b1485c30211e9cd806', '421e60e3e352e1b5442722b4a576335fbf1492401aab16405568490431ba0836ed071d6d6e478ad21a62826faee281486a3229abe583378f3f9811ed8a0262f9', 'a2789c4a9001e6ba36847029005aa551ab1561e8e16915cc3ae5135f8e67a37cb812f1a927180526681c0c7bede65a90c5fcf3c8034e46182f3e53d6047e8dfd', '1b678512a64f8bae9874df034a924560b9292829c3e079a5161bb19619f6cd2f1bb781994e0b13d68accbf0e84503c766a99ad9f9bbfcea4f585af676f69102a', '7f414fc758e6b2143b0fdd48e0d1fe907b9ef56cefe108616dde1ac744c89c7d0e85dd5bd40e7538d731ad0170fe75606bc66feb9513cd510c87948169262035', 'cfe673e3ca9bf301588609008f4d632b4f10c2f32973c8d64963f3245a82ec83f5320b631756e45b9ac21ca709dc2a9b8bee67d231155dcdb4281a8e51c337fe', '1356d32e037b0b353204c07c5498f144254aff83bae72d84566d30a840e809a4d6edde050fa6b7992c9e103b0727cacae96476e95cec2354ee04dfc45eca08e6', '260634b77e092e520ccf81781dcca13926f7b96bb6ddefe18dd594b0b30dd25c493061d262154d43642d158deb8b4bab7e230178423aff054e8a77120bd21042', '36fb97b60098226786b62b3e8d8fc31386e3f4bb4acb900ae2143b9e28271aa18edd389be9c6dc1224d5eaa7e3a08fe70bec1b2f0da5afe91cf0fae02b48b90f', '4b7386f7f08a2f91020bd637bb18f98a331653476cb6a56bebc9b77783ed342ae8d21fab6a1602697c4ba902ba52ca914c893d566311f7024994c0b0045aa7ae', '64d5bb0184df18f5ea0c5d4767f11c8dae0c301239762636ce378af2cb29911328384a5baa4d875705ad9d286fa500badd2c1f20245c9c121ce632c41f6f2187', 'ee5aded58e495fae340ada94177621a11c5056f3eda6295175966c5edf1a92a6fb751fe69b799a4a535eeec9ef49dede42f623df32e702a87bcebdac32ec8309', '83a11e7b110590da894e3fd5c64523487d08822066f9d5bcc09d0e8705707b5baa0802a38e6ab43d94faf47173f8693e9ede11705b9e6ef11756244d18d25665', 'fbb0c0d79a18d1ec052d612e5a75efd48f7b44fb94fe66ad1d8385ce533cb4e7a8bbfb4212ac99ddb4fff01f71f7047067c97dc919cab5a0279c36f23b4c377b', '7a957f563de4c24479757907832456a5639b5c6c61841015f1d1cd703d4b0d37cca2dd88fdca0479a8a4c831160f99568110c09e7f91943ed8e279b8ae686ee1', '3050c6b3a12ff34b53e48970a6e971d659d09e5f74e8d2338c7e50a84f427228b2205bc4366c7250041ee32e057fe17d06f1a19f5e2a254d0eef5672f123748a', '3945e10cad180b03351c1b2edf3a9da60f1914efc973aec22e784dac7de9fc2a0bed99775b560d0ad656a3fdecbb43c94fdab38847491d2634fbf46ed6aa763a', '884882fab7dd0db9c61507da11abb20bc5c7bf003ed1746c48c8f0110ba63ce8d447831a0105dedce614e6edaf63143d455720118325c5dc0303a122f5537d04', '5cf3b662a726df7845a370870e8d5f9ec01fc7f5b130a08623240ee249d757bb3dc8a7bb25d5e520bf9df0d9180c0bacf3ba0bdec3c30db2c8d94b656d10c8fb', 'a217dce29a7b684281ad2def5e8e65c4120b5b3addf52b605ee35af3da0f3eaf643f7217fc803bb394f8df60d357e5d3781cca85805983878ba8066da1622386', '0d6c36442d16f091f3aa62ba6bef9837da71b9c3569c1c312550524da0b7611eed62540c790b32f5cd5d13cac05a2a78727f7a8d632ec853cdff60dc0fe05056', 'cacb425b2e399ece047f46dae9f419e6d254da09936fbd0cebd6ac392aabab42c0e0128aecc1de0ed42e611d5dadbfa284e9e71ebad6979c38dc3b123d347f60', '5e747d79e98d34de7ec55fc24e51b41feec52c80c8c59db69123c6c5883931802b32f5dad9a4caec6326059332844184943748ab175744b70681cba4086caaf2', 'cada0f552899aa6a576387b126d2663fa1f84b7a61294b4fe737fe14a348f6f23f94b7f6aca5d9d83c35c58a31951ea5f8c78b77cb375270864cae907660c23f', 'e89b39ff9cd6961af610a6d36d5d6ca8aafe4a5bcb88f5008bf0f6b329b338af6b03199c9f83e3c71026f2a12fdd59fe1bcf6f24b4f442ec702f6735bc365d1b', '9820e987ac7a04e58fbea54a8205df9db51bb4e9eeccbc3bca4ead6ac72bed8a07fef189941b57bf67bde1aa6b01aa95c94251026e4d047748028468754576c8', 'ac742d15f291e7d7c2b61b9a459e626aa09e79196462cb8dd4d717e44f115e85a9d7d8a44e94c7c4a334ac0d27d0e70c5631595665febd03416a6f35f4c877e6', '8f1ccb9e52d9403b47bc9c4ce519ba2d28067e19253c2a3cb15531cbc030d4dcfe8df26515fc77b6af927b15950fa5ccfd2e80ddd2d503818e82a476159b8c9b', '7bb8d8404862a584c9e22d164433ffdf1aa19cce9c148435e92e8060dce28b1a0afe8da82c1ed79de642bb910f35d5cc9a74e9f9501687e46395fdef43aa8256', 'eadd7fc463369841196287d4eff1eb7ea89271ca791ad2be885b0aef17fbffa6cbff6932e5870b16b79b0cf46d4bdbc7555661c0941ec4b638c760b5e2de8498', 'bb5837040533ece0060c93e58084c72d9da4325d61048cd49ae3fe153b46094fb16c323b54c534e9055967e560aed4feaa46fbbcaccf02f99315d5b6a1e534f7', 'e32190a595b2a78c23a41e3ddbb3c9a5e0f56e6939d1e3392d38f8bab9001bf87d6263d610c51ed967f1d49c389bf7c98609205bdea5221fc635fbcca3a04d2f', '3180354c48250bfce2dee1da6ad43b7a55f96240980c41efee0f1279b8af70b2bdacf8cf3a09e4af1c893f4f94742758db1f4d4b65452769c57c6911e9b89148', '815f33844d80182b7edd79cc352f707301a92a076915c92918eb0954ef26116436add345a6928bc6e3b82b9f95d5207a4bf82442f7428a92c25254be20dcfeb4', '2046aa9745740bd548972b6563b3d9cafd8b2b2f8f11c04d85d4a6cbbb1c26a8a805f8b452d23c915fd105a65874d767b08651f773430cf1f175138f0f96d893', 'b3bcb9546c5797bd87dd28df56a6d8a2023fd31a7817fe2106e12ee5b796c3dfd15ab79d349d63e86761713846ac7eee462927b509bcbecd4bd5c2797b6e0de3', '9520c886ca8b0d12581533583be39620948cbd837cfb2d878caab8f07b30873f4c3c24bf12ecded73c21b4569d74470533175bb5b6eafd46094454be7f5025e4', '5eff8a0fb461ce5dd113c46ee3e55f602c43aafe006baabf03d738a07e38b77fe2055a3ea904ca6c26080db93e42f93ba8558e20702c304ed6f049d4213368a9', '75c57cb18f18e09b91f0cf955ac8992630da558b8f126e05511492ffc45ceeb89d929f4c7844b50fefdcf1c5f6f719374d72f4babfe944aab559048fd59e5796', '03dc2ba91327cf639eb616b5941efc511624c8efe949945d1a7635e472a156134b62d247bf35fea3862524096c5f7da410fd39c92e858ad8f653b4863283dfe4', '80cac0d445a0c96ed6210b66d6bc188ff8e8669201af50f72b559681c212f84f70ad0ac90bc43a65b0a8328636c5b16c0306c57b638c82855af50d8dd83c2b2d', '72eb91e91ade33c9adbe3e13e100e6475a9f91b6d6b216a6712a5be142c0867afd268aa91e6c1db60a95a7ff590c4172e46876f1101f65440a97bd2d48cbf645', 'a7db0c14fa61d7b44db586e96541e4499d918442923064b737a297f6bd2ac8e62f07f7f24a0a052d3f0df2e8a7273b39c6d59ac47a7136ce7a3717f32c5a113a', 'afe36f9ea219ddfe8d773d5efc982b1971d99800143dbf81e53d04a9361027d3c910a6cacf229d943680921575bc77fd908a24ffdc0eafabf29f17fc45a78763', 'a0d05e0c7e57b01391a5bdcdce7bfa9280157cd72a7c14d8bd1647ede1df38e1bd6aa943a3c8a4aee9eac4e2ddea17eb2dbe91a73f5305f16b0d768ebd63c646', '983b1e34b2e2f6e0af480d50e00c1085f4117d4f3eb81218e0d5f136d98cc47ae13fc3f1870a1e9031b122819de0d40624889fd707e5ae257dc79ff9f53c08f1', '24525e3a995de997cbee65b55c77ccd401c91bff9eef83bf28c7fd28bfec4dd14e2cc91a08b8f3f6cffed23ec4f34e921666cff1ea0175bdf66eaf01f38a4368', 'b15d211063c7e0e283fce47e92c6dba28e1bc57f54941595aed6904e1877df7d280357f06482d7ff069438f75c2b41484363ba8325e209d62b19282dd1d5a3f6', '7c4828b29044768b966b3135da0ba918dbedd35a730f4827564ed3291a508417f16d6e60c95a6ce50ed5584f661a5f67772d19cafb8066902f59a7b6d2e99160', 'c48493114a1288eef5fb7c7c4ef68609d3566540ba559ccf137fbdf175e069194c7635dbab83122bcae960039d453ab1ea8de839ddfe417b3026c67981102918']))
        rep_ids_to_query = ["-1"]
        for app_entry in app_entries:
            if app_entry.customer_state == "UT":
                item = {}
                item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                item["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
                item["address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + " " + app_entry.customer_postal
                item["rep_id"] = app_entry.rep_id
                rep_ids_to_query.append(app_entry.rep_id)
                ret_json["items"].append(item)

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for item in ret_json["items"]:
                if item["rep_id"] == rep.rep_id:
                    item["rep_name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "formulas_testing":
        self.response.content_type = "text/plain"
        txt_buffer = ""
        formulas = Helpers.read_setting("proposal_formulas")
        for formula in formulas.keys():
            logging.info(formula)
            obj = Helpers.compile_formula(formula)
            if not obj is None:
                txt_buffer += "formula: " + formula + "\n\n" + obj["source"]
                if not formula == formulas.keys()[len(formulas.keys()) - 1]:
                    txt_buffer += "\n\n"

        self.response.out.write(txt_buffer)

    elif self.request.get("fn") == "get_rep_exposed_formulas":
        formulas = Helpers.read_setting("proposal_formulas")
        keys = formulas.keys()
        keyys = []
        for key in keys:
            keyys.append("expose_to_rep_" + key)

        ret_vals = []
        cnt = 0
        while cnt < len(keys):
            ret_vals.append(False)
            cnt += 1

        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keyys))
        for kv_item in kv_items:
            idx = keyys.index(kv_item.keyy)
            ret_vals[idx] = True

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_vals))

    elif self.request.get("fn") == "change_formula_exposure":
        if self.request.get("target_value") == "exposed":
            kv_item = KeyValueStoreItem(
                expiration=datetime(1970, 1, 1),
                identifier=Helpers.guid(),
                keyy="expose_to_rep_" + self.request.get("formula"),
                val="1"
            )
            kv_item.put()
        else:
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "expose_to_rep_" + self.request.get("formula"))
            kv_item.key.delete()

    elif self.request.get("fn") == "formula_to_js":
        import re
        self.response.content_type = "application/json"
        ret_json = {}
        formula = self.request.get("formula")
        phormula = Helpers.compile_formula(formula)
        if not phormula is None:
            js_formula = phormula["source"]
            js_formula = js_formula.replace("float(proposal_dict[\"system_size\"])", "proposal_dict[\"system_size\"]")
            js_formula = js_formula.replace("float(propoal_dict[\"additional_amount\"])", "parseFloat(proposal_dict[\"additional_amount\"])")
            js_formula = js_formula.replace("float(app_entry.usage_months)", "parseFloat(app_entry.usage_months)")
            js_formula = js_formula.replace("float(int(app_entry.customer_state == 'CA'))", "parseFloat((app_entry.customer_state == 'CA' * 1))")
            js_formula = js_formula.replace("float(int(app_entry.customer_state == 'UT'))", "parseFloat((app_entry.customer_state == 'UT' * 1))")
            js_formula = js_formula.replace("float(int(app_entry.customer_state == 'TX'))", "parseFloat((app_entry.customer_state == 'TX' * 1))")

            for character in ["A", "B", "C", "D", "E"]:
                js_formula = js_formula.replace("float(int(app_entry.tier_option == '" + character + "'))", "parseFloat((app_entry.tier_option == '" + character + "' * 1))")

            funds = Helpers.list_funds()
            for fund in funds:
                js_formula = js_formula.replace("float(int(booking.fund == '" + fund["value"] + "'))", "parseFloat((booking.fund == '" + fund["value"] + "' * 1))")

            js_formula = js_formula.replace("and", "&&").replace("or", "||").replace("not", "!")
            while "**" in js_formula:
                matches = re.search("([\d.]+)\*\*([\d.]+)", js_formula)
                js_formula = js_formula.replace(matches.group(0), "Math.pow(" + matches.group(1) + ", " + matches.group(2) + ")")

            ret_json["formula"] = js_formula

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "crunch_numbers_v2":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["items"] = []        
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)
            if not booking is None:
                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                if not proposal is None:
                    proposal.fix_additional_amount()
                    proposal_dict = json.loads(proposal.info)
                    if "panel_type" in proposal_dict.keys() and "new_panel_qty" in proposal_dict.keys() and "panel_qty_override" in proposal_dict.keys():
                        if "[[[" in proposal_dict["panel_type"]:
                            wattage = proposal_dict["panel_type"][proposal_dict["panel_type"].index("[[["):]
                            wattage = wattage.replace("[[[", "").replace("]]]", "")
                            wattage = float(wattage)

                            new_ss = wattage * float(proposal_dict["new_panel_qty"])
                            new_ss /= float(1000)
                            proposal_dict["system_size"] = str(new_ss)

                    if "cad_photo" in proposal_dict.keys() and "offset" in proposal_dict.keys() and "system_size" in proposal_dict.keys():
                        ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                        if not ol is None:
                            market_identifier = ol.parent_identifier
                            pricing_structures = Helpers.get_pricing_structures()
                            funds = Helpers.list_funds()
                            keys = ["fx_Points_Used", "fx_State_Tax_Credit", "fx_Solar_Bill_W_No_Tax_Credit", "fx_Total_System_Cost", "fx_Federal_Tax_Credit", "fx_Average_Bill_W_Utility", "fx_Bill_With_Credits_And_Rebates_Applied"]
                            if booking.fund == "pace_dividend":
                                 keys = ["fx_Points_Used", "fx_State_Tax_Credit", "fx_Dividend_Pace_Monthly_Payment", "fx_Total_System_Cost", "fx_Dividend_Pace_Financed_Amount", "fx_Dividend_Pace_Annual_Payment", "fx_Federal_Tax_Credit", "fx_Average_Bill_W_Utility"]
                            for key in keys:
                                if key == "fx_Points_Used":
                                    ret_json["items"].append({"number": Helpers.crunch(key, market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds), "formula": key.replace("fx_", "").replace("_", " ")})
                                else:
                                    ret_json["items"].append({"number": Helpers.currency_format(str(round(Helpers.crunch(key, market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds), 2))), "formula": key.replace("fx_", "").replace("_", " ")})

                            ret_json["state_tax_formula_label"] = Helpers.crunch("fx_State_Tax_Credit_Label", market_identifier, app_entry, booking, proposal_dict, pricing_structures, funds)

        ret_json["funds"] = Helpers.list_funds(True, app_entry.customer_state)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "crunch_numbers":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["items"] = []
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)
            if not booking is None:
                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                if not proposal is None:
                    proposal.fix_additional_amount()
                    proposal_dict = json.loads(proposal.info)
                    if "panel_type" in proposal_dict.keys() and "new_panel_qty" in proposal_dict.keys() and "panel_qty_override" in proposal_dict.keys():
                        if "[[[" in proposal_dict["panel_type"]:
                            wattage = proposal_dict["panel_type"][proposal_dict["panel_type"].index("[[["):]
                            wattage = wattage.replace("[[[", "").replace("]]]", "")
                            wattage = float(wattage)

                            new_ss = wattage * float(proposal_dict["new_panel_qty"])
                            new_ss /= float(1000)
                            proposal_dict["system_size"] = str(new_ss)
                    if "cad_photo" in proposal_dict.keys() and "offset" in proposal_dict.keys() and "system_size" in proposal_dict.keys():
                        formulas = Helpers.read_setting("proposal_formulas")
                        keyys = []
                        for formula in formulas.keys():
                            keyys.append("expose_to_rep_" + formula)

                        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keyys))
                        for item in kv_items:
                            f_name = item.keyy.replace("expose_to_rep_", "")
                            compiled_formula = Helpers.compile_formula(f_name)
                            if not compiled_formula is None:
                                number = Helpers.currency_format(str(round(compiled_formula["fn"](app_entry, booking, proposal_dict), 2)))
                                item = {}
                                item["number"] = number
                                item["formula"] = f_name.replace("fx_", "")

                                ret_json["items"].append(item)

        ret_json["funds"] = Helpers.list_funds(True, app_entry.customer_state)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "kk12kk":
        lst = gcs.listbucket("/npfieldapp.appspot.com/ProposalBlobs")
        items = []
        for item in lst:
            fname = item.filename
            eyetem = {}
            identifier = item.filename.split("/")[3].split("_")[0]
            eyetem["identifier"] = identifier
            eyetem["size"] = item.st_size
            if eyetem["size"] > 2550013:
                items.append(eyetem["identifier"])

        self.response.out.write(json.dumps(items))

    elif self.request.get("fn") == "kk12kk12":
        identifiers = ["02cd7d8556e906627d75bb5c81a851d24a1853b158aeb85545e27a70b4824f4236b2c8248eaab1b4f377c111ffae4dc35654248c60c94ec7af5225b151ee1664", "074ecf0511527fd3eeeabc86073c3d80522fc8409393d9ca979b1cc311d65ffaf2adadf44e301e7a4d9349806aacb1339c91bfa4020ccae535aa1df9513d262d", "080b8fffcf485819bd844a48bcf19d9bff45c7e62c29a696a0a331eaaf05f9ce6a0b134aefe2d8ba5a18fb15755de1bbc59238ee21051441f5c708457f713578", "0f9241b72500ec8e664a3af67b2c9d71a60e2582ea11926a967ba2b52db7b346949c2da9acc575b7a98474b7f0f4310a58547d574cc5d3a914f04fc154eb92cd", "12cba84fd8ae793abb7f24feb14c7ac4ad00d5233d05d87bf7d96ff58f8e6151a37f91f56d46e0260f71bfe2186c2d058fb603cb7cc20ad61c07323bd60f0667", "1d09c745ec82e2883a99c572e3dd3add4fa55b92dc3f59f54845bf59928bfe885a9afbc2c9d703c81fc70dcff4393c3ab58b671c1c19a081f0e3e11ee8551f80", "2215864c15d499c991765c81b58b8e1417b5011a114821f5f040657b37faabf605dc8f0724205a44a6771d64e364411aeb9b17009a77d5ffafcb687095e4fe9f", "28aa891e3d4c3beafa6b23e503a996ae945b50ae9c0297a594cb257bccf0b0f1d62333b2ebc9dfecf05ceb83ea16234ed24c56a4ef85c56de7e8a1ebc4f0f539", "3395625e6bc7586f66fee6c1870c41806877465f0d117e831870da3a0f2cfcd86da68b3a53851c644a31c6541e91ca4aec5000b6de45f7a12715185b72fac8eb", "37b09f3c2efa080e8805da85ef2eb76be90c7a4df42cecdf3fec4f5cf5c6809eccc3d77153e366b59aff8b700cc8dc785f56377c9647fe761f3f81f2ccd9c239", "43c673e4987d428598b877730b7a032984df2897faf1e49f3174ba4135f17d54ae0830c2e9d06b8140d51a0a07f59361b674f9fb764a6ea2fc56186874d7e869", "595cdc2a7c7ea457aab7dad4a62e18cc8b190876cb6ab41cd1e3aaed4f4446c6f670fea3dcbf62504e6b7161c7c08ab72b9778526d9976b32198206ffbb21832", "5c32b034fd4bfa2c9858ec05b75f73ae3b7fe721f8c22dd9ea6467ae2618bbaace129e9619971edd5622dc693c1322ae910ec6398e2575034a4ff46024740cef", "6c35a3b672f543823dea040df64c566c7994e12f0d6b9d2c53d5ad974066374f83304137ab3221cfd2bb52e3a0c0577f3a3ad775eb8b1edf6a8c45283c765759", "6d2da864411c488dfd2ba7a1066e4ce758276b6bceb73eca08020db7d13254fa6bdf8edbebe5f02e0934d3d6924964fc04c14fbe686b2305a86731e0d8f62e52", "701692e1f9db194dffba44686abe707775883273cb49e17935333a296a66e7d83ea87008ccfc8cc591c5a663311690c6fe2eed5ee343f286fcf6c15b4b58068e", "7034db673bea072a1638fc6f72096b0026dae67dd654ebd0f7ff470031269ffbdfbcbd55638e702cc9f2ec19de98fe5929cb1ab3bbcf21206c30e87552146d65", "72497ea3e4ae93cf31e4e12fa8798bcf522624859aedbeb280cca6a8985e2c6ed33008bc3cfa34c9f88fb50b450b04757f79c1e69a52f13b112e3c2e317f36a1", "7695d191e46935ff895c73cd32eb8bd474e4a35a436e84b3d5efa34bd945d6fc6fd487c9e29d0194e654bc3eb0222e7488613251bb1925f08d0b8fdb612d7082", "7695d191e46935ff895c73cd32eb8bd474e4a35a436e84b3d5efa34bd945d6fc6fd487c9e29d0194e654bc3eb0222e7488613251bb1925f08d0b8fdb612d7082", "7b1153b41305e46bfeeb8b823bae371e03121e0d335051ba3466f0e0d9b141fe61cd20e03c48c3a113453a42f73af66d8e64b72937b4080d3f8c391e35226f92", "7cfabd72eb903e23abf11b48611751f25f92494f8e34a8900e297a3784aaf8b2aca5f2d70dd0201f1314def30ae0947cc00734ebc67ad57da9a2cec16991a4b4", "7d327f50e08e547411987371ebb4b013114306be8c9e0d88ebaf87decdc8e704c91241863c72323d124ee5f601ad51c80883d6df714bfad11016ca12a2cad5c8", "8277ae3c7f83acbb91434032505dd87299d2f67db945a9c1458fe75aecb7da2b32b94a72dba4c03a2ba0e838ec065f542cfd571052e913e5eae394c4ce26641f", "831574f88bca787d2ff7ffbea6bfb7e043304d86d0ee6d9070a5fae9fa0acd1adc15868342a7b039d05f29bd16747c300cd3a0b6da377ad917534657c7f56a8a", "85b74e1f7d6299fb45e28e8f03049e9fc5e99f75020b455f9686af9c64bb842a16adbf4460c467bfe7fffabe32f23ce25377348d38dc3f66084b89c614d21eba", "90d97256d5da56740725a310312929c1e1eb6f8aa14aba4dec90cfcd6a37a71aec322ce83e2bd18abef47783ebacdb9400611658a9f1d252893a8b704789bcb4", "936e6532eba94d6d34e6414d1cc64253d57f91145cafab68696f970bb8240fac5c37d1ec832d15de8be37106dad16ff65356c25bd40c46ed4da2f56d14ce22d7", "9aecf2db03658287dc5bf9f5e1e291dc088478e0f97377b143fabbb6c3e2f2ab3f16d8ab0694d001206f039342d551026bee6c0d37df3b32adef64eab34e3af9", "ac668f9e8940a9554be96c0c225de467d6ad8c360860447c06371f1d8da7d3c0704693fcc9e066c31d780b811c64c02e12beb4896217d70f238467e99b702653", "ace2ed3bfea3b222db93d7b9593bc145aabbea8664fa3f3f5ca69f8d51808c042ae522235faca376b4743b900b87ef84b523a74f42d340a09c0e75f0f775d0e2", "c9b2bf9a5af822143c1c5bbfb30b5e6f660b27206f7b958566d11a224190be2d435ec766702c0fa4c435b7bb4b0e89e27fe3231dc61ed4a99e71bfbdf394938a", "d27d4e2e6568ef7c04fdb18265ddfa6542a8a9c8ce52f76be7d0df58550aaba18af1617ed74b563412b8c2b94df7a18a36da7f14eebf82fce983f4fd13234185", "d51571f14c4e8ca9574d29325cf73e54450c93a935ec00ca71d9bb36bd6454f15d31757295eb612cd5f48f31b739050571fd182ef38cafaf432426f23e854274", "da880fb0646d5b8c5877863a51bf64e98616fc6f983ab9aafd97d359fe68aff79ec523db9eef967f8d8e4dae236376afae76ef1259c33bd77e602cfccb48b3d4", "db9c4cff66f13b400ecde1c93858a63622e8b23b9ca7a478a2c3d0dfd2e13913f230e39ee9278e893fabbc9752fc4ad082770de04bf6333ae10872f7b13e1fae", "ea19075fbd66526dca4b0fbf4dbbc2c367efca6b5500e5fb83c12c29bdad79318506aceb6960a073c20e5abd879cbe2e245f0019482245c8fe324e13e3b7aa46", "f338b2f1918bda703f88b01cc9a5daa6c83e94a2e9524c03ad578856c564d8296b1b86a0b6bfba06b26d7eb6c15fc5eed1224e9c2ea72fd364a910c7df4a63b6", "ffca1cdd16ff951031ebd4e754fee1ceb24a7f8bedf098f493d12120e04c259d66582be1334fe236bbc3838c1f3ab92415c01c2a3f2880ab8c3c3d5a0100cf30"]

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(identifiers))
        for app_entry in app_entries:
            app_entry.proposal_state = 1
            app_entry.put()

    elif self.request.get("fn") == "init_counties":
        oset = 0
        if not str(self.request.get("offset")) == "":
            oset = int(self.request.get("offset"))

        app_entries = FieldApplicationEntry.query().order(FieldApplicationEntry.insert_time).fetch(1, offset=oset)
        for app_entry in app_entries:
            if not app_entry.customer_county == "n/a":
                try:
                    resp = urlfetch.fetch(
                        url="https://maps.googleapis.com/maps/api/geocode/json?address=" + app_entry.customer_postal.strip(),
                        method=urlfetch.GET,
                        deadline=30,
                        follow_redirects=True
                    )
                    info = json.loads(resp.content)
                    for item in info["results"][0]["address_components"]:
                        if item["types"][0] == "administrative_area_level_2":
                            app_entry.customer_county = item["long_name"]
                            app_entry.put()

                except:
                    oset = oset

        self.redirect("./data?fn=init_counties&offset=" + str(oset + 1))

    elif self.request.get("fn") == "init_counties_v2":
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.customer_county == 'n/a')
        self.response.out.write(str(app_entries.count()))
        now = datetime.now()
        for app_entry in app_entries:
            if (datetime.now() - now).total_seconds() > 45:
                break
            try:
                resp = urlfetch.fetch(
                            url="https://maps.googleapis.com/maps/api/geocode/json?address=" + app_entry.customer_city.strip() + "," + app_entry.customer_state,
                            method=urlfetch.GET,
                            deadline=30,
                            follow_redirects=True
                )
                info = json.loads(resp.content)
                for item in info["results"][0]["address_components"]:
                    if item["types"][0] == "administrative_area_level_2":
                        app_entry.customer_county = item["long_name"]
                        app_entry.put()

            except:
                now = now

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.customer_county == 'n/a')
        self.response.out.write("<br />" + str(app_entries.count()))

    elif self.request.get("fn") == "change_fund_exposure_to_rep":
        funds = Helpers.list_funds()
        funds.pop(0)
        funds.pop(len(funds) - 1)
        for fund in funds:
            if fund["value"] == self.request.get("fund"):
                fund = fund
                #fund[self.request.get("state") + "_exposed"] = (self.request.get("exposed") == "1")

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type="text/plain",
            options={'x-goog-meta-foo': 'foo',
                     'x-goog-meta-bar': 'bar',
                     'x-goog-acl': 'public-read'},
            retry_params=write_retry_params
        )

        gcs_file.write(json.dumps(funds))
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

    elif self.request.get("fn") == "export_payment_history_for_rep":
        from google.appengine.api import taskqueue
        vals_dict = {"identifier": self.request.get("identifier"), "start": self.request.get("start"), "end": self.request.get("end")}
        taskqueue.add(url="/tq/export_payment_history_for_rep", params=vals_dict)

    elif self.request.get("fn") == "update_rep_customer_tier":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
            if not usr is None:
                app_entry.tier_option = self.request.get("tier")
                CustomerTranscriber.transcribe(app_entry, usr, "tier_option_update")                
                app_entry.put()

    elif self.request.get("fn") == "roof_work_existing_details":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["data"] = {}
        roof_item = RoofWorkItem.first(RoofWorkItem.field_app_identifier == self.request.get("identifier"))
        if not roof_item is None:
            ret_json["data"] = json.loads(roof_item.info)            

        ret_json["proof_photo_1_exists"] = Helpers.gcs_file_exists("/Images/RoofWorkDetails/" + self.request.get("identifier") + "/proof_photo_1.jpg")
        ret_json["proof_photo_2_exists"] = Helpers.gcs_file_exists("/Images/RoofWorkDetails/" + self.request.get("identifier") + "/proof_photo_2.jpg")
        ret_json["solar_area_only_photo_exists"] = Helpers.gcs_file_exists("/Images/RoofWorkDetails/" + self.request.get("identifier") + "/solar_area_photo.jpg")
        ret_json["reroof_photo_exists"] = Helpers.gcs_file_exists("/Images/RoofWorkDetails/" + self.request.get("identifier") + "/reroof_photo.jpg")            

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "react_test_data":
        ret = {}
        ret["products"] = []
        prod_1 = {}
        prod_1["name"] = "Nokia N800 Internet Tablet"
        prod_1["price"] = "$200"
        prod_1["image"] = "https://i.ebayimg.com/images/g/MHYAAOSw8Otd5Tx3/s-l1600.jpg"

        ret["products"].append(prod_1)

        prod_2 = {}
        prod_2["name"] = "Palm Treo 650"
        prod_2["price"] = "$300"
        prod_2["image"] = "https://www.bing.com/th?id=OIP.cZj3vM75f25WzFZHl6RSKwHaLU"

        ret["products"].append(prod_2)

        self.response.headers.add_header("Access-Control-Allow-Origin", "*")
        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "docs_compile":
        self.response.content_type = "application/json"
        from google.appengine.api import taskqueue

        vals_dict = {}
        vals_dict["identifier"] = self.request.get("identifier")
        vals_dict["incentive"] = self.request.get("incentive")

        kv1 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "incentive_option_" + vals_dict["identifier"])
        if kv1 is None:
            kv1 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="incentive_option_" + vals_dict["identifier"],
                expiration=datetime(1970, 1, 1)
            )
        kv1.val = vals_dict["incentive"]
        kv1.put()

        vals_dict["utility_person"] = self.request.get("utility_person")

        kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "utility_person_" + vals_dict["identifier"])
        if kv2 is None:
            kv2 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="utility_person_" + vals_dict["identifier"],
                expiration=datetime(1970, 1, 1)
            )
        kv2.val = vals_dict["utility_person"]
        kv2.put()

        is_greensky = (str(self.request.get("is_greensky")) == "1")
        is_greensky = int(is_greensky)
        is_greensky = str(is_greensky)

        kv3 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "is_greensky_" + vals_dict["identifier"])
        if kv3 is None:
            kv3 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="is_greensky_" + vals_dict["identifier"],
                expiration=datetime(1970, 1, 1)
            )
        kv3.val=is_greensky
        kv3.put()

        if str(self.request.get("is_greensky")) == "1":
            vals_dict["is_greensky"] = "1"

            kv4 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "credit_card_number_" + vals_dict["identifier"])
            if kv4 is None:
                kv4 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="credit_card_number_" + vals_dict["identifier"],
                    expiration=datetime(1970, 1, 1)
                )
            kv4.val = self.request.get("acct_num")
            kv4.put()

            kv5 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "credit_card_expiration_month_" + vals_dict["identifier"])
            if kv5 is None:
                kv5 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="credit_card_expiration_month_" + vals_dict["identifier"],
                    expiration=datetime(1970, 1, 1)
                )
            kv5.val = self.request.get("exp_month")
            kv5.put()

            kv6 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "credit_card_expiration_year_" + vals_dict["identifier"])
            if kv6 is None:
                kv6 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="credit_card_expiration_year_" + vals_dict["identifier"],
                    expiration=datetime(1970, 1, 1)
                )
            kv6.val = self.request.get("exp_year")
            kv6.put()

            kv7 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "credit_card_cvv_num_" + vals_dict["identifier"])
            if kv7 is None:
                kv7 = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="credit_card_cvv_num_" + vals_dict["identifier"],
                    expiration=datetime(1970, 1, 1)
                )

            kv7.val = self.request.get("cvv")
            kv7.put()

            vals_dict["acct_num"] = self.request.get("acct_num")
            vals_dict["exp_year"] = self.request.get("exp_year")
            vals_dict["exp_month"] = self.request.get("exp_month")
            vals_dict["cvv"] = self.request.get("cvv")

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.customer_utility_account_number = self.request.get("u_num")
            app_entry.put()
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            amps_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "miss_amps_" + app_entry.identifier)
            if amps_kv is None:
                amps_kv = KeyValueStoreItem()
                amps_kv.identifier = Helpers.guid()
                amps_kv.keyy = "miss_amps_" + app_entry.identifier                
            
            amps_kv.expiration = Helpers.pacific_now() + timedelta(days=7)
            amps_kv.val = self.request.get("miss_amps")
            amps_kv.put()

            volts_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "miss_volts_" + app_entry.identifier)
            if volts_kv is None:
                volts_kv = KeyValueStoreItem()
                volts_kv.identifier = Helpers.guid()
                volts_kv.keyy = "miss_volts_" + app_entry.identifier
            
            volts_kv.expiration = Helpers.pacific_now() + timedelta(days=7)
            volts_kv.val = self.request.get("miss_volts")
            volts_kv.put()
            
            if not rep is None:
                ret_json = {}
                if str(self.request.get("mode")) == "legacy":
                    vals_dict["mail_to_rep"] = "1"
                    #taskqueue.add(url="/tq/dispatch_docs_v2", params=vals_dict)
                    #ret_json["success"] = True

                elif str(self.request.get("mode")) == "digital":
                    Helpers.send_email(rep.rep_email, "Docs for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), "At the following URL, you'll be able to sign docs with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ":\r\n\r\n" + "https://" + app_identity.get_application_id() + ".appspot.com/sign/" + app_entry.identifier + "\r\n\r\nBest of luck in closing the deal!")
                    nn = str(Helpers.pacific_now()).split(".")[0]
                    existing_ts_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "docs_gen_timestamp_" + app_entry.identifier)
                    if not existing_ts_kv is None:
                        existing_ts_kv.val = nn
                    else:
                        existing_ts_kv = KeyValueStoreItem(
                            identifier=Helpers.guid(),
                            keyy="docs_gen_timestamp_" + app_entry.identifier,
                            val=nn,
                            expiration=Helpers.pacific_now() + timedelta(days=7)
                        )
                    existing_ts_kv.put()


                    booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
                    if not booking is None:
                        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                        if not proposal is None:
                            proposal.fix_additional_amount()
                            proposal.fix_system_size()
                            info = json.loads(proposal.info)
                            ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                            if not ol is None:
                                market = OfficeLocation.first(OfficeLocation.identifier == ol.parent_identifier)
                                if not market is None:
                                    pricing_structures = Helpers.get_pricing_structures()

                                    friendly_fund_name = ""
                                    funds = Helpers.list_funds()
                                    for f in funds:
                                        if f["value"] == booking.fund:
                                            friendly_fund_name = f["value_friendly"]

                                    sys_cost_txt = Helpers.currency_format(Helpers.crunch("fx_Total_System_Cost", market.identifier, app_entry, booking, info, pricing_structures, funds))
                                    reduced_txt = "No"
                                    if not app_entry.tier_option in ["n/a", "A"]:
                                        if app_entry.tier_option == "B":
                                            reduced_txt = "-$50/KW"
                                        elif app_entry.tier_option == "C":
                                            reduced_txt = "-$100/KW"

                                        elif app_entry.tier_option == "D":
                                            reduced_txt = "-$150/KW"

                                        elif app_entry.tier_option == "E":
                                            reduced_txt = "-$200/KW"

                                    additional_txt = "Addtional Services: No"
                                    if "additional_amount" in info.keys():
                                        if float(info["additional_amount"]) > 0:
                                            additional_txt = "Additional Services: Yes"
                                    notification = Notification.first(Notification.action_name == "Docs Generated Notification")
                                    panel_txt = "Panels: " + str(info["panel_qty"])
                                    if "new_panel_qty" in info.keys() and "panel_qty_override" in info.keys():
                                        panel_txt = "Panels: " + str(info["new_panel_qty"]) + " (reduced from " + str(info["panel_qty"]) + ")"
                                    if not notification is None:
                                        for p in notification.notification_list:
                                            Helpers.send_email(p.email_address, "URGENT", "Urgent: Documents Requested for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " \r\nFund: " + friendly_fund_name + "\r\nPrice: " + sys_cost_txt + "\r\nReduced: " + reduced_txt + "\r\n " + additional_txt + "\r\n" + panel_txt + "\r\nCloser: " + rep.first_name.strip().title() + " " + rep.last_name.strip().title())
                    
                    ret_json["success"] = True

                self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_funding_order":
        f = GCSLockedFile("/ApplicationSettings/funding_sources_" + app_identity.get_application_id() + ".json")
        old_funds = json.loads(f.read())
        new_funds = []
        fund_name_idx_map = {}
        cnt = 0
        for fund in old_funds:
            new_funds.append({})
            fund_name_idx_map[fund["value"]] = cnt
            cnt += 1
        index_map = json.loads(self.request.get("index_map"))
        keys = index_map.keys()
        for key in keys:
            new_funds[index_map[key]] = old_funds[fund_name_idx_map[key]]

        f.write(json.dumps(new_funds), "application/json", "public-read")
        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

    elif self.request.get("fn") == "last_four":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = True
        identifier = self.request.get("identifier")
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "last_four_" + identifier)
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="last_four_" + identifier,
                expiration=datetime(1970, 1, 1)
            )
        kv.val = self.request.get("digits")
        cc = CreditCheck.first(CreditCheck.field_app_identifier == identifier)
        if not cc is None:
            l4 = cc.last_four
            if int(l4) > -1:
                if l4 == int(self.request.get("digits")):
                    ret_json = ret_json
                else:
                    ret_json["success"] = False

        if ret_json["success"]:
            kv.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_panel_type":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            info = json.loads(proposal.info)
            info["panel_type"] = self.request.get("type")
            proposal.info = json.dumps(info)
            proposal.put()

    elif self.request.get("fn") == "sign_docs":
        from google.appengine.api import taskqueue
        identifier = self.request.get("identifier")
        taskqueue.add(url="/tq/sign_docs", params={"identifier": identifier, "bundle_key": str(self.request.get("bundle_key"))})


    elif self.request.get("fn") == "docs_compile_v2":
        self.response.content_type = "application/json"
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/dispatch_docs_v2")

        vals_dict = {}
        vals_dict["identifier"] = self.request.get("identifier")
        vals_dict["incentive"] = self.request.get("incentive")
        vals_dict["utility_person"] =  self.request.get("utility_person")
        if str(self.request.get("is_greensky")) == "1":
            vals_dict["is_greensky"] = "1"
            vals_dict["acct_num"] = self.request.get("acct_num")
            vals_dict["exp_year"] = self.request.get("exp_year")
            vals_dict["exp_month"] = self.request.get("exp_month")
            vals_dict["cvv"] = self.request.get("cvv")

        taskqueue.add(url="/tq/dispatch_docs_v2", params=vals_dict)
        ret_json = {}
        ret_json["success"] = True
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "tq_test":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/email_test", params={"email": "rnirnber@gmail.com"})

    elif self.request.get("fn") == "docs_compile_test":
        import StringIO
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)
            if not booking is None:
                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                if not proposal is None:
                    buff = StringIO.StringIO()
                    test_doc = Helpers.populate_document("rmp", app_entry, booking, proposal, "", 0)
                    test_doc["doc"].write(buff)
                    buff.seek(2)
                    self.response.content_type = "application/pdf"
                    self.response.out.write(buff.getvalue())
                    buff.close()
                    for item in test_doc["data_to_close"]:
                        item.close()

    elif self.request.get("fn") == "cust_identifier_name_lookup":
        self.response.content_type = "application/json"
        ret_json = {"name": "Unknown"}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            ret_json["address"] = app_entry.customer_address
            ret_json["city"] = app_entry.customer_city
            ret_json["state"] = app_entry.customer_state
            ret_json["postal"] = app_entry.customer_postal
            ret_json["email"] = app_entry.customer_email
            ret_json["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
        else:
            app_user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
            if not app_user is None:
                ret_json["name"] = app_user.first_name.strip().title() + " " + app_user.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "flush_cp_cache":
        bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        lst = gcs.listbucket(bucket + "/CustomerProgressCache")
        for item in lst:
            try:
                gcs.delete(item.filename)
            except:
                bucket = bucket

    elif self.request.get("fn") == "seed_user_index":
        Helpers.drop_search_index("app_users")
        idx = search.Index(name="app_users")
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        for user in users:
            doc = search.Document(
                fields=[
                    search.TextField(name="first", value=user.first_name.strip()),
                    search.TextField(name="first_l", value=user.first_name.strip().lower()),
                    search.TextField(name="first_u", value=user.first_name.strip().upper()),
                    search.TextField(name="last", value=user.last_name.strip()),
                    search.TextField(name="last_l", value=user.last_name.strip().lower()),
                    search.TextField(name="last_u", value=user.last_name.strip().upper()),
                    search.TextField(name="name", value=user.first_name.strip() + " " + user.last_name.strip()),
                    search.TextField(name="email", value=user.rep_email),
                    search.TextField(name="phone", value=user.rep_phone),
                    search.TextField(name="phone_f", value=Helpers.format_phone_number(user.rep_phone)),
                    search.TextField(name="identifier", value=user.identifier),
                    search.TextField(name="rep_id", value=user.rep_id)
                ]
            )
            idx.put(doc)

    elif self.request.get("fn") == "change_user_name":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        from google.appengine.api import search
        idx = search.Index(name="app_users")
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            user.first_name = self.request.get("f").strip().title()
            user.last_name = self.request.get("l").strip().title()
            user.put()

            
            if str(self.request.get("has_license")) == "1":
                kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "l_num_" + self.request.get("identifier"))
                if kv is None:
                    kv = KeyValueStoreItem(
                        identifier=Helpers.guid(),
                        keyy="l_num_" + self.request.get("identifier"),
                        expiration=Helpers.pacific_now() + timedelta(days=730)
                    )
                kv.val = self.request.get("license_num")            
                kv.put()

            doc = search.Document(
                fields=[
                    search.TextField(name="first", value=user.first_name.strip()),
                    search.TextField(name="first_l", value=user.first_name.strip().lower()),
                    search.TextField(name="first_u", value=user.first_name.strip().upper()),
                    search.TextField(name="last", value=user.last_name.strip()),
                    search.TextField(name="last_l", value=user.last_name.strip().lower()),
                    search.TextField(name="last_u", value=user.last_name.strip().upper()),
                    search.TextField(name="name", value=user.first_name.strip() + " " + user.last_name.strip()),
                    search.TextField(name="email", value=user.rep_email),
                    search.TextField(name="phone", value=user.rep_phone),
                    search.TextField(name="phone_f", value=Helpers.format_phone_number(user.rep_phone)),
                    search.TextField(name="identifier", value=user.identifier),
                    search.TextField(name="rep_id", value=user.rep_id)
                ]
            )
            idx.put(doc)
            ret_json["success"] = True
            
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "search_users_by_name":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["users"] = []
        query = self.request.get("query").strip()
        while "  " in query:
            query = query.replace("  ", " ")

        index = search.Index(name="app_users")
        results = index.search(query)

        for result in results:
            result_item = {}
            for field in result.fields:
                result_item[field.name] = field.value
            ret_json["users"].append(result_item)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "close_reps_deal_v2":
        self.response.content_type = "application/json"
        ret_json = {"success": Helpers.gcs_file_exists("/SignedDocs/" + self.request.get("identifier") + ".pdf")}
        if ret_json["success"]:
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("user_identifier"))
            self.response.content_type = "application/json"
            packet_entry = PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == self.request.get("identifier"))
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
            if (not app_entry is None) and (not booking is None) and (app_entry.deal_closed == False):
                if packet_entry is None:
                    rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                    packet_entry = PerfectPacketEntry(
                        identifier=Helpers.guid(),
                        booking_identifier=booking.identifier,
                        field_application_identifier=app_entry.identifier,
                        surveyor_identifier=FieldApplicationUser.first(FieldApplicationUser.user_type == "survey").identifier,
                        surveyor_completion_state=1,
                        surveyor_completion_date=Helpers.pacific_now(),
                        rep_identifier=self.request.get("user_identifier"),
                        rep_completion_state=0,
                        rep_completion_date=datetime(1970, 1, 1),
                        outstanding_items=json.dumps([]),
                        created=Helpers.pacific_now(),
                        archived=False,
                        save_me=False
                    )


                packet_entry.rep_completion_state = 1
                packet_entry.rep_completion_date = Helpers.pacific_now()
                packet_entry.put()

                empty_rejection_reasons = {}
                empty_rejection_reasons["reasons"] = []
                empty_rejection_reasons["dates"] = []
                empty_rejection_reasons["responses"] = []
                empty_rejection_reasons["response_dates"] = []


                e_info = {}
                folder = ThirdPartyFolder.first(
                    ndb.AND
                    (
                        ThirdPartyFolder.field_app_identifier == app_entry.identifier,
                        ThirdPartyFolder.folder_key == "signed_docs"
                    )
                )
                if not folder is None:
                    e_info["docs_link"] = "https://drive.google.com/drive/folders/" + folder.foreign_id
                else:
                    e_info["docs_link"] = "https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/SignedDocs/" + self.request.get("identifier") + ".pdf"

                existing_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
                if existing_sub is None:
                    sarah = FieldApplicationUser.first(FieldApplicationUser.rep_email == "smcqueary@newpower.net")
                    if not sarah is None:
                        e_info["project_manager"] = sarah.identifier
                    
                    pp_submission = PerfectPacketSubmission(
                        identifier=Helpers.guid(),
                        archived=False,
                        packet_entry_identifier=packet_entry.identifier,
                        booking_identifier=packet_entry.booking_identifier,
                        field_application_identifier=packet_entry.field_application_identifier,
                        surveyor_identifier=packet_entry.surveyor_identifier,
                        rep_identifier=packet_entry.rep_identifier,
                        rep_submission_date=Helpers.pacific_now(),
                        approved=False,
                        approval_date=datetime(1970, 1, 1, 0, 0),
                        rejected=False,
                        last_rejection_date=datetime(1970, 1, 1, 0, 0),
                        rejection_reasons=json.dumps(empty_rejection_reasons),
                        save_me=False,
                        extra_info=json.dumps(e_info)
                    )
                    pp_submission.put()

                    lb_stat = LeaderBoardStat(
                        identifier=Helpers.guid(),
                        rep_id=app_entry.rep_id,
                        dt=Helpers.pacific_now(),
                        metric_key="packets_submitted",
                        office_identifier=app_entry.office_identifier,
                        field_app_identifier=app_entry.identifier,
                        in_bounds=True,
                        pin_identifier="-1"
                    )
                    if booking.fund == "dnq":
                        lb_stat.metric_key = "packets_submitted_dnq"
                    lb_stat.put()

                else:
                    #email the PM
                    existing_sub_info = json.loads(existing_sub.extra_info)
                    if "project_manager" in existing_sub_info.keys():
                        pm_to_email = FieldApplicationUser.first(FieldApplicationUser.identifier == existing_sub_info["project_manager"])
                        if not pm_to_email is None:
                            subject3 = "Deal Reclosed"
                            msg3 = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was a cancel, but the rep has now reclosed the deal."
                            Helpers.send_email(pm_to_email.rep_email, subject3, msg3)

                app_entry.deal_closed = True

                try:
                    photo_cnt = 1
                    file_content = self.request.POST.multi['req_bill_photo'].file.read()
                    path = "/Images/TitanPhotos/" + app_entry.identifier + "/bill.jpg"
        
                    f = GCSLockedFile(path)
                    f.write(file_content, "image/jpeg", "public-read")
                    f.unlock()
                    file_content = None
                except:
                    y = "y"

                cnt = 1
                while cnt < 6:
                    try:
                        file_content = self.request.POST.multi['req_panel_photo_' + str(cnt)].file.read()                    
                        path = "/Images/TitanPhotos/" + app_entry.identifier + "/panel_" + str(cnt) + ".jpg"
                        f = GCSLockedFile(path)
                        f.write(file_content, "image/jpeg", "public-read")
                        f.unlock()
                        file_content = None
                    except:
                        y2 = "y2"
                    cnt = cnt + 1

                cnt = 1
                while cnt < (int(self.request.get("roof_photo_tallly")) + 1):
                    try:
                        file_content = self.request.POST.multi['roof_panel_photo_' + str(cnt)].file.read()
                        path = "/Images/TitanPhotos/" + app_entry.identifier + "/roof_" + str(cnt) + ".jpg"
                        f = GCSLockedFile(path)
                        f.write(file_content, "image/jpeg", "public-read")
                        f.unlock()
                        file_content = None
                    except:
                        y3 = "y3"
                    cnt = cnt + 1

                one = "one"

                p1 = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == app_entry.identifier)
                if not p1 is None:
                    d1 = json.loads(p1.info)

                    orig_panel_count = float(d1["panel_qty"])
                    new_panel_count = float(d1["panel_qty"])

                    p_q = 0
                    if "panel_qty" in d1.keys():
                        p_q = int(d1["panel_qty"])
                        if "panel_qty_override" in d1.keys():
                            if d1["panel_qty_override"] == True:
                                p_q = int(d1["new_panel_qty"])
                                new_panel_count = float(d1["new_panel_qty"])
                        cnt = 0
                        p_stats_to_put = []
                        while cnt < p_q:
                            p_stat2 = LeaderBoardStat(
                                dt=Helpers.pacific_now(),
                                field_app_identifier=app_entry.identifier,
                                identifier=Helpers.guid(),
                                in_bounds=True,
                                metric_key="panels_sold",
                                office_identifier=app_entry.office_identifier,
                                pin_identifier="-1",
                                rep_id=app_entry.rep_id
                            )
                            p_stats_to_put.append(p_stat2)

                            cnt = cnt + 1

                        ndb.put_multi(p_stats_to_put)

                        send_notification =  (int(orig_panel_count) > int(new_panel_count))
                        if send_notification:
                            usr9 = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                            if not usr9 is None:
                                p_msg = usr9.first_name.strip().title() + " " + usr9.last_name.strip().title() + " closed " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s deal with reduced panels. " + str(orig_panel_count) + " was the original number, " + str(new_panel_count) + " was the closing number."
                                notification = Notification.first(Notification.action_name == "Rep Changes Panel Qty")
                                if (not notification is None) and send_notification:
                                    for person in notification.notification_list:
                                        Helpers.send_email(person.email_address, "Panel Quantity Changes", p_msg)


                if len(str(self.request.get("utility_number"))) > 4:
                    app_entry.customer_utility_account_number = self.request.get("utility_number")
                app_entry.put()

                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not rep is None:
                    msg = "Congrats! " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was closed!"
                    Helpers.send_sms(rep.rep_phone, msg)

                notification = Notification.first(Notification.action_name == "Deal Closed")
                solar_pro_msg = "(This was a self-gen)"
                panel_cnt_for_email = 0

                h_p_t5 = Helpers.pacific_today()
                start_dt5 = datetime(h_p_t5.year, h_p_t5.month, h_p_t5.day)
                while not start_dt5.isoweekday() == 7:
                    start_dt5 = start_dt5 + timedelta(days=-1)

                start_dt5 = datetime(start_dt5.year, start_dt5.month, start_dt5.day)
                end_dt5 = datetime(start_dt5.year, start_dt5.month, start_dt5.day)
                end_dt5 = end_dt5 + timedelta(seconds=-1) + timedelta(days=7)

                existing_dc_stats = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.metric_key == "panels_sold",
                        LeaderBoardStat.dt >= start_dt5,
                        LeaderBoardStat.dt <= Helpers.pacific_now(),
                    )
                )

                panel_cnt_for_email = 0
                for dc_stat in existing_dc_stats:
                    panel_cnt_for_email = panel_cnt_for_email + 1

                if not app_entry.lead_generator == "-1":
                    sp = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not sp is None:
                        solar_pro_msg = "(Deal was set by " + sp.first_name.strip().title() + " " + sp.last_name.strip().title() + ")"
                if not notification is None:
                    for person in notification.notification_list:
                        Helpers.send_email(person.email_address, ">= Deal Closed <=", "A new deal was closed for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "\r\n" + solar_pro_msg + "\r\n\r\nPanels sold tally for the week so far:\r\n" + str(panel_cnt_for_email) + ". \n\nCloser:\n" + usr.first_name.strip().title() + " " + usr.last_name.strip().title())

                if app_entry.deal_closed and (not booking is None):
                    fund_components = booking.fund.split("_")
                    if "ppa" in fund_components:
                        notification = Notification.first(Notification.action_name == "PPA Deal Closed")
                        if not notification is None:
                            for person in notification.notification_list:
                                Helpers.send_email(person.email_address, ">= PPA Deal Was Closed <=", "A PPA deal was closed for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())

                if (not app_entry.lead_generator == "-1"):
                    solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not solar_pro is None:
                        Helpers.send_sms(solar_pro.rep_phone, "Congrats! The lead you booked with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " just became a closed deal.")

                        existing_sp_transaction = MonetaryTransactionV2.first(
                            ndb.AND(
                                MonetaryTransactionV2.description_key == "cd_sp_pay",
                                MonetaryTransactionV2.field_app_identifier == app_entry.identifier
                            )
                        )
                        if existing_sp_transaction is None:
                            pending_cd = PendingCDPayment.first(PendingCDPayment.field_app_identifier == app_entry.identifier)
                            if pending_cd is None:
                                new_pending_cd = PendingCDPayment(
                                    identifier=Helpers.guid(),
                                    dt=Helpers.pacific_now(),
                                    field_app_identifier=app_entry.identifier,
                                    rep_identifier=rep.identifier,
                                    solar_pro_identifier=solar_pro.identifier
                                )
                                new_pending_cd.put()


        self.response.out.write(json.dumps(ret_json))



    elif self.request.get("fn") == "close_reps_deal":
        usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        packet_entry = PerfectPacketEntry.first(PerfectPacketEntry.field_application_identifier == self.request.get("identifier"))
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
        folder = None

        deal_closed = False

        if (not app_entry is None) and (not booking is None):
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if len(str(self.request.get("utility_number"))) > 4:
                app_entry.customer_utility_account_number = self.request.get("utility_number")
            folder = ThirdPartyFolder.first(
                ndb.AND
                (
                    ThirdPartyFolder.field_app_identifier == app_entry.identifier,
                    ThirdPartyFolder.folder_key == "signed_docs"
                )
            )
            if not folder is None:
                def save_attic_photos():
                    post_keys = self.request.POST.multi.keys()
                    potential_keys = ["attic_1", "attic_2", "attic_3", "attic_4", "attic_5"]
                    attic_photos = []
                    attic_photos_mimes = []
                    for potential_key in potential_keys:
                        attic_photos.append(None)
                        attic_photos_mimes.append(None)
                        if potential_key in post_keys:
                            attic_photos[len(attic_photos) - 1] = self.request.POST.multi[potential_key].file.read()
                            attic_photos_mimes[len(attic_photos_mimes) - 1] = self.request.POST.multi[potential_key].type

                    attic_photos_exts = []
                    for mime in attic_photos_mimes:
                        if mime is None:
                            attic_photos_exts.append(None)
                        else:
                            ext = "jpg"
                            if "png" in mime.lower():
                                ext = "png"

                            attic_photos_exts.append(ext)

                    bucket_name = os.environ.get('BUCKET_NAME',
                                     app_identity.get_default_gcs_bucket_name())
                    bucket = '/' + bucket_name
                    filename = bucket + '/AtticPhotos/' + app_entry.identifier + "/"

                    write_retry_params = gcs.RetryParams(backoff_factor=1.1)
                    attic_cnt = 0
                    parent_folder = ThirdPartyFolder.first(
                                ndb.AND
                                (
                                    ThirdPartyFolder.field_app_identifier == app_entry.identifier,
                                    ThirdPartyFolder.folder_key == "root_folder"
                                )
                    )
                    attic_folder = None

                    attic_cnt = 0
                    for photo in attic_photos:
                        if photo is None:
                            attic_cnt += 1
                            continue
                        filename2 = filename + str(attic_cnt + 1) + "." + attic_photos_exts[attic_cnt]
                        gcs_file = gcs.open(filename2,
                                        'w',
                                        content_type=attic_photos_mimes[attic_cnt],
                                        options={'x-goog-meta-foo': 'foo',
                                                 'x-goog-meta-bar': 'bar',
                                                 'x-goog-acl': 'public-read'},
                                        retry_params=write_retry_params)
                        gcs_file.write(photo)
                        gcs_file.close()


                        try:
                            if not parent_folder is None:
                                if (attic_cnt + 1) < 5:
                                    if attic_folder is None:
                                        attic_folder = Helpers.create_customer_folder_in_google_drive(app_entry, parent_folder.foreign_id, "Attic Photos", "attic_photos")
                                    Helpers.create_file_in_google_drive(attic_folder, str(attic_cnt + 1) + "." + attic_photos_exts[attic_cnt], base64.b64encode(attic_photos[attic_cnt]), attic_photos_mimes[attic_cnt])
                                else:
                                    void_folder = Helpers.create_customer_folder_in_google_drive(app_entry, parent_folder.foreign_id, "Shopping Pass", "shopping_pass")
                                    Helpers.create_file_in_google_drive(void_folder, "shopping_pass." + attic_photos_exts[attic_cnt], base64.b64encode(attic_photos[attic_cnt]), attic_photos_mimes[attic_cnt])
                        except:
                            attic_cnt = attic_cnt

                        attic_cnt += 1




                fund = booking.fund
                if not fund == "hero":
                    if not packet_entry is None:
                        app_entry.deal_closed = True
                        app_entry.put()
                        CustomerTranscriber.transcribe(app_entry, usr, "deal_closed")
                        save_attic_photos()
                        deal_closed = True
                else:
                    deal_closed = True
                    app_entry.deal_closed = True
                    app_entry.put()
                    CustomerTranscriber.transcribe(app_entry, usr, "deal_closed")
                    save_attic_photos()

                if not rep is None:
                    msg = "Congrats! " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was closed!"
                    Helpers.send_sms(rep.rep_phone, msg)

                    if packet_entry is None:

                        
                        if not rep is None:
                            packet_entry = PerfectPacketEntry(
                                identifier=Helpers.guid(),
                                booking_identifier=booking.identifier,
                                field_application_identifier=app_entry.identifier,
                                surveyor_identifier=FieldApplicationUser.first(FieldApplicationUser.user_type == "survey").identifier,
                                surveyor_completion_state=1,
                                surveyor_completion_date=Helpers.pacific_now(),
                                rep_identifier=rep.identifier,
                                rep_completion_state=0,
                                rep_completion_date=datetime(1970, 1, 1),
                                outstanding_items=json.dumps([]),
                                created=Helpers.pacific_now(),
                                archived=False,
                                save_me=False
                            )
                            packet_entry.put()

        if (not packet_entry is None) and (not folder is None):
            packet_entry.rep_completion_state = 1
            packet_entry.rep_completion_date = Helpers.pacific_now()
            packet_entry.put()

            empty_rejection_reasons = {}
            empty_rejection_reasons["reasons"] = []
            empty_rejection_reasons["dates"] = []
            empty_rejection_reasons["responses"] = []
            empty_rejection_reasons["response_dates"] = []

            e_info = {}
            e_info["docs_link"] = "https://drive.google.com/drive/folders/" + folder.foreign_id
            if len(self.request.get("closer")) == 128:
                e_info["closer"] = self.request.get("closer")

            existing_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
            if existing_sub is None:
                pp_submission = PerfectPacketSubmission(
                    identifier=Helpers.guid(),
                    archived=False,
                    packet_entry_identifier=packet_entry.identifier,
                    booking_identifier=packet_entry.booking_identifier,
                    field_application_identifier=packet_entry.field_application_identifier,
                    surveyor_identifier=packet_entry.surveyor_identifier,
                    rep_identifier=packet_entry.rep_identifier,
                    rep_submission_date=Helpers.pacific_now(),
                    approved=False,
                    approval_date=datetime(1970, 1, 1, 0, 0),
                    rejected=False,
                    last_rejection_date=datetime(1970, 1, 1, 0, 0),
                    rejection_reasons=json.dumps(empty_rejection_reasons),
                    save_me=False,
                    extra_info=json.dumps(e_info)
                )
                pp_submission.put()
                lb_stat = LeaderBoardStat(
                    identifier=Helpers.guid(),
                    rep_id=app_entry.rep_id,
                    dt=Helpers.pacific_now(),
                    metric_key="packets_submitted",
                    office_identifier=app_entry.office_identifier,
                    field_app_identifier=app_entry.identifier,
                    in_bounds=True,
                    pin_identifier="-1"
                )
                if booking.fund == "dnq":
                    lb_stat.metric_key = "packets_submitted_dnq"
                lb_stat.put()
                ret_json["success"] = True
                cc_keys = ["credit_card_number_" + pp_submission.field_application_identifier, "credit_card_expiration_month_" + pp_submission.field_application_identifier, "credit_card_expiration_year_" + pp_submission.field_application_identifier, "credit_card_cvv_num_" + pp_submission.field_application_identifier]
                cc_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(cc_keys))
                cc_item_cnt = 0
                cc_values = []

                for cc_item in cc_items:
                    cc_item_cnt += 1
                    key_vals = cc_item.keyy.split("_")
                    cc_values.append(" ".join(key_vals[0:len(key_vals) - 1]) + ": " + cc_item.val)

                if len(cc_values) == 4:
                    pp_folder = ThirdPartyFolder.first(
                        ndb.AND
                        (
                            ThirdPartyFolder.field_app_identifier == pp_submission.field_application_identifier,
                            ThirdPartyFolder.folder_key == "root_folder"
                        )
                    )
                    if not pp_folder is None:
                        b64_cc_content = base64.b64encode("\r\n".join(cc_values))
                        Helpers.create_file_in_google_drive(pp_folder.foreign_id, "shopping_pass_info.txt", b64_cc_content, "text/plain")

                notification = Notification.first(Notification.action_name == "Deal Closed")
                if not notification is None:
                    for person in notification.notification_list:
                        Helpers.send_email(person.email_address, ">= Deal Closed <=", "A new deal was closed for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())

                if deal_closed and (not booking is None):
                    fund_components = booking.fund.split("_")
                    if "ppa" in fund_components:
                        notification = Notification.first(Notification.action_name == "PPA Deal Closed")
                        if not notification is None:
                            for person in notification.notification_list:
                                Helpers.send_email(person.email_address, ">= PPA Deal Was Closed <=", "A PPA deal was closed for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())

                try:
                    app_usr = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_submission.rep_identifier)
                    if not app_usr is None:
                        Helpers.increment_tally_for_user(app_usr.rep_id, "packets_submitted")

                except:
                    logging.info("Couldn't record user submitting packet tally thingy")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_smart_assign_stats_for_office":
        self.response.content_type = "application/json"
        f = GCSLockedFile("/AutoAssignStats/" + self.request.get("identifier") + ".json")
        content = f.read()
        self.response.out.write(content)
        f.unlock()

    elif self.request.get("fn") == "get_office_for_app_entry":
        self.response.content_type = "application/json"
        ret_json = {"identifier": "-1"}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["identifier"] = app_entry.office_identifier
        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "nightly_lead_assignment_stats_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/nightly_lead_assignment_stats")

    elif self.request.get("fn") == "phix_pp_submissions":
        app_ids_to_query = ["-1"]
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_submission_date >= Helpers.pacific_now() + timedelta(days=-5))
        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            if "docs_link" in info.keys():
                app_ids_to_query.append(pp_sub.field_application_identifier)

        apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        cnt = 0
        for app in apps:
            cnt += 1
            app.deal_closed = True
            app.put()

        self.response.out.write(str(cnt))

    elif self.request.get("fn") == "get_svys":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["surveys"] = {}
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.new_survey_state == 0
            )
        )

        rep_ids_to_query = ["-1"]
        app_ids_to_query = ["-1"]
        for app_entry in app_entries:
            survey_item = {}
            survey_item["timestamp"] = app_entry.insert_time
            survey_item["identifier"] = app_entry.identifier
            survey_item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            survey_item["address"] = app_entry.customer_address
            survey_item["city"] = app_entry.customer_city
            survey_item["customer_state"] = app_entry.customer_state
            survey_item["postal"] = app_entry.customer_postal
            survey_item["rep"] = {}
            survey_item["rep"]["id"] = app_entry.rep_id


            if not app_entry.customer_state in ret_json["surveys"].keys():
                ret_json["surveys"][app_entry.customer_state] = []

            rep_ids_to_query.append(app_entry.rep_id)
            app_ids_to_query.append(app_entry.identifier)
            ret_json["surveys"][app_entry.customer_state].append(survey_item)

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for state in ret_json["surveys"].keys():
                for item in ret_json["surveys"][state]:
                    if item["rep"]["id"] == rep.rep_id:
                        item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                        item["rep"]["email"] = rep.rep_email
                        item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)
                        item["rep"]["phone"] = rep.rep_phone

        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            for state in ret_json["surveys"].keys():
                for item in ret_json["surveys"][state]:
                    if item["identifier"] == pp_sub.field_application_identifier:
                        try:
                            item["docs_link"] = json.loads(pp_sub.extra_info)["docs_link"]
                        except:
                            x = True

        cpy = {}
        for state in ret_json["surveys"].keys():
            cpy[state] = Helpers.bubble_sort(ret_json["surveys"][state], "timestamp")

        ret_json["surveys"] = cpy
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "new_survey_cancel":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                app_entry.new_survey_state = 1
                app_entry.put()
                Helpers.save_me_state(app_entry, self.request.get("reason"))

    elif self.request.get("fn") == "survey_complete_v3":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        app_entry.new_survey_state = 2
        app_entry.put()
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        docs_link = ""
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["svy_complete"] = True
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()
            if "docs_link" in info.keys():
                docs_link = info["docs_link"]

        msg_body = "PLEASE DO NOT SEND THIS EMAIL TO CUSTOMERS.  FOR INTERNAL USE ONLY.\r\n\r\n"
        msg_body += app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s survey was completed. Details Below:\r\n\r\n"
        msg_body += "Sales Rep:\r\n"
        rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
        if not rep is None:
            msg_body += rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            msg_body += "\r\n\r\n"
            msg_body += "Project Manager:\r\n"
            pp_info = json.loads(pp_sub.extra_info)
            pm_to_write = "Not Yet Assigned"
            if "project_manager" in pp_info.keys():
                pm2 = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_info["project_manager"])
                if not pm2 is None:
                    pm_to_write = pm2.first_name.strip().title() + " " + pm2.last_name.strip().title()

            msg_body += pm_to_write
            msg_body += "\r\n\r\n"

            msg_body += "Roof Condition:"
            msg_body += "\r\n"
            msg_body += self.request.get("roof_condition")
            msg_body += "\r\n\r\n"
            msg_body += "Roof Work Needed:"
            msg_body += "\r\n"
            msg_body += self.request.get("roof_work_needed")
            msg_body += "\r\n\r\n"
            msg_body += "Electrical Panel Attention Needed:"
            msg_body += "\r\n"
            msg_body += self.request.get("electrical_attention")
            msg_body += "\r\n\r\n"
            msg_body += "Fragile Roof:"
            msg_body += "\r\n"
            msg_body += self.request.get("fragile")
            msg_body += "\r\n\r\n"
            msg_body += "Dead Plate:"
            msg_body += "\r\n"
            msg_body += self.request.get("dead_plate")
            msg_body += "\r\n\r\n"
            msg_body += "Notes:"
            msg_body += "\r\n"
            msg_body += self.request.get("notes")
            msg_body += "\r\n"
            msg_body += "\r\n"
            msg_body += "Address:\r\n"
            msg_body += app_entry.customer_address
            msg_body += "\r\n"
            msg_body += app_entry.customer_city
            msg_body += ", "
            msg_body += app_entry.customer_state
            msg_body += "\r\n"
            msg_body += app_entry.customer_postal
            msg_body += "\r\n\r\n"
            msg_body += "Surveyor Name:\r\n";
            msg_body += self.request.get("surveyor_name")
            msg_body += "\r\n\r\n"
            msg_body += "Surveyor Phone:\r\n"
            msg_body += Helpers.format_phone_number(self.request.get("surveyor_phone"))
            msg_body += "\r\n"
            msg_body += "\r\n"
            msg_body += "\r\n"
            msg_body += "Docs Link:"
            msg_body += "\r\n"
            msg_body += docs_link
            

            s_details = SurveyDetails.first(SurveyDetails.field_app_identifier == self.request.get("identifier"))
            if s_details is None:
                s_details = SurveyDetails(
                    identifier=Helpers.guid(),
                    field_app_identifier=self.request.get("identifier")
                )

            data = {"roof_condition": self.request.get("roof_condition")}
            data["roof_work_needed"] = self.request.get("roof_work_needed")
            data["electrical_attention"] = self.request.get("electrical_attention")
            data["notes"] = self.request.get("notes")

            s_details.created = Helpers.pacific_now()
            s_details.info = json.dumps({"date": data})
            s_details.put()

            notification = Notification.first(Notification.action_name == "Survey Completed")
            if not notification is None:
                for person in notification.notification_list:
                    Helpers.send_email(person.email_address, "Survey Completed", msg_body)

            rep = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not rep is None:
                Helpers.send_email(rep.rep_email, "Survey Completed for your Customer", msg_body)

    elif self.request.get("fn") == "survey_complete_v2":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        app_entry.new_survey_state = 2
        app_entry.put()
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["svy_complete"] = True
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

        notification = Notification.first(Notification.action_name == "Survey Completed")
        if not notification is None:
            for person in notification.notification_list:
                Helpers.send_email(person.email_address, "Survey Completed", "The survey for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was completed.")


        from fpdf import FPDF
        ordered_keys = json.loads(self.request.get("key_ordering"))
        data = json.loads(self.request.get("data"))

        s_details = SurveyDetails.first(SurveyDetails.field_app_identifier == self.request.get("identifier"))
        if s_details is None:
            s_details = SurveyDetails(
                identifier=Helpers.guid(),
                field_app_identifier=self.request.get("identifier")
            )
        
        s_details.created = Helpers.pacific_now()
        s_details.info = json.dumps({"key_ordering": ordered_keys, "data": data})
        s_details.put()

        pdf = FPDF('P', 'in', 'Letter')
        pdf.set_auto_page_break(True, margin = 0.5)
        pdf.add_page()
        pdf.set_font('Arial', 'B', 18.0)
        pdf.set_y(0.5)
        pdf.set_x(1.0)
        pdf.cell(7.5, 0.5, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "", 0, 0, "C")
        pdf.set_y(1.1)
        pdf.set_x(0.5)
        pdf.set_font('Arial', 'I', 16)
        pdf.multi_cell(7.5, 0.25, app_entry.customer_address.strip().title() + "\n" + app_entry.customer_city.strip().title() + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal)
        pdf.ln(0.5)

        import types
        
        for key in ordered_keys:
            text_content = data[key]
            if isinstance(text_content, (list)):
                text_content = "\n".join(text_content)
            elif isinstance(text_content, (dict)):
                content = ""
                for item in text_content.keys():
                    content += (item + ": " + str(text_content[item]) + "\n")
                text_content = content[0:-1]

            split = key.split("_")
            new_split_vals = []
            for item in split:
                new_split_vals.append(item.title())
            

            pdf.set_font('Arial', 'B', 14)
            pdf.set_x(0.5)
            pdf.set_fill_color(0, 0, 0)
            pdf.set_text_color(255, 255, 255)
            pdf.multi_cell(7.5, 0.20, " ".join(new_split_vals), 1, "L", True)
            pdf.set_text_color(0, 0, 0)
            pdf.ln(0.2)
            if not text_content == "{image}":
                pdf.set_x(0.5)
                pdf.multi_cell(7.5, 0.20, text_content, 0, "L", False)
                pdf.ln(0.3)
            else:
                x = 6
                done = False
                cnt = 1
                while not done:
                    jpeg_exists = Helpers.gcs_file_exists("/SurveyDetails/" + self.request.get("identifier") + "/" + " ".join(new_split_vals) + " " + str(cnt) + ".jpg")
                    png_exists = Helpers.gcs_file_exists("/SurveyDetails/" + self.request.get("identifier") + "/" + " ".join(new_split_vals) + " " + str(cnt) + ".png")
                    if (not jpeg_exists) and (not png_exists):
                        done = True
                    else:
                        pdf.set_font('Arial', 'U', 10)
                        url = "https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/SurveyDetails/" + self.request.get("identifier") + "/" + " ".join(new_split_vals) + " " + str(cnt) + "."
                        if jpeg_exists:
                            url += "jpg"
                        elif png_exists:
                            url += "png"
                        pdf.write(0.1, "Image #" + str(cnt) + " Link", url)
                        pdf.ln(0.2)
                    cnt += 1
                pdf.ln(0.3)

        buff = StringIO.StringIO()
        buff.write(pdf.output('', 'S'))
        buff.seek(2)

        bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/SurveyDetails/' + self.request.get("identifier") + "/details.pdf"

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(filename,
                            'w',
                            content_type="text/plain"
                            ,
                            options={'x-goog-meta-foo': 'foo',
                                    'x-goog-meta-bar': 'bar',
                                    'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)
        gcs_file.write(buff.getvalue())
        gcs_file.close()
        buff.seek(2)
        b64_string = base64.b64encode(buff.getvalue())

        survey_details_folder = ThirdPartyFolder.first(
            ndb.AND(
                ThirdPartyFolder.field_app_identifier == self.request.get("identifier"),
                ThirdPartyFolder.folder_key == "survey_details"
            )
        )
        if not survey_details_folder is None:
            Helpers.create_file_in_google_drive(survey_details_folder.foreign_id, "Details.pdf", b64_string, "application/pdf")

    elif self.request.get("fn") == "new_survey_complete":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        app_entry.new_survey_state = 2
        pp_sub = None
        if self.request.get("new_layout") == "1":
            app_entry.new_survey_state = 3
            app_entry.put()
            pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
            if not pp_sub is None:
                info = json.loads(pp_sub.extra_info)
                info["svy_complete"] = True
                pp_sub.extra_info = json.dumps(info)
                rejection_reasons = json.loads(pp_sub.rejection_reasons)

                rejection_reasons["reasons"].append(["A new layout signature is required: Link: " + self.request.get("new_layout_link")])
                rejection_reasons["dates"].append(str(Helpers.pacific_now()))

                if len(rejection_reasons["reasons"]) > 0:
                    pp_sub.rejected = True
                    pp_sub.approved = False
                    pp_sub.rejection_reasons = json.dumps(rejection_reasons)
                    pp_sub.last_rejection_date = Helpers.pacific_now()

                usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "new_survey_complete_with_signature_request")
                    notification = Notification.first(Notification.action_name == "Packet Rejected")
                    if not notification is None:
                        for person in notification.notification_list:
                            Helpers.send_email(person.email_address, "Rejected Packet", "The packet for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was rejected (new layout signature requested.)")
        else:
            app_entry.put()
            pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
            if not pp_sub is None:
                info = json.loads(pp_sub.extra_info)
                info["svy_complete"] = True
                pp_sub.extra_info = json.dumps(info)

                usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not usr is None:
                    CustomerTranscriber.transcribe(app_entry, usr, "new_survey_complete")

        notification = Notification.first(Notification.action_name == "Survey Completed")
        if not notification is None:
            for person in notification.notification_list:
                Helpers.send_email(person.email_address, "Survey Completed", "The survey for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was completed.")

        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if self.request.get("roof_work_required") == "1":
                info["roof_work_required"] = "1"
                info["roof_work_details"] = self.request.get("roof_work_details")

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "update_customer_details":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        email_str = str(self.request.get("e"))
        has_email = False
        phone_str = str(self.request.get("p"))
        has_phone = False
        if (not email_str.lower() == "") and (not email_str.lower() == "none"):
            has_email = True
        if (not phone_str.lower() == "") and (not phone_str.lower() == "none"):
            has_phone = True

        if not app_entry is None:
            app_entry.customer_first_name = self.request.get("f")
            app_entry.customer_last_name = self.request.get("l")
            app_entry.customer_address = self.request.get("a")

            if has_email:
                digit_cnt = 0
                for char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]:
                    if char in self.request.get("e"):
                        digit_cnt += 1

                if digit_cnt < 10:        
                    app_entry.customer_email = self.request.get("e")

            if has_phone:
                app_entry.customer_phone = self.request.get("p")

            app_entry.put()

            booking = SurveyBooking.first(SurveyBooking.identifier == app_entry.booking_identifier)
            if not booking is None:
                booking.name = app_entry.customer_first_name + " " + app_entry.customer_last_name
                booking.address = app_entry.customer_address

                if has_email:
                    booking.email = self.request.get("e")
                if has_phone:
                    booking.phone_number = self.request.get("p")

                booking.put()

            index = search.Index(name="cust_names")
            results = index.search(app_entry.identifier)

            docs_to_delete = []

            for result in results:
                docs_to_delete = [result.doc_id]
                break

            if len(docs_to_delete) == 1:
                index.delete(docs_to_delete)

                new_doc = search.Document(
                    fields=[
                        search.TextField(name="cust_identifier", value=app_entry.identifier),
                        search.TextField(name="cust_name", value=app_entry.customer_first_name.strip() + " " + app_entry.customer_last_name.strip()),
                        search.TextField(name="cust_name_l",
                                         value=app_entry.customer_last_name.strip().lower() + " " + app_entry.customer_last_name.strip().lower()),
                        search.TextField(name="cust_name_title_case", value=app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()),
                        search.TextField(name="rep_id", value=app_entry.rep_id),
                        search.TextField(name="spouse", value=app_entry.spouse_name.strip().title())
                    ]
                )
                index.put([new_doc])

            #rename the file in google drive
            folder = ThirdPartyFolder.first(
                ndb.AND
                (
                    ThirdPartyFolder.field_app_identifier == app_entry.identifier,
                    ThirdPartyFolder.folder_key == "root_folder"
                )
            )
            if not folder is None:
                Helpers.rename_file_in_google_drive(folder.foreign_id, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())
            else:
                logging.info("not found")

            if len(str(self.request.get("l4"))) == 4:
                parsed = int(str(self.request.get("l4")))

                cc = CreditCheck.first(CreditCheck.field_app_identifier == app_entry.identifier)
                if not cc is None:
                    cc.last_four = parsed
                    cc.put()

    elif self.request.get("fn") == "phix_proposals":
        cnt = 0
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.identifier != "")
        data_to_put = []
        for proposal in proposals:
            info = json.loads(proposal.info)
            if not "additional_amount" in info.keys():
                info["additional_amount"] = "0.00"
                proposal.info = json.dumps(info)
                data_to_put.append(proposal)
                cnt += 1

        if len(data_to_put) == 1:
            data_to_put[0].put()

        elif len(data_to_put) > 1:
            ndb.put_multi(data_to_put)

        self.response.out.write(str(cnt))

    elif self.request.get("fn") == "set_additional_amount":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            info = json.loads(proposal.info)
            info["additional_amount"] = self.request.get("amount")
            proposal.info = json.dumps(info)
            proposal.put()

    elif self.request.get("fn") == "thomas_report_monday":
        may_16 = datetime(2018, 5, 16)
        july_15 = datetime(2018, 6, 15, 23, 59, 59)
        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.metric_key == "leads_acquired",
                LeaderBoardStat.dt >= may_16,
                LeaderBoardStat.dt <= july_15
            )
        )

        app_ids_to_query = ["-1"]
        for stat in stats:
            app_ids_to_query.append(stat.field_app_identifier)

        app_entries = FieldApplicationEntry.query(
            ndb.AND(
                FieldApplicationEntry.deal_closed == False,
                FieldApplicationEntry.identifier.IN(app_ids_to_query)
            )
        )
        lst = []
        for app_entry in app_entries:
            lst.append({"first_name": app_entry.customer_first_name.strip().title(), "last_name": app_entry.customer_last_name.strip().title(), "email": app_entry.customer_email, "phone": Helpers.format_phone_number(app_entry.customer_phone), "address": app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal})

        self.response.out.write(json.dumps(lst))

    elif self.request.get("fn") == "get_customers_for_panel_assessment":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []
        customers = FieldApplicationEntry.query(
            ndb.OR
            (
                    FieldApplicationEntry.new_survey_state == 2,
                    FieldApplicationEntry.new_survey_state == 4
            )
        )

        ids_to_query = ["-1"]
        identifier_idx_dict = {}
        for customer in customers:
            cust_item = {}
            cust_item["identifier"] = customer.identifier
            cust_item["name"] = customer.customer_first_name.strip().title() + " " + customer.customer_last_name.strip().title()
            cust_item["address"] = customer.customer_address.strip().title()
            cust_item["city"] = customer.customer_city
            cust_item["state"] = customer.customer_state
            cust_item["postal"] = customer.customer_postal
            cust_item["phone"] = customer.customer_phone
            cust_item["phone_formatted"] = Helpers.format_phone_number(customer.customer_phone)
            cust_item["insert_time"] = customer.insert_time
            cust_item["rep"] = {}
            cust_item["rep"]["id"] = customer.rep_id

            identifier_idx_dict[cust_item["identifier"]] = len(identifier_idx_dict.keys())
            ret_json["customers"].append(cust_item)
            ids_to_query.append(cust_item["identifier"])

        assessments = PanelAssessment.query(PanelAssessment.field_app_identifier.IN(ids_to_query))
        identifiers_to_remove = []
        for assessment in assessments:
            identifiers_to_remove.append(assessment.field_app_identifier)

        cpy = []
        for item in ret_json["customers"]:
            if not item["identifier"] in identifiers_to_remove:
                cpy.append(item)

        ret_json["customers"] = cpy


        rep_ids_to_query = ["-1"]
        for item in ret_json["customers"]:
            rep_ids_to_query.append(item["rep"]["id"])

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for item in ret_json["customers"]:
                if item["rep"]["id"] == rep.rep_id:
                    item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                    item["rep"]["phone"] = rep.rep_phone
                    item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)

        identifier_idx_dict = {}
        ids_to_query = ["-1"]
        cnt = 0
        for item in ret_json["customers"]:
            ids_to_query.append(item["identifier"])
            identifier_idx_dict[item["identifier"]] = cnt
            cnt += 1

        subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(ids_to_query))
        for sub in subs:
            ret_json["customers"][identifier_idx_dict[sub.field_application_identifier]]["docs_link"] = ""
            jaysawn = json.loads(sub.extra_info)
            if "docs_link" in jaysawn.keys():
                ret_json["customers"][identifier_idx_dict[sub.field_application_identifier]]["docs_link"] = jaysawn["docs_link"]

        ret_json["customers"] = Helpers.bubble_sort(ret_json["customers"], "insert_time")
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "submit_panel_job_info":
        existing_assessment = PanelAssessment.first(PanelAssessment.field_app_identifier == self.request.get("identifier"))
        if existing_assessment is None:
            assessment = PanelAssessment(
                identifier=Helpers.guid(),
                field_app_identifier=self.request.get("identifier"),
                completed=(self.request.get("panel_work_required") == "0")
            )
            assessment.work_type = "n/a"
            if not assessment.completed:
                assessment.work_type = self.request.get("panel_work_type")

            assessment.put()
        else:
            existing_assessment.completed = False
            existing_assessment.work_type = "n/a"
            if self.request.get("panel_work_required") == "1":
                existing_assessment.work_type = self.request.get("panel_work_type")

            existing_assessment.put()

        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        info = json.loads(pp_sub.extra_info)
        info["panel_notes"] = self.request.get("notes")
        for item in ["new_buss_ratings", "new_breaker_amps", "panel_work_required", "original_panel_work_done", "ran_conduit", "required_combiner_box", "installed_disconnect_box", "original_panel_work_done"]:
            info[item] = self.request.get(item)

        if info["required_combiner_box"] == "1":
            info["installed_combiner_box"] = self.request.get("installed_combiner_box")

        if info["panel_work_required"] == "1":
            info["panel_work_type"] = self.request.get("panel_work_type")

        if info["original_panel_work_done"] == "1":
            info["original_panel_work_type"] = self.request.get("original_panel_work_type")

        pp_sub.extra_info = json.dumps(info)
        pp_sub.put()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.new_survey_state = 7
            app_entry.put()

            usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not usr is None:
                CustomerTranscriber.transcribe(app_entry, usr, "electrical_completed")

    elif self.request.get("fn") == "roof_work_needed_v2_reject":
        new_note = CustomerNote(
            identifier=Helpers.guid(),
            field_app_identifier=self.request.get("identifier"),
            inserted_pacific=Helpers.pacific_now(),
            inserted_utc=datetime.now(),
            author=self.request.get("user_identifier"),
            perms="public",
            content=json.dumps({"txt": ["No roof work is needed. The roof is in suitable condition for installation of solar."]}),
            blob_count=0,
            note_key="panel_work",
            read=True
        )

        customer = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not customer is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == customer.rep_id)
            if not rep is None:
                pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
                if not pp_sub is None:
                    info = json.loads(pp_sub.extra_info)
                    if "project_management_specifics" in info.keys():
                        good = "good"
                    else:
                        info["project_management_specifics"] = {}
                    
                    info["project_management_specifics"]["roof_work_needed_v2"] = "0"
                    pp_sub.extra_info = json.dumps(info)
                    if "project_manager" in info.keys():              
                        pm = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                        if not pm is None:
                            recipients = [pm.rep_email, rep.rep_email]
                            sub = customer.customer_first_name.strip().title() + " " + customer.customer_last_name.strip().title() + " Roof Work Status"
                            msg = "No roof work is required for this customer..."
                            for recipient in recipients:
                                Helpers.send_email(recipient, sub, msg)

                            new_note.put()
                            pp_sub.put()

    elif self.request.get("fn") == "new_perfect_packets_screen":
        opts = Helpers.read_setting("system_options")
        opts = opts["panels"]

        self.response.content_type = "application/json"
        packets = []
        ret_json = {}

        app_identifier_pp_sub_dict = {}
        app_identifier_booking_dict = {}
        app_identifier_proposal_dict = {}
        app_identifier_address_dict = {}
        app_identifier_postal_dict = {}
        app_identifier_city_state_dict = {}
        app_identifier_customer_email_dict = {}
        app_identifier_utility_dict = {}
        app_identifier_meter_dict = {}
        app_identifier_NOC_dict = {}
        app_identifier_system_size_dict = {}
        app_identifier_notes_dict = {}
        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.approved == False,
                PerfectPacketSubmission.rejected == False
            )
        )

        identifiers_to_query = ["-1"]
        for pp_sub in pp_subs:
            identifiers_to_query.append(pp_sub.field_application_identifier)
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier] = {}
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["submission_identifier"] = pp_sub.identifier
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["app_entry_identifier"] = pp_sub.field_application_identifier
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["submission_date"] = str(pp_sub.rep_submission_date)
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["submission_dt"] = pp_sub.rep_submission_date
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["rejection_reasons"] = json.loads(pp_sub.rejection_reasons)
            app_identifier_pp_sub_dict[pp_sub.field_application_identifier]["extra_info"] = json.loads(pp_sub.extra_info)
            app_identifier_notes_dict[pp_sub.field_application_identifier] = []

        rep_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(identifiers_to_query))
        app_identifier_rep_id_dict = {}
        identifiers_to_query2 = ["-1"]
        keys_to_query = ["-1"]
        keys_to_query2 = ["-1"]
        note_identifiers_to_query = ["-1"]
        for app_entry in app_entries:
            if app_entry.new_survey_state > 0 and (not app_entry.save_me) and (not app_entry.archived):
                identifiers_to_query2.append(app_entry.identifier)
                rep_ids_to_query.append(app_entry.rep_id)
                app_identifier_rep_id_dict[app_entry.identifier] = app_entry.rep_id
                app_identifier_address_dict[app_entry.identifier] = app_entry.customer_address
                app_identifier_city_state_dict[app_entry.identifier] = app_entry.customer_city + ", " + app_entry.customer_state
                app_identifier_postal_dict[app_entry.identifier] = app_entry.customer_postal
                app_identifier_customer_email_dict[app_entry.identifier] = app_entry.customer_email
                app_identifier_utility_dict[app_entry.identifier] = app_entry.customer_utility_account_number
                keys_to_query.append("SDGE_meter_number_" + app_entry.identifier)
                keys_to_query2.append("NOC_" + app_entry.identifier)
                note_identifiers_to_query.append(app_entry.identifier)
                app_identifier_notes_dict[app_entry.identifier] = []

        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_item in kv_items:
            ident = kv_item.keyy.replace("SDGE_meter_number_", "")
            app_identifier_meter_dict[ident] = kv_item.val

        kv_items2 = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query2))
        for kv_item in kv_items2:
            ident = kv_item.keyy.replace("NOC_", "")
            app_identifier_NOC_dict[ident] = kv_item.val

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.field_app_identifier.IN(note_identifiers_to_query),
                CustomerNote.note_key.IN(["perfect_packet_note", "panel_work"])
            )
        )
        for note in notes:
            app_identifier_notes_dict[note.field_app_identifier].append(json.loads(note.content)["txt"][0])


        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(identifiers_to_query))
        for proposal in proposals:
            p_dict = json.loads(proposal.info)
            if "system_size" in p_dict.keys():
                sys_size = float(p_dict["system_size"])
            else:
                sys_size = float(0)

            panel_qty = None
            wattage = None
            panel_type = None
            if "panel_qty" in p_dict.keys():
                panel_qty = float(p_dict["panel_qty"])

            if "new_panel_qty" in p_dict.keys() and "panel_qty_override" in p_dict.keys():
                panel_qty = float(p_dict["new_panel_qty"])

            if "panel_type" in p_dict.keys():
                panel_type = p_dict["panel_type"]

            if not panel_type is None:
                if "[[[" in panel_type:
                    wattage = panel_type[panel_type.index("[[["):]
                    wattage = wattage.replace("[[[", "").replace("]]]", "")
                    wattage = float(wattage)
                else:

                    for opt in opts:
                        if opt[0:opt.index("[[[")] == panel_type:
                            wattage = opt[opt.index("[[["):]
                            wattage = wattage.replace("[[[", "").replace("]]]", "")
                            wattage = float(wattage)

            if (not wattage is None) and (not panel_qty is None):
                sys_size = wattage * panel_qty
                sys_size /= 1000

            app_identifier_proposal_dict[proposal.field_app_identifier] = p_dict
            app_identifier_system_size_dict[proposal.field_app_identifier] = str(sys_size)

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(identifiers_to_query2))
        for booking in bookings:
            app_identifier_booking_dict[booking.field_app_identifier] = {}
            app_identifier_booking_dict[booking.field_app_identifier]["survey_date"] = str(date(booking.booking_year, booking.booking_month, booking.booking_day))
            app_identifier_booking_dict[booking.field_app_identifier]["name"] = booking.name.strip()
            app_identifier_booking_dict[booking.field_app_identifier]["booking_identifier"] = booking.identifier
            app_identifier_booking_dict[booking.field_app_identifier]["fund"] = booking.fund
            app_identifier_booking_dict[booking.field_app_identifier]["phone"] = booking.phone_number

        for identifier in identifiers_to_query2:
            if not identifier == "-1":
                try:
                    packet = {}
                    packet["identifier"] = app_identifier_pp_sub_dict[identifier]["submission_identifier"]
                    packet["app_entry_identifier"] = app_identifier_pp_sub_dict[identifier]["app_entry_identifier"]
                    packet["submission_date"] = app_identifier_pp_sub_dict[identifier]["submission_date"]
                    packet["submission_dt"] = app_identifier_pp_sub_dict[identifier]["submission_dt"]
                    packet["survey_date"] = app_identifier_booking_dict[identifier]["survey_date"]
                    packet["name"] = app_identifier_booking_dict[identifier]["name"]
                    packet["booking_identifier"] = app_identifier_booking_dict[identifier]["booking_identifier"]
                    packet["fund"] = app_identifier_booking_dict[identifier]["fund"]
                    packet["rep"] = {}
                    packet["rep"]["id"] = app_identifier_rep_id_dict[packet["app_entry_identifier"]]
                    packet["rejection_reasons"] = app_identifier_pp_sub_dict[identifier]["rejection_reasons"]
                    packet["extra_info"] = app_identifier_pp_sub_dict[identifier]["extra_info"]
                    packet["customer_phone"] = app_identifier_booking_dict[identifier]["phone"]
                    packet["customer_phone_formatted"] = Helpers.format_phone_number(app_identifier_booking_dict[identifier]["phone"])
                    packet["customer_address"] = app_identifier_address_dict[packet["app_entry_identifier"]]
                    packet["customer_city_state"] = app_identifier_city_state_dict[packet["app_entry_identifier"]]
                    packet["customer_postal"] = app_identifier_postal_dict[packet["app_entry_identifier"]]
                    packet["customer_email"] = app_identifier_customer_email_dict[packet["app_entry_identifier"]]
                    packet["utility_no"] = app_identifier_utility_dict[packet["app_entry_identifier"]]
                    packet["system_size"] = app_identifier_system_size_dict[packet["app_entry_identifier"]]
                    packet["notes"] = []
                    if packet["app_entry_identifier"] in app_identifier_notes_dict.keys():
                        app_identifier_notes_dict[packet["app_entry_identifier"]]

                    packet["estimated_kwh_production"] = None
                    if packet["app_entry_identifier"] in app_identifier_proposal_dict.keys():
                        if "year_one_production" in app_identifier_proposal_dict[packet["app_entry_identifier"]].keys():
                            packet["estimated_kwh_production"] = app_identifier_proposal_dict[packet["app_entry_identifier"]]["year_one_production"]

                    packet["meter_number"] = None
                    if packet["app_entry_identifier"] in app_identifier_meter_dict.keys():
                        packet["meter_number"] = app_identifier_meter_dict[packet["app_entry_identifier"]]

                    packet["noc"] = "Unavailable"
                    if packet["app_entry_identifier"] in app_identifier_NOC_dict.keys():
                        packet["noc"] = app_identifier_NOC_dict[packet["app_entry_identifier"]]

                    packets.append(packet)

                except:
                    packet = {}

        ret_json["packets"] = Helpers.bubble_sort(packets, "submission_dt")
        for item in ret_json["packets"]:
            del item["submission_dt"]

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for item in ret_json["packets"]:
                if item["rep"]["id"] == rep.rep_id:
                    item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                    item["rep"]["phone"] = rep.rep_phone
                    item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pp_checkoff":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if self.request.get("checked") == "1":
                date_vals = self.request.get("dt").split("-")
                info[self.request.get("key")] = str(date(int(date_vals[0]), int(date_vals[1]), int(date_vals[2])))
            else:
                if self.request.get("key") in info.keys():
                    del info[self.request.get("key")]

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

            if self.request.get("key") in ["check_plan_set_requested", "check_plan_set_received", "check_stamps_received"] and self.request.get("checked") == "1":
                a_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
                if not a_entry is None:
                    usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == a_entry.rep_id)
                    if not usr is None:
                        CustomerTranscriber.transcribe(a_entry, usr, self.request.get("key").replace("check_", ""))

    elif self.request.get("fn") == "add_active_annotation":
        sources = Helpers.list_funds()
        sources.pop(0)
        sources.pop(len(sources) - 1)

        for source in sources:
            source["active"] = False

        jaysawn = json.dumps(sources)

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type="text/plain",
            options={'x-goog-meta-foo': 'foo',
                     'x-goog-meta-bar': 'bar',
                     'x-goog-acl': 'public-read'},
            retry_params=write_retry_params
        )

        gcs_file.write(jaysawn)
        gcs_file.close()

    elif self.request.get("fn") == "activate_deactivate_fund":
        sources = Helpers.list_funds()
        sources.pop(0)
        sources.pop(len(sources) - 1)

        for source in sources:
            if source["value"] == self.request.get("fund"):
                source["active"] = (self.request.get("active") == "1")

        jaysawn = json.dumps(sources)

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/funding_sources_' + app_identity.get_application_id() + '.json'

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type="text/plain",
            options={'x-goog-meta-foo': 'foo',
                     'x-goog-meta-bar': 'bar',
                     'x-goog-acl': 'public-read'},
            retry_params=write_retry_params
        )

        gcs_file.write(jaysawn)
        gcs_file.close()

        keyy = "list_of_funding_source_names"
        keyy2 = "list_of_funding_groups"
        memcache.delete(keyy)
        memcache.delete(keyy2)

    elif self.request.get("fn") == "runway_save":
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:        
            runway = Runway(
                identifier=Helpers.guid(),
                rep_identifier=self.request.get("identifier"),
                level=self.request.get("level"),
                info=self.request.get("data"),
                dt=Helpers.pacific_now()
            )
            runway.put()

            notification = Notification.first(Notification.action_name == "Runway Submissions")
            if not notification is None:
                for person in notification.notification_list:
                    Helpers.send_email(person.email_address, "Runway Submission", rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " has submitted a runway request")

    elif self.request.get("fn") == "upload_runway_doc":
        file_content = self.request.POST.multi['img'].file.read()
        path = "/Images/RunwayDocs/" + self.request.get("level") + "/" + self.request.get("identifier") + ".jpg"

        f = GCSLockedFile(path)
        f.write(file_content, "image/jpeg", "public-read")
        f.unlock()
    elif self.request.get("fn") == "upload_runway_selfie":
        file_content = self.request.POST.multi['img'].file.read()
        path = "/Images/RunwaySelfies/" + self.request.get("level") + "/" + self.request.get("identifier") + "/" + self.request.get("idx") + ".jpg"
    
        f = GCSLockedFile(path)
        f.write(file_content, "image/jpeg", "public-read")
        f.unlock()


    elif self.request.get("fn") == "approve_runway":
        runway = Runway.first(Runway.identifier == self.request.get("identifier"))
        if not runway is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == runway.rep_identifier)
            if not rep is None:
                payment_date = Helpers.get_payment_date_for_runway()
                amount = 180
                if runway.level == "level_two":
                    amount = 500
                elif runway.level == "level_three":
                    amount = 1000

            user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("user_identifier"))
            if not user is None:
                existing_trans = MonetaryTransactionV2.first(
                    ndb.AND(
                        MonetaryTransactionV2.recipient == rep.identifier,
                        MonetaryTransactionV2.description_key == "runway_" + runway.level
                    )
                )
                if existing_trans is None:
                    descrip = "Runway payment for completing " + runway.level + ". Approved by " + user.first_name.strip().title() + " " + user.last_name.strip().title() + "."
                    v2_transaction = MonetaryTransactionV2(
                        approved=True,
                        cents=0,
                        check_number=-1,
                        created=Helpers.pacific_now(),
                        denied=False,
                        description=descrip,
                        description_key="runway_" + runway.level,
                        dollars=amount,
                        extra_info="{}",
                        field_app_identifier="n/a",
                        identifier=Helpers.guid(),
                        paid=False,
                        payout_date=Helpers.get_payment_date_for_runway(),
                        recipient=runway.rep_identifier
                    )
                    docs_to_put = []
                    s_index = search.Index(name="v2_transactions")
                    v2_transaction.put()
                    docs_to_put.append(
                        search.Document(
                            fields=[
                                search.TextField(name="identifier", value=v2_transaction.identifier),
                                search.TextField(name="description", value=v2_transaction.description)
                            ]
                        )
                    )
                    s_index.put(docs_to_put)

                    Helpers.send_email(rep.rep_email, "Runway Submission Approved", "Congrats! Keep up the hard work. Your runway submission has been accepted and you will be paid $" + str(amount) + " on " + str(payment_date))
                    runway.key.delete()

                    kv = KeyValueStoreItem(
                        identifier=Helpers.guid(),
                        keyy="runway_" + runway.level + "_approval_" + rep.identifier,
                        val="1",
                        expiration=Helpers.pacific_now() + timedelta(days=90)
                    )
                    kv.put()
                else:
                    runway.key.delete()                

    elif self.request.get("fn") == "reject_runway_submission":
        runway = Runway.first(Runway.identifier == self.request.get("identifier"))
        if not runway is None:            
            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == runway.rep_identifier)
            if not rep is None:                
                subject = "Your Runway Submission Was Rejected (" + runway.level + ")"
                msg = "Please do not reply to this email. Instead, reply to the director of recruitement or speak with your manager.\r\n\r\nReason for Rejection:\r\n\r\n" + self.request.get("reason")
                Helpers.send_email(rep.rep_email, subject, msg)
                runway.key.delete()

    elif self.request.get("fn") == "get_pending_runways":
        self.response.content_type = "application/json"
        ret_json = []
        runways = Runway.query().order(Runway.dt)
        rep_ids_to_query = ["-1"]
        for runway in runways:
            obj = {"identifier": runway.identifier}
            obj["rep_identifier"] = runway.rep_identifier
            obj["level"] = runway.level
            obj["info"] = json.loads(runway.info)
            obj["dt"] = str(runway.dt).split(".")[0]
            rep_ids_to_query.append(obj["rep_identifier"])
            ret_json.append(obj)

        rep_identifier_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        for item in ret_json:
            item["rep_name"] = rep_identifier_name_dict[item["rep_identifier"]]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pm_comm_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/pm_comm_report", params={})

    elif self.request.get("fn") == "pm_email_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/pm_email", params={})

    elif self.request.get("fn") == "pm_text_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/pm_text", params={})


    elif self.request.get("fn") == "get_solar_ready_customers":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["surveys"] = {}
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.new_survey_state.IN([0, 2])
                #FieldApplicationEntry.new_survey_state.IN([0, 2, 4, 7])
            )
        )

        rep_identifiers_to_query = ["-1"]
        app_ids_to_query = ["-1"]
        app_identifier_state_dict_idx = {}
        app_identifier_state_dict = {}

        logging.info(str(time.time()))
        for app_entry in app_entries:
            if app_entry.archived or app_entry.save_me:
                continue

            survey_item = {}
            survey_item["assessment_complete"] = False
            survey_item["timestamp"] = app_entry.insert_time
            survey_item["identifier"] = app_entry.identifier
            survey_item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            survey_item["address"] = app_entry.customer_address
            survey_item["city"] = app_entry.customer_city
            survey_item["customer_state"] = app_entry.customer_state
            survey_item["customer_utility_account_number"] = app_entry.customer_utility_account_number
            survey_item["state"] = survey_item["customer_state"]
            survey_item["postal"] = app_entry.customer_postal
            survey_item["survey_complete"] = (app_entry.new_survey_state == 2  or app_entry.new_survey_state == 4)
            survey_item["rejected_packet"] = False
            survey_item["rep"] = {}
            survey_item["rep"]["id"] = app_entry.rep_id
            survey_item["new_docs_link"] = False
            survey_item["notes"] = []


            if not app_entry.customer_state in ret_json["surveys"].keys():
                ret_json["surveys"][app_entry.customer_state] = []

            if not app_entry.customer_state in app_identifier_state_dict_idx.keys():
                app_identifier_state_dict_idx[app_entry.customer_state] = {}

            app_ids_to_query.append(app_entry.identifier)
            ret_json["surveys"][app_entry.customer_state].append(survey_item)
            app_identifier_state_dict[app_entry.identifier] = app_entry.customer_state
            app_identifier_state_dict_idx[app_entry.customer_state][app_entry.identifier] = len(app_identifier_state_dict_idx[app_entry.customer_state].keys())

        logging.info(str(time.time()))
        note_ids_to_query = ["-1"]
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            try:
                stayte = app_identifier_state_dict[pp_sub.field_application_identifier]
                item_idx = app_identifier_state_dict_idx[stayte][pp_sub.field_application_identifier]
                item = ret_json["surveys"][stayte][item_idx]
                inpho = json.loads(pp_sub.extra_info)
                item["docs_link"] = inpho["docs_link"]
                item["rejected_packet"] = pp_sub.rejected
                item["survey_complete"] = ("svy_complete" in inpho.keys())
                item["verify_submitted"] = ("verify_submitted" in inpho.keys() and inpho["verify_submitted"] == "1")
                if not pp_sub.rejected:
                    cnt = 0
                    rejection_reasons = json.loads(pp_sub.rejection_reasons)
                    while cnt < len(rejection_reasons["reasons"]):
                        if item["new_docs_link"] == False:
                            cnt2 = 0
                            while cnt2 < len(rejection_reasons["reasons"][cnt]):
                                if "A new layout signature is required" in rejection_reasons["reasons"][cnt][cnt2]:
                                    item["new_docs_link"] = rejection_reasons["responses"][cnt][cnt2]
                                cnt2 += 1

                        cnt += 1

                if not item["survey_complete"] and (not item["rejected_packet"]):
                    note_ids_to_query.append(pp_sub.field_application_identifier)
                    rep_identifiers_to_query.append(pp_sub.rep_identifier)
            except:
                x = True
        logging.info(str(time.time()))
        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.field_app_identifier.IN(note_ids_to_query),
                CustomerNote.note_key == "panel_work"
            )
        )

        for note in notes:
            stayte = app_identifier_state_dict[note.field_app_identifier]
            item_idx = app_identifier_state_dict_idx[stayte][note.field_app_identifier]
            ret_json["surveys"][stayte][item_idx]["notes"].append(json.loads(note.content)["txt"][0])

        cpy2 = {}
        for state in ret_json["surveys"].keys():
            logging.info(len(ret_json["surveys"][state]))
            cpy2[state] = []
            for item in ret_json["surveys"][state]:
                if not item["survey_complete"]  and (not item["rejected_packet"]):
                    cpy2[state].append(item)

        ret_json["surveys"] = cpy2
        cpy = {}
        for state in ret_json["surveys"].keys():
            cpy[state] = Helpers.bubble_sort(ret_json["surveys"][state], "timestamp")
        ret_json["surveys"] = cpy
        
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_identifiers_to_query))
        for rep in reps:
            for state in ret_json["surveys"].keys():
                for item in ret_json["surveys"][state]:
                    if item["rep"]["id"] == rep.rep_id:
                        item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                        item["rep"]["email"] = rep.rep_email
                        item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)
                        item["rep"]["phone"] = rep.rep_phone

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "doctor":
        self.response.content_type = "application/json"
        app_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.deal_closed == True)
        found_ids = ["-1"]
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
        subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for sub in subs:
            found_ids.append(sub.field_application_identifier)

        missing_ids = []
        for item in app_ids_to_query:
            if not item in found_ids:
                missing_ids.append(item)

        self.response.out.write(json.dumps(missing_ids))

    elif self.request.get("fn") == "get_followup_details":
        self.response.content_type = "application/json"
        ret_json = {}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret_json["email"] = app_entry.customer_email
            ret_json["address"] = app_entry.customer_address
            ret_json["city"] = app_entry.customer_city
            ret_json["state"] = app_entry.customer_state
            ret_json["postal"] = app_entry.customer_postal

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_plan_set_details":
        details = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
        if not details is None:
            info = json.loads(details.data)
            info[self.request.get("key")]["value"] = self.request.get("value")
            details.data = json.dumps(info)
            details.put()

    elif self.request.get("fn") == "deactivate_plan_set":
        planset = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
        if not planset is None:
            planset.active = False
            planset.put()

    elif self.request.get("fn") == "activate_plan_set":
        planset = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
        if not planset is None:
            planset.active = True
            planset.put()

    elif self.request.get("fn") == "mark_project_management_item_as_non_applicable":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                info = info
            else:
                info["project_management_checkoffs"] = {}

            if self.request.get("key") in info["project_management_checkoffs"].keys():
                info = info
            else:
                info["project_management_checkoffs"][self.request.get("key")] = {}
                
            info["project_management_checkoffs"][self.request.get("key")]["date"] = "1800-01-01"
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "remove_project_management_checkoff_date":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if self.request.get("key") in info["project_management_checkoffs"].keys():
                    if "date" in info["project_management_checkoffs"][self.request.get("key")].keys():
                        good = True
                        if "checked" in info["project_management_checkoffs"][self.request.get("key")].keys():
                            if info["project_management_checkoffs"][self.request.get("key")]["checked"]:
                                good = False

                        if good:
                            del info["project_management_checkoffs"][self.request.get("key")]["date"]
                            pp_sub.extra_info = json.dumps(info)
                            pp_sub.put()

        event = CalendarEvent.first(
            ndb.AND(
                CalendarEvent.field_app_identifier == self.request.get("identifier"),
                CalendarEvent.event_key == self.request.get("key")
            )
        )
        if not event is None:
            old_start_dt = event.start_dt
            old_end_dt = event.end_dt

            old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
            old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)


            event.start_dt = datetime(1970, 1, 1)
            event.end_dt = datetime(1970, 1, 1)
            event.put()
            
            from google.appengine.api import taskqueue
            taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "update_one_time_event", "old_start_dt": old_start_dt_str, "old_end_dt": old_end_dt_str})

    elif self.request.get("fn") == "get_permit_design_customers_v2":
        self.response.content_type = "application/json"
        ret_json = {}
        plan_set_details = PlanSetDetails.query(PlanSetDetails.active == True)
        plan_set_details_info_dict = {}
        plan_set_details_keys_dict = {}
        app_ids_to_query = ["-1"]
        for plan_set_detail in plan_set_details:
            plan_set_details_info_dict[plan_set_detail.field_app_identifier] = json.loads(plan_set_detail.data)
            plan_set_details_keys_dict[plan_set_detail.field_app_identifier] = json.loads(plan_set_detail.key_ordering)
            app_ids_to_query.append(plan_set_detail.field_app_identifier)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.note_key == "panel_work",
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )
        app_identifier_panel_notes_dict = {}
        for note in notes:
            if not note.field_app_identifier in app_identifier_panel_notes_dict.keys():
                app_identifier_panel_notes_dict[note.field_app_identifier] = []

            app_identifier_panel_notes_dict[note.field_app_identifier].append(json.loads(note.content)["txt"][0])
        

        app_identifier_system_size_dict = {}
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        for p in proposals:
            p.fix_additional_amount()
            p.fix_system_size()
            info = json.loads(p.info)
            app_identifier_system_size_dict[p.field_app_identifier] = str(info["system_size"])

        rep_ids_to_query = ["-1"] 
        for app_entry in app_entries:
            item = {}
            item["system_size"] = app_identifier_system_size_dict[app_entry.identifier]
            item["identifier"] = app_entry.identifier
            item["timestamp"] = app_entry.insert_time
            item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["address"] = app_entry.customer_address
            item["city"] = app_entry.customer_city
            item["state"] = app_entry.customer_state
            item["customer_state"] = item["state"]
            item["customer_phone"] = app_entry.customer_phone
            item["customer_phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
            item["postal"] = app_entry.customer_postal
            item["panel_notes"] = app_identifier_panel_notes_dict[app_entry.identifier]
            item["notes"] = app_identifier_panel_notes_dict[app_entry.identifier]
            item["rep"] = {}
            item["rep"]["id"] = app_entry.rep_id
            item["customer_utility_account_number"] = app_entry.customer_utility_account_number
            item["plan_set_data"] = plan_set_details_info_dict[app_entry.identifier]
            item["key_ordering"] = plan_set_details_keys_dict[app_entry.identifier]

            rep_ids_to_query.append(app_entry.rep_id)

            if not item["state"] in ret_json.keys():
                ret_json[item["state"]] = []

            ret_json[item["state"]].append(item)

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            name = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            phone = rep.rep_phone
            phone_formatted = Helpers.format_phone_number(phone)
            email = rep.rep_email
            rep_id = rep.rep_id

            for state in ret_json.keys():
                for item in ret_json[state]:
                    if item["rep"]["id"] == rep_id:
                        item["rep"]["name"] = name
                        item["rep"]["phone"] = phone
                        item["rep"]["phone_formatted"] = phone_formatted
                        item["rep"]["email"] = email

        self.response.out.write(json.dumps(ret_json))
        
        

    elif self.request.get("fn") == "get_permit_design_customers":
        def keep_packet(p):
            info = json.loads(p.extra_info)
            keys = info.keys()
            keep = True
            if "pdesign_questions" in keys:
                if "stamps_needed" in info["pdesign_questions"]:
                    if info["pdesign_questions"]["stamps_needed"] == "1":
                        if "check_stamps_received" in keys:
                            keep = False
                    else:
                        if "check_plan_set_received" in keys:
                            keep = False

            return keep

        self.response.content_type = "application/json"
        ret_json = {}
        app_identifier_docs_link_dict = {}
        app_identifier_new_buss_ratings_dict = {}
        app_identifier_new_breaker_amps_dict = {}
        app_identifier_pdesign_questions_dict = {}
        app_identifier_submission_identifier_dict = {}
        app_identifier_panel_notes_dict = {}
        app_identifier_checkoffs_dict = {}
        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.approval_date > datetime(2016, 4, 1),
                PerfectPacketSubmission.approved == True
            )
        )
        app_ids_to_query = ["-1"]
        subs_list = []
        for pp_sub in pp_subs:
            if not keep_packet(pp_sub):
                continue

            info = json.loads(pp_sub.extra_info)
            dlink = "Unavailable"
            new_buss_ratings = "Unavailable"
            new_breaker_amps = "Unavailable"

            if "packet_approval_docs_link" in info.keys():
                dlink = info["packet_approval_docs_link"]
            if "new_buss_ratings" in info.keys():
                new_buss_ratings = info["new_buss_ratings"]

            if "new_breaker_amps" in info.keys():
                new_breaker_amps = info["new_breaker_amps"]

            app_identifier_docs_link_dict[pp_sub.field_application_identifier] = dlink
            app_identifier_new_buss_ratings_dict[pp_sub.field_application_identifier] = new_buss_ratings
            app_identifier_new_breaker_amps_dict[pp_sub.field_application_identifier] = new_breaker_amps
            app_identifier_pdesign_questions_dict[pp_sub.field_application_identifier] = []
            app_identifier_submission_identifier_dict[pp_sub.field_application_identifier] = pp_sub.identifier
            app_identifier_panel_notes_dict[pp_sub.field_application_identifier] = []

            if "pdesign_questions" in info.keys():
                app_identifier_pdesign_questions_dict[pp_sub.field_application_identifier] = info["pdesign_questions"]
            else:
                app_identifier_pdesign_questions_dict[pp_sub.field_application_identifier] = {}

            checkoffs_dict = {}
            for item in info.keys():
                if "check_" in item:
                    if item.index("check_") == 0:
                        checkoffs_dict[item] = info[item]

            app_identifier_checkoffs_dict[pp_sub.field_application_identifier] = checkoffs_dict

            subs_list.append(pp_sub)
            app_ids_to_query.append(pp_sub.field_application_identifier)

        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.save_me == False,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.identifier.IN(app_ids_to_query)
            )
        )

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.note_key == "panel_work",
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )
        for note in notes:
            app_identifier_panel_notes_dict[note.field_app_identifier].append(json.loads(note.content)["txt"][0])

        rep_ids_to_query = ["-1"]
        for app_entry in app_entries:
            item = {}
            item["identifier"] = app_entry.identifier
            item["timestamp"] = app_entry.insert_time
            item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["address"] = app_entry.customer_address
            item["city"] = app_entry.customer_city
            item["state"] = app_entry.customer_state
            item["docs_link"] = app_identifier_docs_link_dict[app_entry.identifier]
            item["new_buss_ratings"] = app_identifier_new_buss_ratings_dict[app_entry.identifier]
            item["new_breaker_amps"] = app_identifier_new_breaker_amps_dict[app_entry.identifier]
            item["customer_state"] = item["state"]
            item["customer_phone"] = app_entry.customer_phone
            item["customer_phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
            item["postal"] = app_entry.customer_postal
            item["questions"] = app_identifier_pdesign_questions_dict[app_entry.identifier]
            item["panel_notes"] = app_identifier_panel_notes_dict[app_entry.identifier]
            item["submission_identifier"] = app_identifier_submission_identifier_dict[app_entry.identifier]
            item["checkoffs"] = app_identifier_checkoffs_dict[app_entry.identifier]
            item["notes"] = app_identifier_panel_notes_dict[app_entry.identifier]
            item["rep"] = {}
            item["rep"]["id"] = app_entry.rep_id
            item["customer_utility_account_number"] = app_entry.customer_utility_account_number

            if not item["state"] in ret_json.keys():
                ret_json[item["state"]] = []

            ret_json[item["state"]].append(item)
            rep_ids_to_query.append(app_entry.rep_id)

        for item in ret_json.keys():
            ret_json[item] = Helpers.bubble_sort(ret_json[item], "timestamp")

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for item in ret_json.keys():
                for item2 in ret_json[item]:
                    if item2["rep"]["id"] == rep.rep_id:
                        item2["rep"]["email"] = rep.rep_email
                        item2["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)
                        item2["rep"]["phone"] = rep.rep_phone
                        item2["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "docs_link_v2":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if self.request.get("set") == "1":
                info["packet_approval_docs_link"] = self.request.get("link")
            else:
                if "packet_approval_docs_link" in info.keys():
                    del info["packet_approval_docs_link"]

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "jurisdiction_exists":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["exists"] = False
        jurisdictions = Helpers.read_setting("permitting_jurisdictions")
        for jurisdiction in jurisdictions:
            if jurisdiction["value"] == self.request.get("value").replace(" ", "_").lower():
                ret_json["exists"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_jurisdiction":
        jurisdictions = Helpers.read_setting("permitting_jurisdictions")
        jurisdictions.append({"value": self.request.get("jurisdiction").replace(" ", "_").lower(), "value_friendly": self.request.get("jurisdiction"), "active": True})
        Helpers.write_setting("permitting_jurisdictions", jurisdictions)

    elif self.request.get("fn") == "activate_deactivate_jurisdiction":
        jurisdictions = Helpers.read_setting("permitting_jurisdictions")
        for item in jurisdictions:
            if item["value"] == self.request.get("jurisdiction"):
                item["active"] = (self.request.get("active") == "1")

        logging.info(jurisdictions)
        Helpers.write_setting("permitting_jurisdictions", jurisdictions)

    elif self.request.get("fn") == "rename_jurisdiction":
        jurisdictions = Helpers.read_setting("permitting_jurisdictions")
        for item in jurisdictions:
            if item["value"] == self.request.get("original_value"):
                item["value_friendly"] = self.request.get('value')

        Helpers.write_setting("permitting_jurisdictions", jurisdictions)

    elif self.request.get("fn") == "update_pdesign_questions":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if not "pdesign_questions" in info.keys():
                info["pdesign_questions"] = {}
            info["pdesign_questions"][self.request.get("key")] = self.request.get("value")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "tweak_panel_qty":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.identifier == self.request.get("identifier"))
        if not proposal is None:            
            info = json.loads(proposal.info)
            orig_panel_count = float(info["panel_qty"])
            info["new_panel_qty"] = self.request.get("qty")
            info["panel_qty_override"] = True
            
            digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."]

            estimated_prod = str(info["original_year_one_production"])
            new_estimated_prod = ""
            for digit in estimated_prod:
                if digit in digits:
                    new_estimated_prod = new_estimated_prod + digit

            new_estimated_prod = float(new_estimated_prod)

            new_calculated = (float(info["original_year_one_production"]) * float(self.request.get("qty"))) / float(orig_panel_count)
            new_calculated = int(new_calculated)
            info["year_one_production"] = str(new_calculated)

            proposal.info = json.dumps(info)
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
            if not usr is None:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == proposal.field_app_identifier)
                if not app_entry is None:
                                       
                    proposal.info = json.dumps(info)
                    proposal.put()
                    proposal.fix_system_size()
                    CustomerTranscriber.transcribe(app_entry, usr, "panel_qty_update")

                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "panel_changes_" + str(Helpers.pacific_today()))
                    if kv is None:
                        kv = KeyValueStoreItem(
                            identifier=Helpers.guid(),
                            keyy="panel_changes_" + str(Helpers.pacific_today()),
                            val="[]",
                            expiration=Helpers.pacific_now() + timedelta(days=30)
                        )

                    items = json.loads(kv.val)
                    if not app_entry.identifier in items:
                        items.append(app_entry.identifier)  
                    kv.val = json.dumps(items)

                    kv.put()

                    #send_notification =  (int(orig_panel_count) > int(info["new_panel_qty"]))
                    send_notification = False
                    if send_notification:
                        p_msg = usr.first_name.strip().title() + " " + usr.last_name.strip().title() + " just changed " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s panel count from " + str(orig_panel_count) + " panels to " + str(info["new_panel_qty"]) + " panels."
                        notification = Notification.first(Notification.action_name == "Rep Changes Panel Qty")
                        if (not notification is None) and send_notification:
                            for person in notification.notification_list:
                                Helpers.send_email(person.email_address, "Panel Quantity Changes", p_msg)


    elif self.request.get("fn") == "fix_proposal_amounts":
        entities_to_put = []
        cnt = 0
        proposals = CustomerProposalInfo.query()
        for proposal in proposals:
            if cnt > 100:
                break

            save = False
            i = json.loads(proposal.info)
            if "additional_amount" in i.keys():
                if not i["additional_amount"] == "0.00":
                    i["additional_amount"] = "0.00"
                    save = True
                    cnt += 1

            if save:
                proposal.info = json.dumps(i)
                entities_to_put.append(proposal)

        if len(entities_to_put) == 1:
            entities_to_put[0].put()

        elif len(entities_to_put) > 1:
            ndb.put_multi(entities_to_put)

        self.response.out.write(str(cnt))

    elif self.request.get("fn") == "activate_deactivate_fee_schedule_item":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["active"] = (self.request.get("active") == "1")

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "service_schedule_item_per_kw":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["per_kw"] = (self.request.get("per_kw") == "1")

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "service_schedule_item_exposed_in_docs_composer":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["exposed_as_docs_composer_variable"] = (self.request.get("exposed") == "1")

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "service_schedule_item_listed_in_docs_composer":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["listed_in_docs_composer_additional_services"] = (self.request.get("listed") == "1")

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "set_price_for_fee_schedule_item":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["price"] = float(self.request.get("price"))

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "update_fee_schedule_indexes":
        index_map = json.loads(self.request.get("index_map"))
        items = Helpers.read_setting("services_schedule")
        new_items = []
        item_value_item_dict = {}
        for item in items:
            new_items.append("doof")
            item_value_item_dict[item["value"]] = item

        keys = index_map.keys()
        for key in keys:
            idx = index_map[key]
            new_items[idx] = item_value_item_dict[key]

        Helpers.write_setting("services_schedule", new_items)



    elif self.request.get("fn") == "set_points_for_fee_schedule_item":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["points"] = round(float(self.request.get("points")), 2)

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "rename_fee_schedule_item":
        items = Helpers.read_setting("services_schedule")
        for item in items:
            if item["value"] == self.request.get("item"):
                item["value_friendly"] = self.request.get("name")

        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "create_fee_schedule_item":
        items = Helpers.read_setting("services_schedule")
        items.append({"value": self.request.get("name").lower().replace(" ", "_"), "value_friendly": self.request.get("name"), "price": 1.00, "active": True, "points": 0, "per_kw": False, "exposed_as_docs_composer_variable": False, "listed_in_docs_composer_additional_services": True})
        Helpers.write_setting("services_schedule", items)

    elif self.request.get("fn") == "update_additional_services":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            info = json.loads(proposal.info)
            info["additional_svcs"] = json.loads(self.request.get("services"))
            proposal.info = json.dumps(info)
            services_list = []
            services = Helpers.read_setting("services_schedule")
            service_price_dict = {}
            service_name_dict = {}
            for svc in services:
                service_price_dict[svc["value"]] = float(svc["price"])
                service_name_dict[svc["value"]] = svc["value_friendly"]

            for s in info["additional_svcs"]:
                if s["value"] in service_price_dict.keys():
                    services_list.append({"price": service_price_dict[s["value"]], "name": service_name_dict[s["value"]]})

            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                if not usr is None:
                    msg = "Additional services were updated for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ".\n\nDetails:\n\n"
                    for item in services_list:
                        msg += item["name"] + " @ " + Helpers.currency_format(float(item["price"])) + "\n"
                    if len(services_list) > 0:
                        CustomerTranscriber.transcribe_text(app_entry.identifier, usr.identifier, msg)
                    else:
                        CustomerTranscriber.transcribe_text(app_entry.identifier, usr.identifier, "All additional services for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " were removed.")

                    proposal.put()

    elif self.request.get("fn") == "enumerate_composed_documents":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["docs"] = []
        docs = ComposedDocument.query().order(-ComposedDocument.created)
        for doc in docs:
            doc_item = {}
            for prop in ["identifier", "name", "page_count", "idx", "token", "displayed"]:
                doc_item[prop] = getattr(doc, prop)

            for prop in ["template_items", "criteria"]:
                doc_item[prop] = json.loads(getattr(doc, prop))

            if doc.bundle_key == self.request.get("bundle_key"):
                ret_json["docs"].append(doc_item)

        ret_json["docs"] = Helpers.bubble_sort(ret_json["docs"], "idx")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "docs_compose_local_upload":
        self.response.content_type = "application/json"
        ret_json = {}

        file_content = self.request.POST.multi['pdf'].file.read()

        local_id = Helpers.guid()
        ret_json["local_id"] = local_id
        bucket_name = os.environ.get('BUCKET_NAME',
                                     app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/TempDocs/' + local_id + ".pdf"

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(filename,
                            'w',
                            content_type="application/pdf",
                            options={'x-goog-meta-foo': 'foo',
                                     'x-goog-meta-bar': 'bar',
                                     'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)

        gcs_file.write(file_content)
        gcs_file.close()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "compute_engine_payload_dispatch":
        payload = json.loads(self.request.get("payload"))
        self.response.content_type = str(self.request.get("response_content_type"))
        resp_txt = Helpers.compute_engine_payload_dispatch(self.configuration["compute_engine_ip"],
                                                           8080,
                                                           payload["path"],
                                                           payload["method"],
                                                           payload["data"],
                                                           self.configuration["operation_mode"] == "PROD")
        self.response.out.write(resp_txt)

    elif self.request.get("fn") == "finalize_composed_doc":
        doc_idx = ComposedDocument.query(ComposedDocument.bundle_key == self.request.get("bundle_key")).count()
        template_items = []
        cnt = 0
        while cnt < int(self.request.get("page_count")):
            template_items.append([])
            cnt += 1

        crit = {"description": "For Avalon, CA (Catalina Island) customers", "formula": "cstPostal = '90704'"}
        if self.request.get("bundle_key") in ["rep_employment_docs", "w2_employee_docs"]:
            crit = {"description": "Unsupported User types", "formula": "usrType = 'n/a'"}
        doc = ComposedDocument(
            identifier=self.request.get("identifier"),
            token=self.request.get("token"),
            name=self.request.get("name"),
            bundle_key=self.request.get("bundle_key"),
            idx=doc_idx,
            page_count=int(self.request.get("page_count")),
            template_items = json.dumps(template_items),
            criteria=json.dumps(crit),
            displayed=True
        )
        doc.put()

        bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + "/TempDocs/" + doc.identifier + ".pdf"
        gcs.delete(filename)

    elif self.request.get("fn") == "set_meter_number":
        kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "SDGE_meter_number_" + self.request.get("identifier"))
        if kv_item is None:
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="SDGE_meter_number_" + self.request.get("identifier"),
                expiration=datetime(1970, 1, 1)
            )
        kv_item.val = self.request.get("number")
        kv_item.put()

    elif self.request.get("fn") == "users_by_user_IDs":
        self.response.content_type = "application/json"
        rep_ids = json.loads(self.request.get("user_ids"))
        rep_ids.append("-1")
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.rep_id.IN(rep_ids)
            )
        )
        ret_json = {}
        ret_json["users"] = []
        for user in users:
            ret_json["users"].append(
                {"rep_id": user.rep_id, "name": user.first_name.strip().title() + " " + user.last_name.strip().title(), "rep_email": user.rep_email}
            )

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "set_pm_rep_ids":
        rep_ids = json.loads(self.request.get("rep_ids"))
        rep_ids.append("-1")
        reps = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.rep_id.IN(rep_ids)
            )

        )

        r_ids = []
        for rep in reps:
            r_ids.append(rep.rep_id)

        Helpers.write_setting("project_managers", r_ids)

    elif self.request.get("fn") == "potential_pm":
        self.response.content_type = "application/json"
        ret_json = {}
        user = FieldApplicationUser.first(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.rep_id == self.request.get("rep_id")
            )
        )
        ret_json["success"] = (not user is None)
        if not user is None:
            ret_json["rep"] = {}
            ret_json["rep"]["rep_id"] = user.rep_id
            ret_json["rep"]["name"] = user.first_name.strip().title() + " " + user.last_name.strip().title()
            ret_json["rep"]["rep_email"] = user.rep_email

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_project_managers":
        managers = Helpers.read_setting("project_managers")
        managers.append("-1")
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["managers"] = []

        pms = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.rep_id.IN(managers)
            )
        )

        for pm in pms:
            ret_json["managers"].append({"rep_id": pm.rep_id, "name": pm.first_name.strip().title() + " " + pm.last_name.strip().title()})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "backfill_pm_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill_pm", params={})

    elif self.request.get("fn") == "assign_project_manager":
        if len(str(self.request.get("pm"))) == 128:
            pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
            if not pp_sub is None:
                info =  json.loads(pp_sub.extra_info)
                info["project_manager"] = self.request.get("pm")
                pp_sub.extra_info = json.dumps(info)
                pp_sub.put()

                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
                if not app_entry is None:
                    rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                    if not rep is None:
                        pm = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("pm"))
                        if not pm is None:
                            p_info = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == pp_sub.field_application_identifier)
                            if not p_info is None:
                                extra_msg = ""
                                decoded = json.loads(p_info.info)
                                if "panel_qty_override" in decoded.keys():                                    
                                    if decoded["panel_qty_override"] == True:
                                        original_qty = int(decoded["panel_qty"])
                                        new_qty = int(decoded["new_panel_qty"])
                                        if new_qty < original_qty:
                                            extra_msg = "\n\nThe panel quantity for this deal was lowered. The original count was " + str(original_qty) + "panels, the new panel count is " + str(new_qty) + "."

                                Helpers.send_email(pm.rep_email, "Field App Update", "You have just been assigned as the project manager for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s account. The rep is " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + ". The audio recording can be found here:\r\n\r\n" + "https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/AudioRecordings/wc/" + pp_sub.field_application_identifier + ".mp3" + extra_msg)
                                Helpers.send_sms(pm.rep_phone, "you are the project manager for " +  app_entry.customer_first_name.strip().lower() + " " + app_entry.customer_last_name.strip().lower() + ", " + rep.first_name.lower() + " " + rep.last_name.lower() + "'s customer." + extra_msg)
                                


#            if (not pp_sub is None) and (not idx == -1):
#            idx = -1
#            cnt = 0
#            for pm in pms:
#                if pm["name"] == self.request.get("name").replace("_", " "):
#                    idx = cnt
#                cnt += 1

#            pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
#            if (not pp_sub is None) and (not idx == -1):
#                info = json.loads(pp_sub.extra_info)
#                info["project_manager"] = pms[idx]
#                pp_sub.extra_info = json.dumps(info)
#                pp_sub.put()

#                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
#                if not app_entry is None:
#                    rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
#                    if not rep is None:
#                        Helpers.send_email(pms[idx]["email"], "Field App Update", "You have just been assigned as the project manager for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s account. The rep is " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + ".")
#                        Helpers.send_sms(pms[idx]["phone"], "you are the project manager for " +  app_entry.customer_first_name.strip().lower() + " " + app_entry.customer_last_name.strip().lower() + ", " + rep.first_name.lower() + " " + rep.last_name.lower() + "'s customer.")


    elif self.request.get("fn") == "unassign_project_manager":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_manager" in info.keys():
                del info["project_manager"]
                pp_sub.extra_info = json.dumps(info)
                pp_sub.put()

    elif self.request.get("fn") == "packet_HOA":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["HOA_YN"] = self.request.get("hoa")
            if info["HOA_YN"] == "1":
                info["HOA_info"] = self.request.get("hoa_info")
            else:
                if "HOA_info" in info.keys():
                    del info["HOA_info"]

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "set_installation_date_info":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["has_installation_date"] = self.request.get("install_set")
            if info["has_installation_date"] == "1":
                info["installation_date"] = self.request.get("install_date")
            else:
                if "installation_date" in info.keys():
                    del info["installation_date"]

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

            if info["has_installation_date"] and "installation_date" in info.keys():
                a_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
                if not a_entry is None:
                    usr = FieldApplicationUser.first(FieldApplicationUser.rep_id == a_entry.rep_id)
                    if not usr is None:
                        CustomerTranscriber.transcribe(a_entry, usr, "installation_date_set")

    elif self.request.get("fn") == "team_view":
        opts = Helpers.read_setting("system_options")
        opts = opts["panels"]

        def keep_packet(p):
            info = json.loads(p.extra_info)
            keys = info.keys()
            keep = False
            if "pdesign_questions" in keys:
                if "check_plan_set_received" in keys:
                    keep = True

            return keep

        self.response.content_type = "application/json"
        ret_json = {}

        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.approval_date > datetime(2016, 4, 1),
                PerfectPacketSubmission.approved == True
            )
        )

        app_ids_to_query = ["-1"]
        packet_dict = {}
        for pp_sub in pp_subs:
            if keep_packet(pp_sub):
                packet_dict[pp_sub.field_application_identifier] = pp_sub
                app_ids_to_query.append(pp_sub.field_application_identifier)

        keys_to_query = ["-1"]
        keys_to_query2 = ["-1"]
        rep_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        app_identifier_idx_dict = {}
        app_identifier_state_dict = {}
        app_identifier_idx_dict_2 = {}

        for app_entry in app_entries:
            if not app_entry.customer_state in ret_json.keys():
                ret_json[app_entry.customer_state] = []

            if not app_entry.customer_state in app_identifier_idx_dict_2.keys():
                app_identifier_idx_dict_2[app_entry.customer_state] = {}

            if not app_entry.customer_state in app_identifier_idx_dict.keys():
                app_identifier_idx_dict[app_entry.customer_state] = {}

            app_identifier_state_dict[app_entry.identifier] = app_entry.customer_state

            cust_item = {}
            cust_item["identifier"] = app_entry.identifier
            cust_item["rep"] = {}
            cust_item["rep"]["id"] = app_entry.rep_id
            cust_item["submission_identifier"] = packet_dict[app_entry.identifier].identifier
            cust_item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            cust_item["address"] = app_entry.customer_address
            cust_item["city"] = app_entry.customer_city
            cust_item["customer_state"] = app_entry.customer_state
            cust_item["postal"] = app_entry.customer_postal
            cust_item["customer_phone"] = app_entry.customer_phone
            cust_item["customer_phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
            cust_item["utility_number"] = app_entry.customer_utility_account_number
            cust_item["meter_number"] = None
            cust_item["notes"] = []
            if app_entry.utility_provider == "san_diego_gas_&_electric":
                keys_to_query.append("SDGE_meter_number_" + app_entry.identifier)

            keys_to_query2.append("NOC_" + app_entry.identifier)

            cust_item["extra_info"] = json.loads(packet_dict[app_entry.identifier].extra_info)

            cust_item["submission_identifier"] = packet_dict[app_entry.identifier].identifier
            cust_item["approval_date"] = packet_dict[app_entry.identifier].approval_date
            cust_item["NOC"] = None

            arr_len = len(app_identifier_idx_dict[app_entry.customer_state].keys())
            app_identifier_idx_dict[app_entry.customer_state][app_entry.identifier] = arr_len
            app_identifier_idx_dict_2[app_entry.customer_state][app_entry.identifier] = len(app_identifier_idx_dict_2[app_entry.customer_state].keys())
            if not app_entry.rep_id in rep_ids_to_query:
                rep_ids_to_query.append(app_entry.rep_id)

            ret_json[app_entry.customer_state].append(cust_item)

        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_item in kv_items:
            ident = kv_item.keyy.replace("SDGE_meter_number_", "")
            state = app_identifier_state_dict[ident]
            ret_json[state][app_identifier_idx_dict[state][ident]]["meter_number"] = kv_item.val

        kv_items2 = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query2))
        for kv_item in kv_items2:
            ident = kv_item.keyy.replace("NOC_", "")
            state = app_identifier_state_dict[ident]
            ret_json[state][app_identifier_idx_dict[state][ident]]["NOC"] = kv_item.val

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.note_key == "panel_work",
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )
        for note in notes:
            state = app_identifier_state_dict[note.field_app_identifier]
            idx = app_identifier_idx_dict_2[state][note.field_app_identifier]
            ret_json[state][idx]["notes"].append(json.loads(note.content)["txt"][0])

        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        for proposal in proposals:
            ident = proposal.field_app_identifier
            state = app_identifier_state_dict[ident]
            p_dict = json.loads(proposal.info)
            ret_json[state][app_identifier_idx_dict[state][ident]]["proposal"] = json.loads(proposal.info)


            if "system_size" in p_dict.keys():
                sys_size = float(p_dict["system_size"])
            else:
                sys_size = float(0)

            panel_qty = None
            wattage = None
            panel_type = None
            if "panel_qty" in p_dict.keys():
                panel_qty = float(p_dict["panel_qty"])

            if "new_panel_qty" in p_dict.keys() and "panel_qty_override" in p_dict.keys():
                panel_qty = float(p_dict["new_panel_qty"])

            if "panel_type" in p_dict.keys():
                panel_type = p_dict["panel_type"]

            if not panel_type is None:
                if "[[[" in panel_type:
                    wattage = panel_type[panel_type.index("[[["):]
                    wattage = wattage.replace("[[[", "").replace("]]]", "")
                    wattage = float(wattage)
                else:

                    for opt in opts:
                        if opt[0:opt.index("[[[")] == panel_type:
                            wattage = opt[opt.index("[[["):]
                            wattage = wattage.replace("[[[", "").replace("]]]", "")
                            wattage = float(wattage)

            if (not wattage is None) and (not panel_qty is None):
                sys_size = wattage * panel_qty
                sys_size /= 1000

            ret_json[state][app_identifier_idx_dict[state][ident]]["system_size"] = str(sys_size)

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query))
        for booking in bookings:
            ident = booking.field_app_identifier
            state = booking.state
            ret_json[state][app_identifier_idx_dict[state][ident]]["fund"] = booking.fund


        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            for state in ret_json.keys():
                for item in ret_json[state]:
                    if item["rep"]["id"] == rep.rep_id:
                        item["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                        item["rep"]["phone"] = rep.rep_phone
                        item["rep"]["phone_formatted"] = Helpers.format_phone_number(rep.rep_phone)

        cpy = {}
        for state in ret_json.keys():
            cpy[state] = Helpers.bubble_sort(ret_json[state], "approval_date")
            for item in cpy[state]:
                item["approval_date"] = str(item["approval_date"])

        ret_json = cpy
        self.response.out.write(json.dumps(cpy))

    elif self.request.get("fn") == "query_incomplete_proposals":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.proposal_state == 0,
                FieldApplicationEntry.insert_time > 1454313600000
            )
        )
        app_identifier_name_dict = {}
        keys_to_query = ["-1"]
        for app_entry in app_entries:
            keys_to_query.append("proposal_incomplete_" + app_entry.identifier)
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        kv_items = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        for kv_item in kv_items:
            result = {}
            result["reason"] = kv_item.val
            result["identifier"] = kv_item.keyy.replace("proposal_incomplete_", "")
            result["name"] = app_identifier_name_dict[result["identifier"]]

            ret_json["results"].append(result)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_electrician":
        electricians = Helpers.read_setting("electricians")
        electricians.append({"name": self.request.get("name"), "email": self.request.get("email"), "phone": self.request.get("phone")})
        Helpers.write_setting("electricians", electricians)

    elif self.request.get("fn") == "drop_electrician":
        electricians = Helpers.read_setting("electricians")
        try:
            del electricians[int(self.request.get("idx"))]
            Helpers.write_setting("electricians", electricians)
        except:
            electricians = electricians

    elif self.request.get("fn") == "add_project_manager":
        pms = Helpers.read_setting("project_managers")
        pms.append({"name": self.request.get("name"), "email": self.request.get("email"), "phone": self.request.get("phone")})
        Helpers.write_setting("project_managers", pms)

    elif self.request.get("fn") == "drop_project_manager":
        pms = Helpers.read_setting("project_managers")
        try:
            del pms[int(self.request.get("idx"))]
            Helpers.write_setting("project_managers", pms)
        except:
            pms = pms

    elif self.request.get("fn") == "add_template_item":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            new_item = {}
            new_item["x"] = 0
            new_item["y"] = 0
            new_item["width"] = 400
            new_item["height"] = 50
            new_item["identifier"] = Helpers.guid()
            new_item["font_size"] = 12
            new_item["font_family"] = "Times"
            new_item["text_align"] = "left"
            new_item["color"] = "#000000"
            new_item["value"] = self.request.get("value")
            new_item["value_friendly"] = self.request.get("value_friendly")
            new_item["format"] = "plain_text"
            t_items[int(self.request.get("idx"))].append(new_item)

            if new_item["value"] == "customer_signature":
                new_item["width"] = 350
                new_item["height"] = 150

            if new_item["value"] == "customer_initials":
                new_item["width"] = 50
                new_item["height"] = 50

            doc.template_items = json.dumps(t_items)
            doc.put()

            self.response.content_type = "application/json"
            self.response.out.write(json.dumps(new_item))

    elif self.request.get("fn") == "update_template_item_x":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["x"] = int(self.request.get("x"))

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_y":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["y"] = int(self.request.get("y"))

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_x_y":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["y"] = int(self.request.get("y"))
                    t_items[idx][cnt]["x"] = int(self.request.get("x"))
                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_width":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["width"] = int(self.request.get("width"))

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_height":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["height"] = int(self.request.get("height"))

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_font_size":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["font_size"] = int(self.request.get("font_size"))

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "remove_template_item":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            idx2 = int(self.request.get("index2"))
            del t_items[idx][idx2]
            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "rename_doc":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            doc.name = self.request.get("name")
            doc.put()

    elif self.request.get("fn") == "update_template_item_font_family":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["font_family"] = self.request.get("font_family")

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_text_alignment":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["text_align"] = self.request.get("align")

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_color":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["color"] = self.request.get("color")

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_template_item_format":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            t_items = json.loads(doc.template_items)
            idx = int(self.request.get("index"))
            cnt = 0
            item_id = self.request.get("item_identifier")
            while cnt < len(t_items[idx]):
                if t_items[idx][cnt]["identifier"] == item_id:
                    t_items[idx][cnt]["format"] = self.request.get("format")

                cnt += 1

            doc.template_items = json.dumps(t_items)
            doc.put()

    elif self.request.get("fn") == "update_doc_indexes":
        docs = []
        indexes = json.loads(self.request.get("order"))
        try:
            for doc in ComposedDocument.query(ComposedDocument.bundle_key == self.request.get("bundle")):
                doc.idx = indexes.index(doc.identifier)
                docs.append(doc)

            if len(docs) > 1:
                ndb.put_multi(docs)
            elif len(docs) == 1:
                docs[0].put()
        except:
            x = 25

    elif self.request.get("fn") == "drop_doc":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            doc.key.delete()

    elif self.request.get("fn") == "update_doc_criteria":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            doc.criteria = self.request.get("criteria")
            doc.put()

    elif self.request.get("fn") == "leads_export":
        self.response.content_type = "text/plain"
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id.IN(["AVIL1022", "COVI0311", "MILL0518"]))
        booking_ids_to_query = ["-1"]
        items = []
        app_identifier_items_idx_dict = {}
        for app_entry in app_entries:
            item = {}
            item["Rep ID"] = app_entry.rep_id
            item["Name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["Address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            item["Phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            item["Email Address"] = app_entry.customer_email
            item["insert_time"] = app_entry.insert_time
            item["Fund"] = None
            app_identifier_items_idx_dict[app_entry.identifier] = len(items)
            booking_ids_to_query.append(app_entry.booking_identifier)
            items.append(item)

        bookings = SurveyBooking.query(SurveyBooking.identifier.IN(booking_ids_to_query))
        for booking in bookings:
            identifier = booking.field_app_identifier
            items[app_identifier_items_idx_dict[identifier]]["Fund"] = booking.fund

        cpy = []
        for item in items:
            if not item["Fund"] is None:
                cpy.append(item)

        cpy = Helpers.bubble_sort(cpy, "insert_time")
        for item in cpy:
            del item["insert_time"]

        self.response.out.write(json.dumps(cpy))

    elif self.request.get("fn") == "save_customer_signature":
        from io import BytesIO
        import StringIO
        sig = self.request.get("sig")
        if "," in sig:
            b64 = sig[sig.index(",") + 1:]
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_signature_" + self.request.get("identifier"))
            if kv_item is None:
                kv_item = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="customer_signature_" + self.request.get("identifier"),
                    expiration=datetime(1970, 1, 1)
                )
            kv_item.val = b64
            kv_item.put()

            # store the baseline price
            pricing_structures = Helpers.get_pricing_structures()
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                office_location = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
                if not office_location is None:                    
                    market = OfficeLocation.first(OfficeLocation.identifier == office_location.parent_identifier)
                    if not market is None:                        
                        if market.identifier in pricing_structures.keys():
                            if "baseline_price" in pricing_structures[market.identifier].keys():
                                app_entry.baseline_price = float(pricing_structures[market.identifier]["baseline_price"])
                                app_entry.put()

    elif self.request.get("fn") == "save_cosigner_signature":
        from io import BytesIO
        import StringIO
        sig = self.request.get("sig")
        if "," in sig:
            b64 = sig[sig.index(",") + 1:]
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "cosigner_signature_" + self.request.get("identifier"))
            if kv_item is None:
                kv_item = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="cosigner_signature_" + self.request.get("identifier"),
                    expiration=datetime(1970, 1, 1)
                )
            kv_item.val = b64
            kv_item.put()


    elif self.request.get("fn") == "my_deal_cancels":
        self.response.content_type = "application/json"
        ret_json = []
        now = int(time.time() * 1000)
        now -= (1000 * 60 * 60 * 24 * 90)

        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            app_identifier_name_dict = {}
            app_ids_to_query = ["-1"]
            app_entries = FieldApplicationEntry.query(FieldApplicationEntry.insert_time >= now)
            for app_entry in app_entries:
                if app_entry.deal_closed:
                    if app_entry.archived:
                        if "solar_pro" in user.user_type:
                            if app_entry.lead_generator == user.identifier:
                                app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                                app_ids_to_query.append(app_entry.identifier)
                        elif user.rep_id == app_entry.rep_id:
                            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                            app_ids_to_query.append(app_entry.identifier)

        keepers = []
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            keep = True
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "received_pto" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["received_pto"].keys():
                        if info["project_management_checkoffs"]["received_pto"]["checked"]:
                            keep = False

            if keep:
                keepers.append(pp_sub.field_application_identifier)

        for keeper in keepers:
            obj = {"name": app_identifier_name_dict[keeper]}
            obj["date"] = None
            ret_json.append(obj)


        ret_json.reverse()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "recent_installs":
        self.response.content_type = "application/json"
        ret_json = []
        
        app_entries = []
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            if "solar_pro" in user.user_type:
                app_entries = FieldApplicationEntry.query(
                    ndb.AND(
                        FieldApplicationEntry.archived == False,
                        FieldApplicationEntry.save_me == False,
                        FieldApplicationEntry.lead_generator == user.identifier
                    )
                )
            else:
                app_entries = FieldApplicationEntry.query(
                    ndb.AND(
                        FieldApplicationEntry.archived == False,
                        FieldApplicationEntry.save_me == False,
                        FieldApplicationEntry.rep_id == user.rep_id
                    )
                )

        app_ids_to_query = ["-1"]
        app_identifier_name_dict = {}
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        h_p_n = Helpers.pacific_now()
        ninety_days_ago = h_p_n + timedelta(days=-90)
        ninety_days_ago = date(ninety_days_ago.year, ninety_days_ago.month, ninety_days_ago.day)
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "date" in info["project_management_checkoffs"]["install"].keys():
                            if "checked" in info["project_management_checkoffs"]["install"].keys():
                                if info["project_management_checkoffs"]["install"]["checked"]:
                                    dt_vals = info["project_management_checkoffs"]["install"]["date"].split("-")
                                    dt = date(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                                    if dt > ninety_days_ago:
                                        obj = {"name": app_identifier_name_dict[pp_sub.field_application_identifier]}
                                        obj["date"] = info["project_management_checkoffs"]["install"]["date"]
                                        ret_json.append(obj)

        
        ret_json = Helpers.bubble_sort(ret_json, "date")
        ret_json.reverse()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "solar_pro_install_schedule":
        today = Helpers.pacific_today()
        self.response.content_type = "application/json"
        ret_json = []
        app_entries = []
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            if "solar_pro" in user.user_type: 
                app_entries = FieldApplicationEntry.query(
                    ndb.AND(
                        FieldApplicationEntry.deal_closed == True,
                        FieldApplicationEntry.archived == False,
                        FieldApplicationEntry.save_me == False,
                        FieldApplicationEntry.lead_generator == self.request.get("identifier")
                    )
                )
            else:
                app_entries = FieldApplicationEntry.query(
                    ndb.AND(
                        FieldApplicationEntry.deal_closed == True,
                        FieldApplicationEntry.archived == False,
                        FieldApplicationEntry.save_me == False,
                        FieldApplicationEntry.rep_id == user.rep_id
                    )
                )

            app_identifier_name_dict = {}
            app_ids_to_query = ["-1"]
            for app_entry in app_entries:
                app_ids_to_query.append(app_entry.identifier)
                app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

            pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
            for pp_sub in pp_subs:
                obj = {"name": app_identifier_name_dict[pp_sub.field_application_identifier]}
                obj["date"] = "1970-01-01"
                info = json.loads(pp_sub.extra_info)
                if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "date" in info["project_management_checkoffs"]["install"].keys():
                            obj["date"] = info["project_management_checkoffs"]["install"]["date"]

                append = True
                if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "checked" in info["project_management_checkoffs"]["install"].keys():
                            if  info["project_management_checkoffs"]["install"]["checked"]:
                                append = False

                if append:
                    dt_vals = obj["date"].split("-")
                    dt = date(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                    if dt < today:
                        append = False

                if append:
                    ret_json.append(obj)

        ret_json = Helpers.bubble_sort(ret_json, "date")
        ret_json.reverse()
        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "save_employee_signature":
        from io import BytesIO
        import StringIO
        sig = self.request.get("sig")
        if "," in sig:
            b64 = sig[sig.index(",") + 1:]
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "pending_user_signature_" + self.request.get("identifier"))
            if kv_item is None:
                kv_item = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="pending_user_signature_" + self.request.get("identifier"),
                    expiration=Helpers.pacific_now() + timedelta(days=7)
                )
            kv_item.val = b64
            kv_item.put()

    elif self.request.get("fn") == "save_customer_initials":
        from io import BytesIO
        import StringIO
        sig = self.request.get("sig")
        if "," in sig:
            b64 = sig[sig.index(",") + 1:]
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_initials_" + self.request.get("identifier"))
            if kv_item is None:
                kv_item = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="customer_initials_" + self.request.get("identifier"),
                    expiration=datetime(1970, 1, 1)
                )
            kv_item.val = b64
            kv_item.put()

    elif self.request.get("fn") == "save_cosigner_initials":
        from io import BytesIO
        import StringIO
        sig = self.request.get("sig")
        if "," in sig:
            b64 = sig[sig.index(",") + 1:]
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "cosigner_initials_" + self.request.get("identifier"))
            if kv_item is None:
                kv_item = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="cosigner_initials_" + self.request.get("identifier"),
                    expiration=datetime(1970, 1, 1)
                )
            kv_item.val = b64
            kv_item.put()

    elif self.request.get("fn") == "drive_list_v2":
        from httplib2 import Http
        from oauth2client.service_account import ServiceAccountCredentials
        from apiclient.discovery import build
        from apiclient.http import MediaIoBaseUpload

        scopes = ['https://www.googleapis.com/auth/drive']

        credentials = ServiceAccountCredentials.from_json_keyfile_name(
            'FieldApp Drive Integration-167daf548a32.json', scopes)

        drive = build('drive', 'v2', credentials=credentials)
        #filez = drive.files().


    elif self.request.get("fn") == "drive_oauth":
        logging.info(self.request.__dict__)

    elif self.request.get("fn") == "drive_refresh_test":
        import json

        import StringIO
        import httplib2
        from oauth2client.service_account import ServiceAccountCredentials
        from apiclient.discovery import build
        from apiclient.http import MediaIoBaseUpload

        from oauth2client import client



        from oauth2client.client import OAuth2WebServerFlow
        from oauth2client.client import OAuth2Credentials
        from oauth2client import GOOGLE_AUTH_URI
        from oauth2client import GOOGLE_REVOKE_URI
        from oauth2client import GOOGLE_TOKEN_URI

        REFRESH_TOKEN = "1/8Vb04HoTM7ootTe3G-tcJ_TKuXo31HGOG6r4ui343_0"
        CLIENT_ID = "7243489703-7h4g1esc4i2oqcgngbb8gvnqdlcorl6u.apps.googleusercontent.com"
        CLIENT_SECRET = '83QmOX_Pl6EAlDVJz8z9ws0-'

        OAUTH_SCOPE = ['https://www.googleapis.com/auth/drive']

        REDIRECT_URI = 'https://' + app_identity.get_application_id() + '/data?fn=drive_oauth'

        credentials = OAuth2Credentials(None, CLIENT_ID,
                               CLIENT_SECRET, REFRESH_TOKEN, None,
                               GOOGLE_TOKEN_URI, None,
                               revoke_uri=GOOGLE_REVOKE_URI,
                               id_token=None,
                               token_response=None)
        http = httplib2.Http()
        http_auth = credentials.authorize(http)
        drive = build('drive', 'v2', http=http_auth)


        io_buff = StringIO.StringIO(base64.b64decode("iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAB2BJREFUeJztnUuMFFUUhr+eGVFAxqhRiAoxUVAjCAoajRDZqKDiC42JUUxcGEU0PqML3aiJK1EgigQfCxc+osYHqDExLlzgIwK6MGh00MCgMRADDOIIM+PiTsehqXtudd+qrurp/0v+DVTdR90z3eevOnUbhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgjRTswEXgB+Ag4AQ1KhOjC8FquBWca6RTMWWFOCCUu21gLjPGt4GB1pDwROBa6q43hRDAuAKXk1fgqwmeKjXErWt8BJ3tXLiAnA+oInKh2u94HxxrplShewKucJSem1HOg0Vywn7gUG6xyslJ0GgKXBVYrkGexkcRGwzzNAKT/tBa4w1qUTWGH8f2qGgLdxNtDHeUCvMVgpW23D3Y/xMR6XEwwZx6Sm2ukG4ATjODmE5mgjdqY/Efh6xPHRjOz8F2CacawcQr76ADjauP5nAVtrzommdhC7gLnG8XII+ehZ7Ex/PvBXwnnRJA2mH7gpcJ4cQjYaAO4OXOtbgH8950djDe4RoGKcK4cQp1CmXwEeC7QRTWiQL+I+9n3IITSm7diZ/hHAyynaiSbNYD/CJYA+5BDq00bgZON6dgOfpmwrmrSD3oRtT+QQ0imU6U8Gvq+jvWjqGfw2YIbRlhyCrVCmP4v6v06jqXcSe4BLA23KIRyqNJn+QlxSWG/b0TQyoQPA7YF25RCcQpk+wB3AwQbbjyZmck9i28R2dwihTL8DeDqyj2hiJ/kacKTRfrs6hFCmfxTwegb9RJPFZD8HjjX6aDeHEMr0jwe+yKivaLKa9A+4wlIf7eIQnsPO9E8Dfsywv2iynPwfwJxAf6PVIQwAywJzvxD4M+N+o8n6QuwDrg70uQjoy6HvorQXuDIw5+uB/Tn0HU0eFyTNX8O5jA6HsB37jZ0KcD/5fepFk+fFWY5db9jqDiGU6XcCK3MeQzR5X6R3sF9lmgCsa8I4staH2Jn+yLq9tg6AIeBL4ERjDK3mEFZgZ/qTgG+aNJZomnXRQvWGUH6HkCa3SarbUwAMaxcwLzCesjqEPsKZ/nyS6/YUACOUpt6wbA4hlOmDXbenAEhQqN6wLA5hE3amXwEeL3B80RR5cddg1xsW7RBCmX7auj0FgKGPsesNi3IIoUz/GNLX7SkAAgp9zELzHMIAcE9gLPXW7SkAUmgbcE5grHk7hDSZfiN1ewqAlNoDXBYYb14OoZdwpt9o3Z4CoA6lqTfM2iGk+QqKqdtTADSgmwPjzsohrMPO9AGWlOB6tFUArMVZrBCxDiGU6VcZA7xagusy6gNgEHgI+wZREvU6hDSZfi0V4NGc5q0AAP4GrvOMsUL4EyGtQ+gjvCGm1dcN5FPZ09YBsAOY7RlfF/A84S1sIOwQeoePsahuwWJ9PVyAq38s+rqNigDYjMvqk5iAezO5euzPwNTAfHwOYZPRT5UzgJ4R51jl3VMox82gaIocvHWvfTLwXcI5O4GLAnOqdQhpMv25uMfVtf1ZZV/dHBqgCoA6ZO1+ORv3teA7dz+wODCvLlw93kqjnyo3Av8Y/VmPg6v9KABS6iBwpzGea0j3UukgcF/k3CvAgynHHbpNvAznLhQAhnbjv9VbwS1ovQ98Qm/i+Oik/nsIIfu4EHc7WwGQoK3A2Z4xVDP9Rtt+F3un01rGAe9F9Gc5hBnAbxFtj8oA2IC/KjirRCqNTWR4HF9l0J+VwE7KqI9REQBv4P/rzPq5esgmTsNVJ2fVn+UQxgJvZdhXSwbAE/jfDApl+o3KZxMvJtnmxcpyCB3AUzn0WfoA6MdVyfpIm+k3qlqbuBjb5sUqdHv5NvKrGI4m6wHtxL/XcN4vSo5U1SY2q7+QQ7iEfD6BoslyMFtwGyAk0YX7PcK8F6JoWTeeppLt5hClCoDP8G8T042r/i16cZolyyEch9tSZ1QFwEv4H6GWqYK2mbIePo0BXsmon2hiOh8EHsZfwJFXpt8qsh4/V3BvR7VsAFgFHJB/pt8qCjmExcPXsqUCwCrgqAAPUO7XvJutAVzZmo/zgd8bbDuaeju0CjjaJdNvVJZDmEJy/UOpAsDKbtst029U6/C/C9lIqXs0aTuytjovS3lUq8j6FO3EPeIuTQAcBO4yzp9D499f7axQgepS0r2JFI3V+G7gcuPca4nLYNtdfbhydh8LCBeYRONreCv+Ag5l+tkp5BCmA78a50eT1KhVwNEFrDYGJDWmVfh3S5mI22qvKQFgFXB0A58Yk5DiZDmEscCbCedEM7Ixq4BDmX5zZDmEDtyvtGQeAP3ArcYxyvSbq17cz+34WML/BSbR7MTevFGZfjHah+0Q5uHWLprTPf9efWlCmX5xGsR2CL61i6YL95vBRV8AyclyCJmjTL+cWo+9n2ImKNMvtyyHEM10lOm3gnYAZ3rW8DCsn2uppQe3IYIoL4O4m0E9eXYyE1fUsQV3f6DoiG939eN+k3EF7scohBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgjRJvwHgCy8xzapbjIAAAAASUVORK5CYII="))
        mediabody = MediaIoBaseUpload(io_buff, mimetype="image/jpeg")
        body = {
            'title': "test.png",
            'mimeType': "image/png",
            'parents': [{'id': '0ByC1Jggyu8GGM20xekU4dXJ5VTQ'}],
            'description': 'foo'
        }
        file = drive.files().insert(
            body=body,
            media_body=mediabody
        ).execute()
        io_buff.close()

    elif self.request.get("fn") == "drive_test":
        import json

        import StringIO
        import httplib2
        from oauth2client.service_account import ServiceAccountCredentials
        from apiclient.discovery import build
        from apiclient.http import MediaIoBaseUpload

        from oauth2client import client

        flow = client.flow_from_clientsecrets(
            'drive_client_id.json',
            scope='https://www.googleapis.com/auth/drive',
            redirect_uri='https://' + app_identity.get_application_id() + '.appspot.com/data?fn=drive_oauth')

        auth = str(self.request.get("auth"))
        if auth == "" or auth.lower() == "none":
            auth_uri = flow.step1_get_authorize_url()
            self.response.out.write(auth_uri)
        else:
            credentials = flow.step2_exchange(auth)
            self.response.out.write(json.dumps({"access_token": credentials.access_token, "refresh_token": credentials.refresh_token}))
            http_auth = credentials.authorize(httplib2.Http())
            drive = build('drive', 'v2', http=http_auth)
            io_buff = StringIO.StringIO(base64.b64decode("iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAB2BJREFUeJztnUuMFFUUhr+eGVFAxqhRiAoxUVAjCAoajRDZqKDiC42JUUxcGEU0PqML3aiJK1EgigQfCxc+osYHqDExLlzgIwK6MGh00MCgMRADDOIIM+PiTsehqXtudd+qrurp/0v+DVTdR90z3eevOnUbhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgjRTswEXgB+Ag4AQ1KhOjC8FquBWca6RTMWWFOCCUu21gLjPGt4GB1pDwROBa6q43hRDAuAKXk1fgqwmeKjXErWt8BJ3tXLiAnA+oInKh2u94HxxrplShewKucJSem1HOg0Vywn7gUG6xyslJ0GgKXBVYrkGexkcRGwzzNAKT/tBa4w1qUTWGH8f2qGgLdxNtDHeUCvMVgpW23D3Y/xMR6XEwwZx6Sm2ukG4ATjODmE5mgjdqY/Efh6xPHRjOz8F2CacawcQr76ADjauP5nAVtrzommdhC7gLnG8XII+ehZ7Ex/PvBXwnnRJA2mH7gpcJ4cQjYaAO4OXOtbgH8950djDe4RoGKcK4cQp1CmXwEeC7QRTWiQL+I+9n3IITSm7diZ/hHAyynaiSbNYD/CJYA+5BDq00bgZON6dgOfpmwrmrSD3oRtT+QQ0imU6U8Gvq+jvWjqGfw2YIbRlhyCrVCmP4v6v06jqXcSe4BLA23KIRyqNJn+QlxSWG/b0TQyoQPA7YF25RCcQpk+wB3AwQbbjyZmck9i28R2dwihTL8DeDqyj2hiJ/kacKTRfrs6hFCmfxTwegb9RJPFZD8HjjX6aDeHEMr0jwe+yKivaLKa9A+4wlIf7eIQnsPO9E8Dfsywv2iynPwfwJxAf6PVIQwAywJzvxD4M+N+o8n6QuwDrg70uQjoy6HvorQXuDIw5+uB/Tn0HU0eFyTNX8O5jA6HsB37jZ0KcD/5fepFk+fFWY5db9jqDiGU6XcCK3MeQzR5X6R3sF9lmgCsa8I4staH2Jn+yLq9tg6AIeBL4ERjDK3mEFZgZ/qTgG+aNJZomnXRQvWGUH6HkCa3SarbUwAMaxcwLzCesjqEPsKZ/nyS6/YUACOUpt6wbA4hlOmDXbenAEhQqN6wLA5hE3amXwEeL3B80RR5cddg1xsW7RBCmX7auj0FgKGPsesNi3IIoUz/GNLX7SkAAgp9zELzHMIAcE9gLPXW7SkAUmgbcE5grHk7hDSZfiN1ewqAlNoDXBYYb14OoZdwpt9o3Z4CoA6lqTfM2iGk+QqKqdtTADSgmwPjzsohrMPO9AGWlOB6tFUArMVZrBCxDiGU6VcZA7xagusy6gNgEHgI+wZREvU6hDSZfi0V4NGc5q0AAP4GrvOMsUL4EyGtQ+gjvCGm1dcN5FPZ09YBsAOY7RlfF/A84S1sIOwQeoePsahuwWJ9PVyAq38s+rqNigDYjMvqk5iAezO5euzPwNTAfHwOYZPRT5UzgJ4R51jl3VMox82gaIocvHWvfTLwXcI5O4GLAnOqdQhpMv25uMfVtf1ZZV/dHBqgCoA6ZO1+ORv3teA7dz+wODCvLlw93kqjnyo3Av8Y/VmPg6v9KABS6iBwpzGea0j3UukgcF/k3CvAgynHHbpNvAznLhQAhnbjv9VbwS1ovQ98Qm/i+Oik/nsIIfu4EHc7WwGQoK3A2Z4xVDP9Rtt+F3un01rGAe9F9Gc5hBnAbxFtj8oA2IC/KjirRCqNTWR4HF9l0J+VwE7KqI9REQBv4P/rzPq5esgmTsNVJ2fVn+UQxgJvZdhXSwbAE/jfDApl+o3KZxMvJtnmxcpyCB3AUzn0WfoA6MdVyfpIm+k3qlqbuBjb5sUqdHv5NvKrGI4m6wHtxL/XcN4vSo5U1SY2q7+QQ7iEfD6BoslyMFtwGyAk0YX7PcK8F6JoWTeeppLt5hClCoDP8G8T042r/i16cZolyyEch9tSZ1QFwEv4H6GWqYK2mbIePo0BXsmon2hiOh8EHsZfwJFXpt8qsh4/V3BvR7VsAFgFHJB/pt8qCjmExcPXsqUCwCrgqAAPUO7XvJutAVzZmo/zgd8bbDuaeju0CjjaJdNvVJZDmEJy/UOpAsDKbtst029U6/C/C9lIqXs0aTuytjovS3lUq8j6FO3EPeIuTQAcBO4yzp9D499f7axQgepS0r2JFI3V+G7gcuPca4nLYNtdfbhydh8LCBeYRONreCv+Ag5l+tkp5BCmA78a50eT1KhVwNEFrDYGJDWmVfh3S5mI22qvKQFgFXB0A58Yk5DiZDmEscCbCedEM7Ixq4BDmX5zZDmEDtyvtGQeAP3ArcYxyvSbq17cz+34WML/BSbR7MTevFGZfjHah+0Q5uHWLprTPf9efWlCmX5xGsR2CL61i6YL95vBRV8AyclyCJmjTL+cWo+9n2ImKNMvtyyHEM10lOm3gnYAZ3rW8DCsn2uppQe3IYIoL4O4m0E9eXYyE1fUsQV3f6DoiG939eN+k3EF7scohBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgjRJvwHgCy8xzapbjIAAAAASUVORK5CYII="))
            mediabody = MediaIoBaseUpload(io_buff, mimetype="image/jpeg")
            body = {
                'title': "test.png",
                'mimeType': "image/png",
                'parents': [{'id': '0ByC1Jggyu8GGM20xekU4dXJ5VTQ'}],
                'description': 'foo'
            }
            file = drive.files().insert(
                body=body,
                media_body=mediabody
            ).execute()
            io_buff.close()

    elif self.request.get("fn") == "google_drive_legacy":
        import base64

        oset = int(str(self.request.get("offset")))
        done = True
        app_entries = FieldApplicationEntry.query().order(FieldApplicationEntry.insert_time).fetch(1, offset=oset)
        pic_ext = "jpg"
        pic_mime = "image/jpeg"
        for app_entry in app_entries:
            done = False
            f_content = None
            try:
                f1 = GCSLockedFile("/QualificationCards/" + app_entry.identifier + ".jpg")
                f_content = base64.b64encode(f1.read())
            except:
                try:
                    f2 = GCSLockedFile("/QualificationCards/" + app_entry.identifier + ".png")
                    f_content = base64.b64encode(f2.read())
                    pic_ext = "png"
                    pic_mime = "image/png"
                except:
                    f_content = None

            if not f_content is None:
                cust_folder_id = Helpers.create_customer_folder_in_google_drive(app_entry,
                                                                        Helpers.get_root_customer_folder(),
                                                                        app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(),
                                                                        "root_folder")

                qual_card_folder_id = Helpers.create_customer_folder_in_google_drive(app_entry, cust_folder_id, "Qual Card", "qual_card")

                Helpers.create_file_in_google_drive(qual_card_folder_id, "qualcard." + pic_ext, f_content, pic_mime)

        self.response.out.write(str(int(done)))

    elif self.request.get("fn") == "peters_deals":
        identifiers = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == "CHAP1001")
        for app_entry in app_entries:
            identifiers.append(app_entry.identifier)

        self.response.out.write(json.dumps(identifiers))

    elif self.request.get("fn") == "customer_details":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            self.response.content_type = "application/json"
            ret_json = {}

            atts = ["customer_address", "customer_first_name", "customer_last_name", "customer_phone", "customer_email"]
            for att in atts:
                ret_json[att] = getattr(app_entry, att)

            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "new_sr_testing":
        Helpers.grant_sales_rabbit_access("", "", "", "", "")

    elif self.request.get("fn") == "andrews_leads":
        data = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == "SHAF1006")
        for app_entry in app_entries:
            data.append(app_entry)

        data = Helpers.bubble_sort(data, "insert_time")
        data.reverse()

        data2 = []
        for item in data:
            dct = {}
            dct["Name"] = item.customer_first_name.strip().title() + " " + item.customer_last_name.strip().title()
            dct["Address"] = item.customer_address + "\n" + item.customer_city + ", " + item.customer_state + "\n" + item.customer_postal
            dct["Phone"] = Helpers.format_phone_number(item.customer_phone)
            dct["Timestamp"] = item.insert_time
            data2.append(dct)

        self.response.out.write(json.dumps(data2))

    elif self.request.get("fn") == "gdrive_search_test":
        logging.info(Helpers.check_if_file_exists_in_google_drive("Signed Docs", "0ByC1Jggyu8GGLXNRTnNUdUhzU2M"))

    elif self.request.get("fn") == "update_panel_option":
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.identifier == self.request.get("identifier"))
        if not proposal is None:
            info = json.loads(proposal.info)
            orig_panel_count = float(info["system_size"])
            info["panel_type"] = self.request.get("panel")
            if not "new_panel_qty" in info.keys():
                info["new_panel_qty"] = info["panel_qty"]

            info["panel_qty_override"] = True
            proposal.info = json.dumps(info)
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
            if not usr is None:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == proposal.field_app_identifier)
                if not app_entry is None:    
                    proposal.info = json.dumps(info)
                    proposal.put()
                    proposal.fix_system_size()
                    CustomerTranscriber.transcribe(app_entry, usr, "panel_qty_update")                
            
                    self.response.out.write(json.dumps(info))

    elif self.request.get("fn") == "fix_credits":
        oset = 0
        if str(self.request.get("offset")) == "" or (str(self.request.get("offset")).lower() == "none"):
            oset = 0
        else:
            oset = int(self.request.get("offset"))

        app_entries = FieldApplicationEntry.query().order(FieldApplicationEntry.insert_time).fetch(25, offset=oset)
        ccs = []
        done = True
        for app_entry in app_entries:
            done = False
            cc=CreditCheck(
                identifier=Helpers.guid(),
                field_app_identifier=app_entry.identifier,
                success=False,
                score=-1,
                last_four=-1,
                recorded_dt=Helpers.pacific_now()
            )
            ccs.append(cc)

        if len(ccs) == 1:
            ccs[0].put()
        elif len(ccs) > 1:
            ndb.put_multi(ccs)

        if done:
            self.response.out.write("done")
        else:
            self.redirect("/data?fn=fix_credits&offset=" + str(oset + 25))

    elif self.request.get("fn") == "aldo":
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == "ALDO0701")
        for app_entry in app_entries:
            if app_entry.sp_two_time < datetime.now() + timedelta(days=50):
                app_entry.sp_two_time = datetime(2016, 5, 22, 10, 30, 0)
                app_entry.put()

    elif self.request.get("fn") == "update_last_four":
        cc = CreditCheck.first(CreditCheck.field_app_identifier == self.request.get("identifier"))
        if not cc is None:
            cc.last_four = int(self.request.get("val"))
            cc.put()

    elif self.request.get("fn") == "project_verification_status":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["verify_submitted"] = self.request.get("status")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "save_me_rejected_tallies":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["save_me"] = FieldApplicationEntry.query(FieldApplicationEntry.save_me == True).count()
        ret_json["rejected"] = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.save_me == False,
                PerfectPacketSubmission.archived == False,
                PerfectPacketSubmission.rejected == True
            )
        ).count()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_save_mes":
        self.response.content_type = "application/json"
        ret_json = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.save_me == True)
        for app_entry in app_entries:
            ret_json.append({"identifier": app_entry.identifier, "name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_new_packet_panel_info":
        data = json.loads(self.request.get("data"))
        if not "panel_work_type" in data.keys() or data["panel_work_type"] is None:
            data["panel_work_type"] = "n/a"
        electricians = Helpers.read_setting("electricians")

        existing_assessment = PanelAssessment.first(
            PanelAssessment.field_app_identifier == self.request.get("identifier"))

        if existing_assessment is None:
            assessment = PanelAssessment(
                identifier=Helpers.guid(),
                field_app_identifier=self.request.get("identifier"),
                completed=(data["panel_work_needed"] == "0")
            )
            assessment.work_type = "n/a"
            if not assessment.completed:
                assessment.work_type = data["panel_work_type"]

            assessment.put()
        else:
            existing_assessment.completed = False
            existing_assessment.work_type = "n/a"
            if data["panel_work_needed"] == "1":
                existing_assessment.work_type = data["panel_work_type"]

            existing_assessment.put()

        pp_sub = PerfectPacketSubmission.first(
            PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))

        info = json.loads(pp_sub.extra_info)
        info["new_buss_ratings"] = data["ratings"]["buss_rating"]
        info["new_breaker_amps"] = data["ratings"]["main_breaker_rating"]
        info["solar_breaker"] = data["ratings"]["solar_breaker"]

        info["try_intercept"] = data["intercept_needed"]
        if info["try_intercept"] == "0":
            info["mpu_needed"] = data["mpu_needed"]
            if info["mpu_needed"] == "0":
                info["panel_work_required"] = data["panel_work_needed"]
                if info["panel_work_required"] == "1":
                    info["panel_work_type"] = data["panel_work_type"]

        if "electrician" in data.keys():
            if not data["electrician"] is None:
                for electrician in electricians:
                    if electrician["name"] == data["electrician"]:
                        info["electrician"] = electrician

        pp_sub.extra_info = json.dumps(info)
        pp_sub.put()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            app_entry.new_survey_state = 7
            app_entry.put()

    elif self.request.get("fn") == "fix_panel_notes":
        oset = str(self.request.get("offset"))
        if oset == "" or oset.lower() == "none":
            oset = 0
        else:
            oset = int(oset)

        pp_subs = PerfectPacketSubmission.query().order(PerfectPacketSubmission.rep_submission_date).fetch(50, offset=oset)
        done = True
        notes_to_put = []
        for pp_sub in pp_subs:
            done = False
            info = json.loads(pp_sub.extra_info)
            if "panel_notes" in info.keys():
                if not info["panel_notes"] == "":
                    notes_to_put.append(CustomerNote(
                        identifier=Helpers.guid(),
                        author=FieldApplicationUser.first(FieldApplicationUser.rep_email == "rnirnber@gmail.com").identifier,
                        blob_count=0,
                        content=json.dumps({"txt": [info["panel_notes"]]}),
                        field_app_identifier=pp_sub.field_application_identifier,
                        inserted_pacific=Helpers.pacific_now(),
                        inserted_utc=datetime.now(),
                        note_key="panel_work",
                        perms="public",
                        read=True
                    ))

        if len(notes_to_put) == 1:
            notes_to_put[0].put()

        elif len(notes_to_put) > 1:
            ndb.put_multi(notes_to_put)

        if done:
            self.response.out.write("done")

        else:
            self.redirect("/data?fn=fix_panel_notes&offset=" + str(oset + 50))

    elif self.request.get("fn") == "file_upload_testing":
        self.response.out.write(json.dumps(self.request.POST.multi.keys()))

    elif self.request.get("fn") == "remove_panel_work_new_info":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)

            keys = ["new_buss_ratings", "new_breaker_amps", "solar_breaker", "try_intercept", "mpu_needed", "panel_work_required", "panel_work_type", "electrician"]
            info_keys = info.keys()
            for key in keys:
                if key in info_keys:
                    del info[key]

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put
            assessment = PanelAssessment.first(PanelAssessment.field_app_identifier == self.request.get("identifier"))
            if not assessment is None:
                assessment.key.delete()

        data = json.loads(self.request.get("data"))
        if data["panel_work_type"] is None:
            data["panel_work_type"] = "n/a"
        electricians = Helpers.read_setting("electricians")

        existing_assessment = PanelAssessment.first(
            PanelAssessment.field_app_identifier == self.request.get("identifier"))

        if existing_assessment is None:
            assessment = PanelAssessment(
                identifier=Helpers.guid(),
                field_app_identifier=self.request.get("identifier"),
                completed=(data["panel_work_needed"] == "0")
            )
            assessment.work_type = "n/a"
            if not assessment.completed:
                assessment.work_type = data["panel_work_type"]

            assessment.put()
        else:
            existing_assessment.completed = False
            existing_assessment.work_type = "n/a"
            if data["panel_work_needed"] == "1":
                existing_assessment.work_type = data["panel_work_type"]

            existing_assessment.put()

        pp_sub = PerfectPacketSubmission.first(
            PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))

        info = json.loads(pp_sub.extra_info)
        info["new_buss_ratings"] = data["ratings"]["buss_rating"]
        info["new_breaker_amps"] = data["ratings"]["main_breaker_rating"]
        info["solar_breaker"] = data["ratings"]["solar_breaker"]

        info["try_intercept"] = data["intercept_needed"]
        if info["try_intercept"] == "0":
            info["mpu_needed"] = data["mpu_needed"]
            if info["mpu_needed"] == "0":
                info["panel_work_required"] = data["panel_work_needed"]
                if info["panel_work_required"] == "1":
                    info["panel_work_type"] = data["panel_work_type"]

        if "electrician" in data.keys():
            if not data["electrician"] is None:
                for electrician in electricians:
                    if electrician["name"] == data["electrician"]:
                        info["electrician"] = electrician

        pp_sub.extra_info = json.dumps(info)
        pp_sub.put()

    elif self.request.get("fn") == "get_panel_work_view":
        electricians = Helpers.read_setting("electricians")

        def keep_packet(p):
            info = json.loads(p.extra_info)
            keys = info.keys()
            return "check_plan_set_sent_to_electrician" in keys and "electrician" in keys

        self.response.content_type = "application/json"
        ret_json = {}

        pp_subs = PerfectPacketSubmission.query(
            ndb.AND
            (
                PerfectPacketSubmission.approval_date > datetime(2016, 4, 1),
                PerfectPacketSubmission.approved == True
            )
        )
        app_ids_to_query = ["-1"]
        app_identifier_idx_dict = {}
        items = []
        for pp_sub in pp_subs:
            if keep_packet(pp_sub):
                app_ids_to_query.append(pp_sub.field_application_identifier)
                app_identifier_idx_dict[pp_sub.field_application_identifier] = len(app_identifier_idx_dict.keys())
                item = {}
                item["notes"] = []
                item["identifier"] = pp_sub.field_application_identifier
                item["submission_identifier"] = pp_sub.identifier
                item["extra_info"] = json.loads(pp_sub.extra_info)
                items.append(item)

        apps = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app in apps:
            idx = app_identifier_idx_dict[app.identifier]
            items[idx]["name"] = app.customer_first_name.strip().title() + " " + app.customer_last_name.strip().title()
            items[idx]["address"] = app.customer_address
            items[idx]["city"] = app.customer_city
            items[idx]["state"] = app.customer_state
            items[idx]["postal"] = app.customer_postal
            items[idx]["phone"] = Helpers.format_phone_number(app.customer_phone)
            items[idx]["utility_number"] = app.customer_utility_account_number

        assessments = PanelAssessment.query(PanelAssessment.field_app_identifier.IN(app_ids_to_query))
        for assessment in assessments:
            idx = app_identifier_idx_dict[assessment.field_app_identifier]
            items[idx]["assessment"] = {"completed": assessment.completed, "work_type": assessment.work_type}

        notes = CustomerNote.query(
            ndb.AND
            (
                CustomerNote.note_key == "panel_work",
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )
        for note in notes:
            idx = app_identifier_idx_dict[note.field_app_identifier]
            items[idx]["notes"].append(json.loads(note.content)["txt"][0])

        ret_json = {}
        for item in items:
            e = item["extra_info"]["electrician"]["name"]
            for electrician in electricians:
                if electrician["name"] == e:
                    if not "_" + electrician["name"].replace(" ", "_") in ret_json.keys():
                        ret_json["_" + electrician["name"].replace(" ", "_")] = {"name": electrician["name"], "phone": Helpers.format_phone_number(electrician["phone"]), "email": electrician["email"], "customers": []}
                    ret_json["_" + electrician["name"].replace(" ", "_")]["customers"].append(item)


        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "electrical_checkoff":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info[self.request.get("key")] = self.request.get("value")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "electrical_checkoff_remove":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            try:
                del info[self.request.get("key")]
            except:
                info = info

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "reassign_as_mpu":
        electricians = Helpers.read_setting("electricians")
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["try_intercept"] = "0"
            info["mpu_needed"] = "1"
            for electrician in electricians:
                if electrician["name"] == self.request.get("electrician"):
                    info["electrician"] = electrician

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "registration_existing_user_check":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["found"] = not (FieldApplicationUser.first(ndb.OR(FieldApplicationUser.rep_email == self.request.get("rep_email"),FieldApplicationUser.rep_id == self.request.get("rep_id"))) is None)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "copy_document_template_items":
        source = ComposedDocument.first(ComposedDocument.identifier == self.request.get("source"))
        destination = ComposedDocument.first(ComposedDocument.identifier == self.request.get("destination"))

        if (not source is None) and (not destination is None):
            source_items = json.loads(source.template_items)
            destination_items = json.loads(destination.template_items)

            destination_items[int(self.request.get("destination_index"))] = source_items[int(self.request.get("source_index"))]
            destination.template_items = json.dumps(destination_items)
            destination.put()

    elif self.request.get("fn") == "remove_docs_composer_page":
        self.response.content_type = "application/json"
        ret_json = {}
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            new_token = Helpers.guid()
            token = doc.token
            cnt = 0
            files_to_copy = []
            while cnt < doc.page_count:
                if not (cnt == int(self.request.get("index"))):
                    num = cnt + 1
                    leng = len(files_to_copy)
                    leng += 1
                    files_to_copy.append({"source": "/Images/Docs/" + token + "/72/" + str(num) + ".jpg", "destination": "/Images/Docs/" + new_token + "/72/" + str(leng) + ".jpg"})
                    files_to_copy.append({"source": "/Images/Docs/" + token + "/300/" + str(num) + ".jpg", "destination": "/Images/Docs/" + new_token + "/300/" + str(leng) + ".jpg"})
                cnt += 1

            for item in files_to_copy:
                Helpers.gcs_copy(item["source"], item["destination"], "image/jpeg", "public-read")

            doc.page_count -= 1
            doc.token = new_token
            doc.put()
            ret_json["token"] = new_token
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sales_stats_for_smart_assign_csv_report":
        office_identifiers = json.loads(self.request.get("offices"))
        if len(office_identifiers) >= 1:
            import tablib
            offices = OfficeLocation.query(OfficeLocation.identifier.IN(office_identifiers))
            msg_body = "Attached are your reports..."
            subject = "Your Data to Go Report"
            attachment_data = {}
            attachment_data["data"] = []
            attachment_data["content_types"] = []
            attachment_data["filenames"] = []
            for office in offices:
                headers = ("Name", "Conversion of Leads to AKs", "Conversion Of Leads to CDs", "Conversion Of AKs to CDs", "Combined Average")
                f = GCSLockedFile("/AutoAssignStats/" + office.identifier + ".json")
                items = json.loads(f.read())
                f.unlock()

                data = []
                for item in items:
                    percentage1 = item["conversion_of_abs_to_aks"] * float(100)
                    percentage1 = str(percentage1)
                    percentage1 += "%"

                    percentage2 = item["conversion_of_leads_to_cds"] * float(100)
                    percentage2 = str(percentage2)
                    percentage2 += "%"

                    percentage3 = item["conversion_of_aks_to_cds"] * float(100)
                    percentage3 = str(percentage3)
                    percentage3 += "%"

                    percentage4 = item["dual_average"] * float(100)
                    percentage4 = str(percentage4)
                    percentage4 += "%"

                    data.append((str(item["name"]),
                            percentage1,
                            percentage2,
                            percentage3,
                            percentage4))

                structured_data = tablib.Dataset(*data, headers=headers)
                attachment_data["data"].append(base64.b64encode(structured_data.csv))
                attachment_data["content_types"].append("text/csv")
                attachment_data["filenames"].append(office.name.replace(" ", "_") + ".csv")
                
            Helpers.send_email(self.request.get("email"), subject, msg_body, attachment_data)
        

    elif self.request.get("fn") == "pin":
        ret_json = {}
        pin_codes = {"docs_composer": "7025", "data_to_go": "0325"}
        self.response.content_type = "application/json"
        ret_json["success"] = (self.request.get("pin_key") in pin_codes.keys() and pin_codes[self.request.get("pin_key")] == self.request.get("pin"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "user_manual_password_reset":
        usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not usr is None:
            usr.password = Helpers.hash_pass(self.request.get("pass"))
            usr.put()
            Helpers.send_email(usr.rep_email, "Password Reset", usr.first_name.strip().title() + " " + usr.last_name.strip().title() + ",\r\n\r\nAn adminstrator has manually reset your password. If you did initiate this request, please inform Thomas or Ray.\r\n\r\nThanks! -Noreply @ Newpower")

    elif self.request.get("fn") == "enumerate_slides":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["slides"] = []
        slides = Slide.query()
        slides_cpy = []
        for slide in slides:
            slides_cpy.append(slide)

        for item in slides_cpy:
            ret_json["slides"].append({"identifier": item.identifier, "slide_count": item.slide_count, "slide_identifiers": json.loads(item.slide_identifiers), "name": item.name, "options": json.loads(item.options), "children": item.children(True), "image_assets": json.loads(item.image_assets), "applicable_offices": json.loads(item.applicable_offices)})

        ret_json["functions"] = Helpers.list_crunchable_fns()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_new_slide":
        default_view = [[{"type": "text", "font-size": "16", "font-weight": "normal", "font-family": "Maven Pro", "color": "rgba(255, 255, 255, 1.0)", "x": 100, "y": 100, "value": "Hello World", "identifier": Helpers.guid(), "name": "Layer 1"}]]
        default_options = {"background": "rgba(0,0,0,1.0)", "color": "rgba(255,255,255,1.0)", "background_mode": "color", "local_functions": [], "web_assets": []}

        slide_item = SlideItem(
            identifier=Helpers.guid(),
            views=json.dumps(default_view),
            options=json.dumps(default_options),
            idx=0
        )

        slide = Slide(
            identifier=Helpers.guid(),
            slide_count=1,
            slide_identifiers=json.dumps([slide_item.identifier]),
            name=self.request.get("name"),
            options=json.dumps(default_options),
            image_assets="[]",
            applicable_offices="{}"
        )
        slide_item.put()
        slide.put()

    elif self.request.get("fn") == "rename_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            slide.name = self.request.get("name")
            slide.put()

    elif self.request.get("fn") == "delete_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            children = slide.children()
            for child in children:
                child.key.delete()
            slide.key.delete()

    elif self.request.get("fn") == "add_additional_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            slide.slide_count += 1
            new_item = SlideItem(
                identifier=Helpers.guid(),
                views=json.dumps([[]]),
                options=slide.options,
                idx=slide.slide_count - 1
            )
            new_item.put()
            slide.slide_identifiers = json.dumps(json.loads(slide.slide_identifiers) + [new_item.identifier])
            slide.put()
            self.response.content_type = "application/json"
            ret_json = {}
            ret_json["child"] = {"identifier": new_item.identifier, "views": json.loads(new_item.views), "options": json.loads(new_item.options), "idx": new_item.idx}
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "drop_slide_item":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        slide_item = SlideItem.first(SlideItem.identifier == self.request.get("item_identifier"))
        if (not slide is None) and (not slide_item is None):
            identifiers = json.loads(slide.slide_identifiers)
            if self.request.get("item_identifier") in identifiers:
                idx = identifiers.index(self.request.get("item_identifier"))
                del identifiers[idx]
                slide.slide_count -= 1

            slide.identifiers = json.dumps(identifiers)
            slide_item.key.delete()
            slide.put()

            if len(identifiers) > 0:
                update_slides = SlideItem.query(SlideItem.identifier.IN(identifiers))
                for item in update_slides:
                    item.idx = identifiers.index(item.identifier)
                    item.put()

    elif self.request.get("fn") == "add_subview_to_slide_item":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            last_view = views[len(views) - 1]
            copies = []
            for item in last_view:
                cpy = json.loads(json.dumps(item))
                #cpy["old_identifier"]
                #cpy["identifier"] = Helpers.guid()
                copies.append(cpy)
            views.append(copies)
            slide.views = json.dumps(views)
            slide.put()
            self.response.content_type = "application/json"
            ret_json = {}
            ret_json["view"] = copies
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "drop_subview":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            try:
                del views[int(self.request.get("index"))]
            except:
                views = views
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_slite_item_text_value":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            for item in views[int(self.request.get("subview_index"))]:
                if item["identifier"] == self.request.get("identifier"):
                    item["value"] = self.request.get("txt")
                    break
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_text_item_font_weight":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["font-weight"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_text_item_font_size":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["font-size"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "add_new_slide_component_item":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        slide_item = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if (not slide is None) and (not slide_item is None):
            views = json.loads(slide_item.views)
            options = json.loads(slide_item.options)
            target_view = views[int(self.request.get("subview_index"))]
            new_item = {}
            new_item["identifier"] = Helpers.guid()
            new_item["type"] = self.request.get("type")
            new_item["on_click"] = "n/a"
            if str(self.request.get("type")) == "text":
                new_item["font-size"] = "16"
                new_item["font-weight"] = "normal"
                new_item["font-family"] = "Maven Pro"
                new_item["color"] = options["color"]
                new_item["x"] = 100
                new_item["y"] = 100
                new_item["value"] = "Hello World"
                new_item["name"] = "Layer " + str(len(target_view) + 1)

            if str(self.request.get("type")) == "rectangle":
                new_item["font-size"] = "16"
                new_item["font-weight"] = "normal"
                new_item["font-family"] = "Maven Pro"
                new_item["color"] = options["color"]
                new_item["background"] = options["color"]
                new_item["border-color"] = "rgba(0,0,0,1.0)"
                new_item["border-width"] = 5
                new_item["border-radius"] = 0
                new_item["x"] = 300
                new_item["y"] = 300
                new_item["width"] = 100
                new_item["height"] = 100
                new_item["value"] = "Hello World"
                new_item["name"] = "Layer " + str(len(target_view) + 1)

            if str(self.request.get("type")) == "image":
                new_item["font-size"] = "16"
                new_item["font-weight"] = "normal"
                new_item["font-family"] = "Maven Pro"
                new_item["color"] = options["color"]
                new_item["background"] = options["color"]
                new_item["border-color"] = "rgba(0,0,0,1.0)"
                new_item["border-width"] = 5
                new_item["border-radius"] = 0
                new_item["x"] = 650
                new_item["y"] = 0
                new_item["width"] = 50
                new_item["height"] = 50
                new_item["value"] = "Hello World"
                new_item["name"] = "Layer " + str(len(target_view) + 1)
                new_item["image_identifier"] = self.request.get("image_identifier")
                new_item["image_extension"] = self.request.get("image_extension")

            if str(self.request.get("type")) == "user_input":
                new_item["value"] = "X"
                new_item["font-size"] = "16"
                new_item["font-weight"] = "normal"
                new_item["font-family"] = "Maven Pro"
                new_item["color"] = options["color"]
                new_item["background"] = options["color"]
                new_item["border-color"] = "rgba(0,0,0,1.0)"
                new_item["border-width"] = 5
                new_item["border-radius"] = 0
                new_item["x"] = 650
                new_item["y"] = 0
                new_item["width"] = 50
                new_item["height"] = 50
                new_item["value"] = ""
                new_item["name"] = "Layer " + str(len(target_view) + 1)
                new_item["text_width"] = 1

            if str(self.request.get("type")) == "two_dimensional_graph":
                new_item["y_function"] = "return [1, 2, 3];"
                new_item["x_function"] = "return [\"A\", \"B\", \"C\"];"
                new_item["x_color"] = "#00FF00"
                new_item["y_color"] = "#FF0000"
                new_item["y_format"] = "integer"
                new_item["x"] = 50
                new_item["y"] = 50
                new_item["chart_type"] = "b-chart"
                new_item["width"] = 600
                new_item["height"] = 600

            target_view.append(new_item)
            views[int(self.request.get("subview_index"))] = target_view
            slide_item.views = json.dumps(views)
            slide_item.put()
            self.response.content_type = "application/json"
            ret_json = {}
            ret_json["item"] = new_item
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_slide_item_x_y":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            target_view = views[int(self.request.get("subview_index"))]
            target_view[int(self.request.get("index"))]["x"] = int(self.request.get("x"))
            target_view[int(self.request.get("index"))]["y"] = int(self.request.get("y"))
            views[int(self.request.get("subview_index"))] = target_view
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_text_item_font_family":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["font-family"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_text_item_color":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["color"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_customer_email_address":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            digit_cnt = 0
            for char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]:
                if char in self.request.get("value"):
                    digit_cnt += 1

            if digit_cnt < 10:
                app_entry.customer_email = self.request.get("value")
                app_entry.put()
                booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
                if not booking is None:
                    booking.email = app_entry.customer_email
                    booking.put()

    elif self.request.get("fn") == "update_background_color_for_slide_item":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["background"] = self.request.get("value")
            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "update_slide_default_options":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["color"] = self.request.get("color")
            options["background"] = self.request.get("background")
            options["youtube_assets"] = json.loads(self.request.get("youtube_assets"))
            slide.options = json.dumps(options)
            slide.applicable_offices = self.request.get("applicable_offices")
            slide.put()

    elif self.request.get("fn") == "update_default_text_color_for_slide_item":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["color"] = self.request.get("value")
            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "move_presentation_item_down":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            target_view = views[int(self.request.get("subview_index"))]
            cpy = json.loads(json.dumps(target_view))
            item_a = json.loads(json.dumps(cpy[int(self.request.get("index"))]))
            item_b = json.loads(json.dumps(cpy[int(self.request.get("index")) - 1]))

            cpy[int(self.request.get("index"))] = item_b
            cpy[int(self.request.get("index")) - 1] = item_a

            views[int(self.request.get("subview_index"))] = cpy
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "move_presentation_item_up":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            target_view = views[int(self.request.get("subview_index"))]
            cpy = json.loads(json.dumps(target_view))
            item_a = json.loads(json.dumps(cpy[int(self.request.get("index"))]))
            item_b = json.loads(json.dumps(cpy[int(self.request.get("index")) + 1]))

            cpy[int(self.request.get("index"))] = item_b
            cpy[int(self.request.get("index")) + 1] = item_a

            views[int(self.request.get("subview_index"))] = cpy
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_width":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["width"] = int(self.request.get("value"))
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_on_click":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["on_click"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_height":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["height"] = int(self.request.get("value"))
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_shape_background_color":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["background"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_shape_border_width":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["border-width"] = int(self.request.get("value"))
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_shape_border_radius":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["border-radius"] = int(self.request.get("value"))
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_presentation_item_shape_border_color":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["border-color"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "read_email_template":
        self.response.content_type = "application/json"
        self.response.out.write(Helpers.read_email_template(self.request.get("name")))

    elif self.request.get("fn") == "rep_reschedule_customer_search_by_name":
        ret_json = {}
        ret_json["results"] = []
        r_id = self.session["user_rep_id"].upper()
        index = search.Index(name="cust_names")
        results = index.search(
            query=search.Query(
                self.request.get("query"),
                options=search.QueryOptions(
                    limit=1000
                )
            )
        )

        app_ids_to_query = ["-1"]

        for result in results:
            result_item = {}
            for field in result.fields:
                if field.name == "cust_identifier":
                    result_item["identifier"] = field.value
                elif field.name == "cust_name":
                    result_item["name"] = field.value
                elif field.name == "rep_id":
                    result_item["rep_id"] = field.value

            keys = result_item.keys()
            if "identifier" in keys and "name" and "rep_id" in keys and True:#result_item["rep_id"] == r_id:
                app_ids_to_query.append(result_item["identifier"])

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        rep_id_results_idxes = {}
        md5_insert_time_dict = {}
        for app_entry in app_entries:
            hashed = hashlib.md5(app_entry.customer_first_name.strip().lower() + "_" + app_entry.customer_last_name.strip().lower()).hexdigest()
            if not app_entry.save_me:
                if not app_entry.archived:
                    if app_entry.rep_id == r_id:#if not hashed in md5_insert_time_dict.keys() or (hashed in md5_insert_time_dict.keys() and md5_insert_time_dict[hashed] < app_entry.insert_time):
                        ret_json["results"].append({"identifier": app_entry.identifier, "name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), "address": app_entry.customer_address.strip().title() + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal})
                        md5_insert_time_dict[hashed] = app_entry.insert_time

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_assessment_for_app_entry":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["assessment"] = ""
        assessment = PanelAssessment.first(PanelAssessment.field_app_identifier == self.request.get("identifier"))
        if not assessment is None:
            ret_json["assessment"] = assessment.work_type

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "read_email_templates":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["templates"] = []
        templates = EmailTemplate.query()
        for item in templates:
            eyetem = {}
            eyetem["identifier"] = item.identifier
            eyetem["hash_keyy"] = item.hash_keyy
            eyetem["name"] = item.name
            eyetem["active"] = item.active
            eyetem["ut_content"] = item.ut_content
            eyetem["ca_content"] = item.ca_content
            eyetem["published"] = str(item.published)
            ret_json["templates"].append(eyetem)

        for item in ret_json["templates"]:
            item["lower"] = item["name"].strip().lower()

        ret_json["templates"] = Helpers.bubble_sort(ret_json["templates"], "lower")

        for item in ret_json["templates"]:
            del item["lower"]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_new_email_template":
        gid = Helpers.guid()
        hashed = hashlib.md5(gid).hexdigest().lower()
        et = EmailTemplate(
            identifier=gid,
            hash_keyy=hashed,
            name=self.request.get("name"),
            active=False,
            published=datetime(1970, 1, 1),
            ca_content="Edit the content here...",
            ut_content="Edit the content here..."
        )
        et.put()

    elif self.request.get("fn") == "update_name_for_email_template":
        et = EmailTemplate.first(EmailTemplate.identifier == self.request.get("identifier"))
        if not et is None:
            et.name = self.request.get("name")
            et.put()

    elif self.request.get("fn") == "activate_deactivate_email_template":
        et = EmailTemplate.first(EmailTemplate.identifier == self.request.get("identifier"))
        if not et is None:
            et.active = (self.request.get("value") == "1")
            et.put()

    elif self.request.get("fn") == "email_template_update_text":
        et = EmailTemplate.first(EmailTemplate.identifier == self.request.get("identifier"))
        if not et is None:
            setattr(et, self.request.get("state") + "_content", self.request.get("value"))
            et.put()

    elif self.request.get("fn") == "new_formula_testing":
        identifier = self.request.get("identifier")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        if not app_entry is None:
            booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
            if not booking is None:
                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
                if not proposal is None:
                    proposal_dict = json.loads(proposal.info)
                    formula = Helpers.compile_formula(self.request.get("formula"))
                    if not formula is None:
                        self.response.out.write(str(formula["fn"](app_entry, booking, proposal_dict)))

    elif self.request.get("fn") == "upload_slide_image":
        slide_identifier = self.request.get("identifier")
        new_img_id = Helpers.guid()

        bucket_name = os.environ.get(
            'BUCKET_NAME',
            app_identity.get_default_gcs_bucket_name()
        )
        bucket = '/' + bucket_name

        fyle = self.request.POST.multi["img"].file.read()
        myme = self.request.POST["img"].type
        extension = "jpg"
        if myme == "image/png":
            extension = "png"

        filename = bucket + '/SlideImages/' + slide_identifier + '/' + new_img_id + '.' + extension

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        gcs_file = gcs.open(
            filename,
            'w',
            content_type=myme,
            options={
                'x-goog-meta-foo': 'foo',
                'x-goog-meta-bar': 'bar',
                'x-goog-acl': 'public-read',
                'content-disposition': 'attachment'
            },
            retry_params=write_retry_params
        )

        gcs_file.write(fyle)
        gcs_file.close()

        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["image"] = {"identifier": new_img_id, "extension": extension}
        slide = Slide.first(Slide.identifier == slide_identifier)
        if not slide is None:
            assets = json.loads(slide.image_assets)
            assets.append(ret_json["image"])
            slide.image_assets = json.dumps(assets)
            slide.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "slides_presentation_search":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        index_entity_type_dict = {"customer": "cust_names", "rep": "app_users"}
        index_entity_type_name_field_dict = {"customer": "cust_name", "rep": "name"}
        index_entity_type_identifier_field_dict = {"customer": "cust_identifier", "rep": "identifier"}

        index = search.Index(name=index_entity_type_dict[self.request.get("entity_type")])
        results = index.search(self.request.get("query"))

        for result in results:
            result_item = {}
            for field in result.fields:
                name_field = index_entity_type_name_field_dict[self.request.get("entity_type")]
                identifier_field = index_entity_type_identifier_field_dict[self.request.get("entity_type")]
                if field.name == identifier_field:
                    result_item["identifier"] = field.value
                elif field.name == name_field:
                    result_item["name"] = field.value

            keys = result_item.keys()
            if "identifier" in keys and "name" in keys:
                ret_json["results"].append(result_item)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "remove_slide_item_component":
        slide_item = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide_item is None:
            views = json.loads(slide_item.views)
            target_view = views[int(self.request.get("view_index"))]
            try:
                del target_view[int(self.request.get("item_index"))]
                views[int(self.request.get("view_index"))] = target_view
            except:
                views = views

            slide_item.views = json.dumps(views)
            slide_item.put()

    elif self.request.get("fn") == "hashids_test":
        import hashids
        from random import randint
        r_int = randint(1,1000)
        hids = hashids.Hashids("abc902ielKKLLMM22", 8, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
        lead_id = hids.encode(int((datetime.now() - datetime(1970, 1, 1)).total_seconds()), r_int);
        self.response.out.write(lead_id)

    elif self.request.get("fn") == "remove_project_management_checkoff_date":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if self.request.get("key") in info["project_management_checkoffs"].keys():
                    if "date" in info["project_management_checkoffs"][self.request.get("key")].keys():
                        del info["project_management_checkoffs"][self.request.get("key")]["date"]
                        pp_sub.extra_info = json.dumps(info)
                        pp_sub.put()

    elif self.request.get("fn") == "get_customers_for_pm_tab":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["Unassigned"] = []
        pto_received = []
        pms = FieldApplicationUser.query(
            ndb.AND(
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.is_project_manager == True
            )
        )
        
        pm_identifier_name_dict = {}
        for pm in pms:
            ret_json[pm.first_name.strip().title() + " " + pm.last_name.strip().title()] = []
            pm_identifier_name_dict[pm.identifier] = pm.first_name.strip().title() + " " + pm.last_name.strip().title()

        app_identifier_info_dict = {}
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.save_me == False
            )
        )
        app_ids_to_query = ["-1"]
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
            item = {}
            item["identifier"] = app_entry.identifier
            item["customer_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["address"] = app_entry.customer_address
            item["city"] = app_entry.customer_city
            item["state"] = app_entry.customer_state
            item["postal"] = app_entry.customer_postal
            item["panel_work_completed"] = False

            app_identifier_info_dict[app_entry.identifier] = item

        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            key = "Unassigned"
            info = json.loads(pp_sub.extra_info)
            if "project_manager" in info.keys():
                pm_identifier = info["project_manager"]
                if pm_identifier in pm_identifier_name_dict.keys():
                    key = pm_identifier_name_dict[pm_identifier]

            skip = False
            if "project_management_checkoffs" in info.keys():
                if "received_pto" in info["project_management_checkoffs"].keys():
                    if info["project_management_checkoffs"]["received_pto"]["checked"] == True:
                        skip = True

            if "project_management_specifics" in info.keys():
                if "electrical" in info["project_management_specifics"].keys():
                    app_identifier_info_dict[pp_sub.field_application_identifier]["panel_work_completed"] = True

            if not skip:
                ret_json[key].append(app_identifier_info_dict[pp_sub.field_application_identifier])
            else:
                pto_received.append(app_identifier_info_dict[pp_sub.field_application_identifier])

        ret_json["PTO Received"] = pto_received

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "rep_customer_progress_pm_v2":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["customers"] = []

        app_identifier_info_dict = {}
        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.deal_closed == True,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.save_me == False,
                FieldApplicationEntry.rep_id == self.session["user_rep_id"]
            )
        )
        app_ids_to_query = ["-1"]
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
            item = {}
            item["identifier"] = app_entry.identifier
            item["customer_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            ret_json["customers"].append(item)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "backfill_quadrant_transactions":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill_quadrant_transactions", params={})

    elif self.request.get("fn") == "v3_questions_wc_script":
        g_f = GCSLockedFile("/SPV3Questions/" + self.request.get("identifier") + ".json")
        content = g_f.read()
        if content is None:
            content = "{}"
        existing_data = json.loads(content)
        existing_data[self.request.get("key")] = self.request.get("value")
        g_f.write(json.dumps(existing_data), "application/json", "public-read")
        g_f.unlock()

    elif self.request.get("fn") == "v3_questions_wc_script":
        g_f = GCSLockedFile("/SPV3Questions/" + self.request.get("identifier") + ".json")
        content = g_f.read()
        if content is None:
            content = "{}"
        existing_data = json.loads(content)
        existing_data[self.request.get("key")] = self.request.get("value")
        g_f.write(json.dumps(existing_data), "application/json", "public-read")
        g_f.unlock()

    elif self.request.get("fn") == "v4_questions_wc_script_v4":
        g_f = GCSLockedFile("/SPV4Questions/" + self.request.get("identifier") + ".json")
        content = g_f.read()
        if content is None:
            content = "{}"
        existing_data = json.loads(content)
        existing_data[self.request.get("key")] = self.request.get("value")
        g_f.write(json.dumps(existing_data), "application/json", "public-read")
        g_f.unlock()

    elif self.request.get("fn") == "take_care_of_grandpa":
        g_f = GCSLockedFile("/Grandpa/Details/" + self.request.get("identifier") + ".txt")
        g_f.write(self.request.get("message"), "text/plain", "public-read")
        g_f.unlock()

    elif self.request.get("fn") == "roof_year_estimation":
        re = GCSLockedFile("/RoofAgeEstimations/" + self.request.get("identifier") + "/estimation.txt")
        re.write(self.request.get("value"), "text/plain", "public-read")
        re.unlock()

    elif self.request.get("fn") == "unassigned_lock_save":
        ls_f = GCSLockedFile("/UnassignedLock/" + self.request.get("identifier" + "/value.txt"))
        ls_f.write(self.request.get("value"), "text/plain", "public-read")
        ls_f.unlock()

    elif self.request.get("fn") == "smoke_detector_details":
        sd_f = GCSLockedFile("/SmokeDetection/" + self.request.get("identifier") + "/details.txt")
        sd_f.write(self.request.get("value"), "text/plain", "public-read")
        sd_f.unlock()

    elif self.request.get("fn") == "save_smoke_detector_choice":
        s_f = GCSLockedFile("/SmokeDetection/" + self.request.get("identifier") + "/smoke.txt")
        s_f.write(self.request.get("value"), "text/plain", "public-read")

    elif self.request.get("fn") == "save_hoa_affiration":
        h_f = GCSLockedFile("/HOA/affirmation/" + self.request.get("identifier") + "/value.txt")
        h_f.write(self.request.get("value"), "text/plain", "public-read")
        h_f.unlock()    

    elif self.request.get("fn") == "save_hoa_name_unassigned":
        h_f = GCSLockedFile("/HOA/details/" + self.request.get("identifier") + "_details.txt")
        h_f.write(self.request.get("value"), "text/plain", "public-read")
        h_f.unlock()

    elif self.request.get("fn") == "grandpa_y_n":
        g_f = GCSLockedFile("Grandpa/YesOrNo/" + self.request.get("identifier") + ".txt")
        g_f.write(self.request.get("value"), "text/plain", "public-read")
        g_f.unlock()

    elif self.request.get("fn") == "story_count":
        s_f = GCSLockedFile("/StoryEstimations/" + self.request.get("identifier") + "/estimation.txt")
        s_f.write(self.request.get("value"), "text/plain", "public-read")
        s_f.unlock()

    elif self.request.get("fn") == "year_home_was_built_estimation":
        year_f = GCSLockedFile("/Estimations/YearHomeWasBuilt/" + self.request.get("identifier") + "/estimation.txt")
        year_f.write(self.request.get("value"), "text/plain", "public-read")
    

    elif self.request.get("fn") == "phone_call_check_incentive":
        f = GCSLockedFile("/PhoneCallIncentiveChoice/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("incentive"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "power_of_attorney_details":
        f = GCSLockedFile("/PowerOfAttorney/Details/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("info"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "confirm_power_of_attorney_yn":
        f = GCSLockedFile("/PowerOfAttorney/YesOrNo/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "second_power_of_attorney_write":
        f = GCSLockedFile("/PowerOfAttorneyConfirmation/YesOrNo/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "power_of_attorney_involvement":
        f = GCSLockedFile("/PowerOfAttorney/Involvement/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "confirmed_involvement_name_attorney":
        f = GCSLockedFile("/PowerOfAttorney/ConfirmedName/" + self.request.get("identifier") + ".txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "promises_yn_unassigned":
        f = GCSLockedFile("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/promise.txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "power_of_attorney_promises_data":
        f = GCSLockedFile("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/value.txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "initial_promises_yn":
        f = GCSLockedFile("/InitialPromises/YN/" + self.request.get("identifier") + "/value.txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "upload_wc_call":
        from io import BytesIO;
        import StringIO;

        identifier = self.request.get("identifier")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        if not app_entry is None:
            root_folder = ThirdPartyFolder.first(
                ndb.AND(
                    ThirdPartyFolder.field_app_identifier == identifier,
                    ThirdPartyFolder.folder_key == "root_folder"
                )
            )
            if not root_folder is None:
                audio_folder = ThirdPartyFolder.first(
                    ndb.AND(
                        ThirdPartyFolder.field_app_identifier == identifier,
                        ThirdPartyFolder.folder_key == "audio_recordings"
                    )
                )
                parent_id = "-1"
                if audio_folder is None:
                    parent_id = Helpers.create_customer_folder_in_google_drive(app_entry, root_folder.foreign_id, "Audio Recordings", "audio_recordings")
                else:
                    parent_id = audio_folder.foreign_id

                file_id = Helpers.create_file_in_google_drive(parent_id, "WC.mp3", self.request.get("b64"), "audio/mpeg")

                f = GCSLockedFile("/AudioRecordings/wc/" + identifier + ".mp3")
                file_content = self.request.POST.multi['mp3'].file.read()
                f.write(file_content, "audio/mpeg", "public-read")
                f.unlock()

    elif self.request.get("fn") == "initial_promises_save":
        f = GCSLockedFile("/InitialPromises/" + self.request.get("identifier") + "/value.txt")
        f.write(self.request.get("value"), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "unassigned_v2_bulk_questions":
        fw = GCSLockedFile("/UnassignedBulk3/" + self.request.get("identifier") + "/value.json")
        fw.write(self.request.get("json"), "text/plain", "public-read")
        fw.unlock()

    elif self.request.get("fn") == "wc_textarea_notes":
        fr = GCSLockedFile("/WCTANotes/" + self.request.get("identifier") + "/value.txt")
        fr.write(self.request.get("value"), "text/plain", "public-read")
        fr.unlock()

    elif self.request.get("fn") == "save_rep_assistance":
        assist = RepAssistance.first(RepAssistance.field_app_identifier) == ""

    elif self.request.get("fn") == "assistance_reminder_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/remind_assistance_needed", params={})

    elif self.request.get("fn") == "save_rep_assist":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                a = RepAssistance.first(RepAssistance.field_app_identifier == self.request.get("identifier"))
                if a == None:
                    a = RepAssistance(
                        identifier=Helpers.guid()
                    )
                a.field_app_identifier = self.request.get("identifier")
                a.rep_identifier = rep.identifier
                a.data = self.request.get("items")
                dt_vals = self.request.get("deadline").split("-")
                a.deadline = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), 23, 59, 59)
                a.completed = False

                a.put()

                text_msg = "Hello " + rep.first_name.strip().title() + ", " + rep.last_name.strip().title()
                text_msg = text_msg + ",\n\n"
                text_msg = text_msg + "There are some oustanding items and we need your help for a customer (" + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ")...\n\n"
                for i in json.loads(self.request.get("items")):
                    text_msg = text_msg + i
                    text_msg = text_msg + "\n"

                text_msg += "\n\nThank you!"

                Helpers.send_sms(rep.rep_phone, text_msg)


    elif self.request.get("fn") == "get_assistance_needed_for_rep":
        self.response.content_type = "application/json"
        ret_json = {"customers": []}
        items = RepAssistance.query(RepAssistance.rep_identifier == self.request.get("identifier"))
        for item in items:
            customer = {}
            customer["name"] = ""
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == item.field_app_identifier)
            if not app_entry is None:
                customer["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                customer["identifier"] = app_entry.identifier
                customer["data"] = json.loads(item.data)
                customer["item_identifier"] = item.identifier

                ret_json["customers"].append(customer)

        self.response.out.write(json.dumps(ret_json))        

    elif self.request.get("fn") == "fetch_rep_assist":
        app_ids_to_query = ["-1"]
        items = RepAssistance.query(RepAssistance.deadline >= datetime(1970, 1, 1))
        app_id_items_dict = {}
        app_id_cust_name_dict = {}
        for item in items:
            if not item.field_app_identifier in app_ids_to_query:
                app_ids_to_query.append(item.field_app_identifier)
            if not item.field_app_identifier in app_id_items_dict.keys():
                app_id_items_dict[item.field_app_identifier] = []

            app_id_items_dict[item.field_app_identifier].append(item)

        rep_ids_to_query = ["-1"]
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_id_cust_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            if not app_entry.rep_id in rep_ids_to_query:
                rep_ids_to_query.append(app_entry.rep_id)

        rep_identifier_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
        
        self.response.content_type = "application/json"

        ret = {}
        for app_id in app_id_items_dict.keys():
            for i in app_id_items_dict[app_id]:
                obj = {}
                obj["rep_name"] = rep_identifier_name_dict[i.rep_identifier]
                obj["customer_name"] = app_id_cust_name_dict[i.field_app_identifier]
                obj["deadline"] = str(i.deadline).split(" ")[0]
                obj["items"] = json.loads(i.data)

                if not obj["rep_name"] in ret.keys():
                    ret[obj["rep_name"]] = []
                ret[obj["rep_name"]].append(obj)

        self.response.out.write(json.dumps(ret))        

    elif self.request.get("fn") == "drop_expired_assistance_items":
        expired_items = RepAssistance.query(RepAssistance.deadline <= Helpers.pacific_now())
        for item in expired_items:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == item.field_app_identifier)
            if not app_entry is None:
                Helpers.save_me_state(app_entry, "There were too many outstanding items that required rep assistance")
                item.key.delete()

    elif self.request.get("fn") == "drop_assistance_item":
        item = RepAssistance.first(RepAssistance.identifier == self.request.get("identifier"))
        if not item is None:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == item.field_app_identifier)
            if not app_entry is None:
                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not rep is None:
                    pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == app_entry.identifier)
                    if not pp_sub is None:
                        deserialized = json.loads(pp_sub.extra_info)
                        if "project_manager" in deserialized.keys():
                            pm = FieldApplicationUser.first(FieldApplicationUser.identifier == deserialized["project_manager"])
                            if not pm is None:
                                rep_name = rep.first_name.strip().title() + " "  + rep.last_name.strip().title()
                                cust_name = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                                subject = "Following Up - " + cust_name
                                Helpers.send_email(pm.rep_email, subject, rep_name + " has marked the outstanding items as complete for " + cust_name + ",\n\nMessage:\n\n" + self.request.get("msg"))
                                item.key.delete()

    elif self.request.get("fn") == "get_pm_details_for_customer":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        e_i = json.loads(pp_sub.extra_info)
        rep_assist_data = []
        rep_assist_deadline = None
        rep_assist = RepAssistance.first(RepAssistance.field_app_identifier == self.request.get("identifier"))
        if not rep_assist is None:
            rep_assist_data = json.loads(rep_assist.data)
            rep_assist_deadline = str(rep_assist.deadline.date())

        is_unassigned = (not "project_manager" in e_i.keys())        

        pricing_structures = Helpers.get_pricing_structures()
        included_checkoffs = Helpers.read_setting("project_management_additional_checkoffs")
        qualified_checkoffs = []
        funds = Helpers.list_funds()

        identifier = self.request.get("identifier")
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["missing_docs"] = "n/a"
        missing_docs_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "missing_docs_" + identifier)
        if not missing_docs_kv is None:
            ret_json["missing_docs"] = missing_docs_kv.val
        ret_json["panels"] = Helpers.read_setting("system_options")
        ret_json["panels"] = ret_json["panels"]["panels"]
        ret_json["funds"] = funds
        ret_json["jurisdictions"] = Helpers.read_setting("permitting_jurisdictions")
        ret_json["survey_details"] = None
        ret_json["solar_pro"] = "N/A"
        ret_json["rep_assistance_items"] = rep_assist_data
        ret_json["rep_assistance_deadline"] = rep_assist_deadline

        sdetails = SurveyDetails.first(SurveyDetails.field_app_identifier == identifier)
        if not sdetails is None:
            ret_json["survey_details"] = json.loads(sdetails.info)
        save_me_reason = "n/a"
        #scales = Helpers.list_payscales()

        closing_note_kv = KeyValueStoreItem.first(
            KeyValueStoreItem.keyy == "closing_notes_for_" + identifier
        )
        ret_json["closing_notes"] = None
        if not closing_note_kv is None:
            ret_json["closing_notes"] = closing_note_kv.val

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)

        ret_json["panel_quantity_reduced"] = False

        pre_prop_info = json.loads(proposal.info)
        if "panel_qty_override" in pre_prop_info.keys():
            if pre_prop_info["panel_qty_override"]:
                ret_json["panel_quantity_reduced"] = True
        proposal.fix_system_size()
        proposal.fix_additional_amount()
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
        entity_tally = 0
        for item in [app_entry, pp_sub, proposal, booking]:
            entity_tally += int(not item is None)

        ret_json["entity_tally"] = entity_tally
        if entity_tally == 4:
            ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
            if not ol is None:
                market = OfficeLocation.first(OfficeLocation.identifier == ol.parent_identifier)
                if not market is None:
                    market_identifier = market.identifier
                    for checkoff in included_checkoffs:                
                        fn = Helpers.compile_document_formula(checkoff["formula"])
                        if fn["fn"](app_entry, booking, proposal, market):
                            qualified_checkoffs.append({"value": checkoff["value"], "value_friendly": checkoff["value_friendly"], "appears_after": checkoff["appears_after"]})

            if not app_entry.lead_generator == "-1":
                solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                if not solar_pro is None:
                    ret_json["solar_pro"] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()
            save_me_reason = app_entry.save_me_reason
            ret_json["qualified_checkoffs"] = qualified_checkoffs                            
            ret_json["identifier"] = app_entry.identifier
            ret_json["customer_first_name"] = app_entry.customer_first_name.strip().title()
            ret_json["customer_last_name"] = app_entry.customer_last_name.strip().title()
            ret_json["customer_address"] = app_entry.customer_address
            ret_json["customer_city"] = app_entry.customer_city
            ret_json["customer_state"] = app_entry.customer_state
            ret_json["customer_postal"] = app_entry.customer_postal
            ret_json["customer_email"] = app_entry.customer_email
            ret_json["customer_phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            ret_json["tier_option"] = app_entry.tier_option
            ret_json["customer_utility_account_number"] = app_entry.customer_utility_account_number
            ret_json["meter_number"] = "n/a"
            ret_json["notes"] = []
            ret_json["project_managers"] = Helpers.read_setting("project_managers")
            ret_json["electricians"] = Helpers.read_setting("electricians")
            ret_json["utility_provider"] = app_entry.utility_provider
            if ret_json["tier_option"].lower() == "n/a":
                ret_json["tier_option"] = "A"

            ret_json["signed_date"] = str(date(1970, 1, 1))
            ret_json["welcome_call_date"] = str(date(1970, 1, 1))
            kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_signature_" + app_entry.identifier)
            if not kv_item is None:
                ret_json["signed_date"] = str(kv_item.modified.date())
                ret_json["welcome_call_date"] = str(Helpers.next_business_days(kv_item.modified.date(), 4))

            kv_item2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "SDGE_meter_number_" + app_entry.identifier)
            if not kv_item2 is None:
                ret_json["meter_number"] = kv_item2.val

            ret_json["fund"] = booking.fund

            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:
                ret_json["rep"] = {}
                ret_json["rep"]["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
                ret_json["rep"]["phone"] = Helpers.format_phone_number(rep.rep_phone)
                ret_json["rep"]["email"] = rep.rep_email
                                
            info = json.loads(pp_sub.extra_info)
            if not "project_management_specifics" in info.keys():
                info["project_management_specifics"] = {}
                pp_sub.extra_info = json.dumps(info)
                pp_sub.put()

            if "closer" in info.keys():
                closer = FieldApplicationUser.first(FieldApplicationUser.identifier == info["closer"])
                if not closer is None:
                    ret_json["closer"] = {}
                    ret_json["closer"]["name"] = closer.first_name.strip().title() + " " + closer.last_name.strip().title()
                    ret_json["closer"]["phone"] = Helpers.format_phone_number(closer.rep_phone)
                    ret_json["closer"]["email"] = closer.rep_email

            ret_json["confirmed_attorney_involvement_name"] = ""
            if Helpers.gcs_file_exists("/PowerOfAttorney/ConfirmedName/" + self.request.get("identifier") + ".txt") and is_unassigned:
                f9 = GCSLockedFile("/PowerOfAttorney/ConfirmedName/" + self.request.get("identifier") + ".txt")                
                ret_json["confirmed_attorney_involvement_name"] = f9.read()
                f9.unlock()

            ret_json["initial_promises_yn"] = "n/a"
            if Helpers.gcs_file_exists("/InitialPromises/YN/" + self.request.get("identifier") + "/value.txt") and is_unassigned:
                f99 = GCSLockedFile("/InitialPromises/YN/" + self.request.get("identifier") + "/value.txt")
                ret_json["initial_promises_yn"] = f99.read()
                f99.unlock()

            ret_json["unassigned_bulk"] = {}
            if Helpers.gcs_file_exists("/UnassignedBulk3/" + self.request.get("identifier") + "/value.json") and is_unassigned:                
                f100 = GCSLockedFile("/UnassignedBulk3/" + self.request.get("identifier") + "/value.json")
                ret_json["unassigned_bulk"] = json.loads(f100.read())
                f100.unlock()

            ret_json["wc_notes_ta"] = ""
            if Helpers.gcs_file_exists("/WCTANotes/" + self.request.get("identifier") + "/value.txt") and is_unassigned:
                f97 = GCSLockedFile("/WCTANotes/" + self.request.get("identifier") + "/value.txt")
                ret_json["wc_notes_ta"] = f97.read()
                f97.unlock()

            ret_json["power_of_attorney_involvement"] = "n/a"
            if Helpers.gcs_file_exists("/PowerOfAttorney/Involvement/" + self.request.get("identifier") + ".txt") and is_unassigned:
                f5 = GCSLockedFile("/PowerOfAttorney/Involvement/" + self.request.get("identifier") + ".txt")
                ret_json["power_of_attorney_involvement"] = f5.read()
                f5.unlock()

            ret_json["power_of_attorney_yn"] = "n/a"
            if Helpers.gcs_file_exists("/PowerOfAttorney/YesOrNo/" + self.request.get("identifier") + ".txt") and is_unassigned:
                f3 = GCSLockedFile("/PowerOfAttorney/YesOrNo/" + self.request.get("identifier") + ".txt")
                ret_json["power_of_attorney_yn"] = f3.read()
                f3.unlock()

            ret_json["grandpa_details"] = ""
            if Helpers.gcs_file_exists("/Grandpa/Details/" + self.request.get("identifier") + ".txt") and is_unassigned:                
                grandpa_file = GCSLockedFile("/Grandpa/Details/" + self.request.get("identifier") + ".txt")
                ret_json["grandpa_details"] = grandpa_file.read()
                grandpa_file.unlock()

            ret_json["v3_questions_wc_script"] = {}
            if Helpers.gcs_file_exists("/SPV3Questions/" + self.request.get("identifier") + ".json") and is_unassigned:
                v3_gf = GCSLockedFile("/SPV3Questions/" + self.request.get("identifier") + ".json")
                ret_json["v3_questions_wc_script"] = json.loads(v3_gf.read())
                v3_gf.unlock()

            ret_json["v4_questions_wc_script"] = {}
            if Helpers.gcs_file_exists("/SPV4Questions/" + self.request.get("identifier") + ".json") and is_unassigned:
                v4_gf = GCSLockedFile("/SPV4Questions/" + self.request.get("identifier") + ".json")
                ret_json["v4_questions_wc_script"] = json.loads(v4_gf.read())
                v4_gf.unlock()

            ret_json["roof_age_estimation"] = ""
            if Helpers.gcs_file_exists("/RoofAgeEstimations/" + self.request.get("identifier") + "/estimation.txt") and is_unassigned:
                age_file = GCSLockedFile("/RoofAgeEstimations/" + self.request.get("identifier") + "/estimation.txt")
                ret_json["roof_age_estimation"] = age_file.read()
                age_file.unlock()

            ret_json["story_count"] = ""
            if Helpers.gcs_file_exists("/StoryEstimations/" + self.request.get("identifier") + "/estimation.txt") and is_unassigned:
                story_f = GCSLockedFile("/StoryEstimations/" + self.request.get("identifier") + "/estimation.txt")
                ret_json["story_count"] = story_f.read()
                story_f.unlock()

            ret_json["year_home_was_built_estimation"] = ""
            if Helpers.gcs_file_exists("/Estimations/YearHomeWasBuilt/" + self.request.get("identifier") + "/estimation.txt") and is_unassigned:
                year_f = GCSLockedFile("/Estimations/YearHomeWasBuilt/" + self.request.get("identifier") + "/estimation.txt")
                ret_json["year_home_was_built_estimation"] = year_f.read()
                year_f.unlock()

            ret_json["unassigned_lock_value"] = "n/a"
            if Helpers.gcs_file_exists("/UnassignedLock/" + self.request.get("identifier" + "/value.txt")) and is_unassigned:
                ls_f = GCSLockedFile("/UnassignedLock/" + self.request.get("identifier" + "/value.txt"))
                ret_json["unassigned_lock_value"] = ls_f.read()
                ls_f.unlock()

            ret_json["smoke_details"] = ""
            if Helpers.gcs_file_exists("/SmokeDetection/" + self.request.get("identifier") + "/details.txt") and is_unassigned:
                sd_f = GCSLockedFile("/SmokeDetection/" + self.request.get("identifier") + "/details.txt")
                ret_json["smoke_details"] = sd_f.read()
                sd_f.unlock()

            ret_json["hoa_affirmation_choice"] = "n/a"
            if Helpers.gcs_file_exists("/HOA/affirmation/" + self.request.get("identifier") + "/value.txt") and is_unassigned:
                hoa_f = GCSLockedFile("/HOA/affirmation/" + self.request.get("identifier") + "/value.txt")
                ret_json["hoa_affirmation_choice"] = hoa_f.read()
                hoa_f.unlock()

            ret_json["smoke_affirmation"] = "n/a"
            if Helpers.gcs_file_exists("/SmokeDetection/" + self.request.get("identifier") + "/smoke.txt") and is_unassigned:
                s_f = GCSLockedFile("/SmokeDetection/" + self.request.get("identifier") + "/smoke.txt")
                ret_json["smoke_affirmation"] = s_f.read()
                s_f.unlock()

            ret_json["hoa_details_unassigned"] = ""
            if Helpers.gcs_file_exists("/HOA/details/" + self.request.get("identifier") + "_details.txt") and is_unassigned:
                hoa_f2 = GCSLockedFile("/HOA/details/" + self.request.get("identifier") + "_details.txt")
                ret_json["hoa_details_unassigned"] = hoa_f2.read()
                hoa_f2.unlock()

            ret_json["grandpa_choice"] = "n/a"
            if Helpers.gcs_file_exists("Grandpa/YesOrNo/" + self.request.get("identifier") + ".txt") and is_unassigned:
                g_f = GCSLockedFile("Grandpa/YesOrNo/" + self.request.get("identifier") + ".txt")                
                ret_json["grandpa_choice"] = g_f.read()
                g_f.unlock()

            ret_json["promises_data"] = ""
            if Helpers.gcs_file_exists("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/value.txt") and is_unassigned:
                p_f = GCSLockedFile("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/value.txt")
                ret_json["promises_data"] = p_f.read()
                p_f.unlock()

            ret_json["promises_yn"] = "n/a"
            if Helpers.gcs_file_exists("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/promise.txt") and is_unassigned:
                p_f = GCSLockedFile("/PowerOfAttorney/Promises/" + self.request.get("identifier") + "/promise.txt")
                ret_json["promises_yn"] = p_f.read()
                p_f.unlock()

            ret_json["phone_incentive"] = ""
            if Helpers.gcs_file_exists("/PhoneCallIncentiveChoice/" + self.request.get("identifier") + ".txt") and is_unassigned:
                phone_incentivie_f = GCSLockedFile("/PhoneCallIncentiveChoice/" + self.request.get("identifier") + ".txt")
                ret_json["phone_incentive"] = phone_incentivie_f.read()
                phone_incentivie_f.unlock()

            ret_json["attorney_details"] = ""
            if Helpers.gcs_file_exists("/PowerOfAttorney/Details/" + self.request.get("identifier") + ".txt") and is_unassigned:
                f2 = GCSLockedFile("/PowerOfAttorney/Details/" + self.request.get("identifier") + ".txt")
                ret_json["attorney_details"] = f2.read()
                f2.unlock()

            ret_json["attorney_affirmation_y_n"] = "n/a"
            if Helpers.gcs_file_exists("/PowerOfAttorneyConfirmation/YesOrNo/" + self.request.get("identifier") + ".txt") and is_unassigned:
                f3 = GCSLockedFile("/PowerOfAttorneyConfirmation/YesOrNo/" + self.request.get("identifier") + ".txt")
                ret_json["attorney_affirmation_y_n"] = f3.read()
                f3.unlock()

            ret_json["initial_promises_details"] = ""
            if Helpers.gcs_file_exists("/InitialPromises/" + self.request.get("identifier") + "/value.txt") and is_unassigned:
                f33 = GCSLockedFile("/InitialPromises/" + self.request.get("identifier") + "/value.txt")
                ret_json["initial_promises_details"] = f33.read()
                f33.unlock()

            specifics = info["project_management_specifics"]
            ret_json["greensky_amount_verification"] = "0"
            ret_json["greensky_amount_correct"] = "0"
            ret_json["roof_work_needed_v2"] = "-1"
            ret_json["new_layout_needed"] = "0"
            ret_json["commission_reviewed"] = "0"
            ret_json["verified_by"] = "Not Yet Verified"
            ret_json["electrical"] = None
            ret_json["permit_number"] = "n/a"
            ret_json["permit_history"] = []
            if "project_manager" in info.keys():
                pee_m = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                if not pee_m is None:
                    ret_json["pm"] = {"name": pee_m.first_name.strip().title() + " " + pee_m.last_name.strip().title(), "phone": pee_m.rep_phone, "email": pee_m.rep_email, "identifier": pee_m.identifier}


            ret_json["project_management_checkoffs"] = {}
            ret_json["extra_project_specifics"] = []

            if "project_management_checkoffs" in info.keys():
                ret_json["project_management_checkoffs"] = info["project_management_checkoffs"]
            if "extra_project_specifics" in info.keys():
                ret_json["extra_project_specifics"] = info["extra_project_specifics"]

            ret_json["s_keys"] = specifics.keys()
            if "welcome_call_date" in specifics.keys():
                ret_json["welcome_call_date"] = specifics["welcome_call_date"]
            if "signed_date" in specifics.keys():
                ret_json["signed_date"] = specifics["signed_date"]

            if "greensky_amount_verification" in specifics.keys():
                ret_json["greensky_amount_verification"] = specifics["greensky_amount_verification"]
            if "greensky_amount_correct" in specifics.keys():
                ret_json["greensky_amount_correct"] = specifics["greensky_amount_correct"]

            if "roof_work_needed_v2" in specifics.keys():
                ret_json["roof_work_needed_v2"] = specifics["roof_work_needed_v2"]
            if "new_layout_needed" in specifics.keys():
                ret_json["new_layout_needed"] = specifics["new_layout_needed"]
            if "commission_reviewed" in specifics.keys():
                ret_json["commission_reviewed"] = specifics["commission_reviewed"]

            if "jurisdiction" in specifics.keys():
                ret_json["jurisdiction"] = specifics["jurisdiction"]
            if "verified_by" in specifics.keys():
                ret_json["verified_by"] = specifics["verified_by"]
            if "electrical" in specifics.keys():
                ret_json["electrical"] = specifics["electrical"]
            if "permit_number" in specifics.keys():
                ret_json["permit_number"] = specifics["permit_number"]
            if "permit_history" in specifics.keys():
                ret_json["permit_history"] = specifics["permit_history"]

            ret_json["proposal"] = json.loads(proposal.info)

            ret_json["total_system_cost"] = Helpers.crunch("fx_Total_System_Cost", market_identifier, app_entry, booking, ret_json["proposal"], pricing_structures, funds)
            ret_json["last_system_cost_signed"] = "Unknown"
            sys_cost_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "total_system_cost_" + self.request.get("identifier"))
            if not sys_cost_kv is None:
                ret_json["last_system_cost_signed"] = Helpers.currency_format(float(sys_cost_kv.val))
            roofing_cost_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "confirmed_roof_work_numbers_" + self.request.get("identifier"))
            if not roofing_cost_kv is None:
                roofing_data = json.loads(roofing_cost_kv.val)
                try:
                    amt11 = float(roofing_data["fund_one_cost"].replace("$", "").replace(",", ""))
                    amt22 = float(roofing_data["fund_two_cost"].replace("$", "").replace(",", ""))
                    amt33 = amt11 + amt22
                    ret_json["last_system_cost_signed"] = Helpers.currency_format(amt33)
                except:
                    l = 5
                
            ret_json["commission_deduction"] = Helpers.crunch("fx_Commission_Deduction", market_identifier, app_entry, booking, ret_json["proposal"], pricing_structures, funds)
            ret_json["gs_incentive"] = 0.3 * ret_json["total_system_cost"] * 0.0042 * 2
            ret_json["commission_options"] = {}
            if market_identifier in pricing_structures.keys():
                if "baseline_commission" in pricing_structures[market_identifier].keys():
                    ret_json["commission_options"]["A"] = str(pricing_structures[market_identifier]["baseline_commission"])

                for aaa in ["B", "C", "D", "E"]:
                    tier_key = "commission_tier_" + aaa.lower()
                    if tier_key in pricing_structures[market_identifier].keys():
                        ret_json["commission_options"][aaa] = str(pricing_structures[market_identifier][tier_key])

            ret_json["commission_option"] = app_entry.tier_option.replace("tier_", "").upper()
            services_list = []
            services = Helpers.read_setting("services_schedule")
            service_price_dict = {}
            service_name_dict = {}
            for svc in services:
                service_price_dict[svc["value"]] = float(svc["price"])
                service_name_dict[svc["value"]] = svc["value_friendly"]

            prop_info = json.loads(proposal.info)
            if "additional_svcs" in prop_info.keys():
                for s in prop_info["additional_svcs"]:
                    if s["value"] in service_price_dict.keys():
                        services_list.append({"price": service_price_dict[s["value"]], "name": service_name_dict[s["value"]]})

            ret_json["tree_notes"] = None
            if "trees_need_cut" in prop_info.keys():
                if prop_info["trees_need_cut"] == "Yes":
                    ret_json["tree_notes"] = prop_info["tree_cut_details"]

            notes = CustomerNote.query(
                ndb.AND
                (
                    CustomerNote.field_app_identifier == app_entry.identifier,
                    CustomerNote.note_key == "panel_work"
                )
            )
            if not (save_me_reason == "n/a"):
                ret_json["notes"] = ["Save me reason: " + save_me_reason]

            note_cnt = 0
            notes_cpy = []
            if len(services_list) > 0:
                notes_cnt = 1
                svc_str = "Additional Services Ordered: "
                svc_sub = float(0)
                for s in services_list:
                    svc_str += s["name"] + " @ " + Helpers.currency_format(s["price"]) + ". "
                    svc_sub += s["price"]
                svc_str = svc_str.strip()
                ret_json["notes"].append(svc_str)
                ret_json["notes"].append("Total Additional Services Amount: " + Helpers.currency_format(svc_sub) + ".")

            for note in notes:
                notes_cpy.append(note)
            notes_cpy = Helpers.bubble_sort(notes_cpy, "inserted_utc")

            ret_json["notes_idx_identifier_map"] = {}

            if not (save_me_reason == "n/a"):
                note_cnt += 1
            
            for note in notes_cpy:
                ret_json["notes"].append(json.loads(note.content)["txt"])
                ret_json["notes_idx_identifier_map"][str(note_cnt)] = note.identifier
                note_cnt += 1
            
            ret_json["to_dos"] = []
            to_dos = ToDoItem.query(ToDoItem.field_app_identifier == self.request.get("identifier"))
            collaborative_identifiers_list = []
            for t in to_dos:
                collaborative = str(int((len(json.loads(t.linked_identifiers)) > 0)))
                linked_identifiers = t.linked_identifiers
                if collaborative == "1":
                    if not linked_identifiers in collaborative_identifiers_list:
                        ret_json["to_dos"].append({"identifier": t.identifier, "field_app_identifier": t.field_app_identifier, "owner": t.owner, "assigner": t.assigner, "name": t.name, "completed": t.completed, "notes": t.notes, "due_dt": str(t.due_dt), "reminder_dt": str(t.reminder_dt), "completed_dt": str(t.completed_dt), "collaborative": collaborative})
                        collaborative_identifiers_list.append(linked_identifiers)
                else:
                    ret_json["to_dos"].append({"identifier": t.identifier, "field_app_identifier": t.field_app_identifier, "owner": t.owner, "assigner": t.assigner, "name": t.name, "completed": t.completed, "notes": t.notes, "due_dt": str(t.due_dt), "reminder_dt": str(t.reminder_dt), "completed_dt": str(t.completed_dt), "collaborative": collaborative})
            
            ret_json["equipment_ordered_email_sent"] = False
            ret_json["equipment_ordered_email_sent_date"] = str(date(1970, 1, 1))
            ret_json["welcome_email_sent"] = False
            ret_json["welcome_email_sent_date"] = str(date(1970, 1, 1))
            ret_json["inspection_passed_email_sent"] = False
            ret_json["inspection_passed_email_sent_date"] = str(date(1970, 1, 1))
            ret_json["pto_received_email_sent"] = False
            ret_json["pto_received_email_sent_date"] = str(date(1970, 1, 1))
            ret_json["install_email_sent"] = False
            ret_json["install_email_sent_date"] = str(date(1970, 1, 1))
            email_keys = ["-1", "equipment_ordered_email_sent_" + self.request.get("identifier"), "welcome_email_sent_" + self.request.get("identifier"), "inspection_passed_email_sent_" + self.request.get("identifier"), "pto_received_email_sent_" + self.request.get("identifier"), "install_email_sent_" + self.request.get("identifier")]
            email_kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(email_keys))
            for email_kv in email_kvs:
                ret_json[email_kv.keyy.replace("_" + identifier, "")] = True

                if not email_kv.val == "1":
                    split_vals = email_kv.val.split("-")
                    key = email_kv.keyy.replace("_" + identifier, "_date")
                    dt = str(date(int(split_vals[0]), int(split_vals[1]), int(split_vals[2])))
                    ret_json[key] = dt

            ret_json["permit_to_city_event_owners"] = json.dumps(["-1"])
            ret_json["final_inspection_event_owners"] = json.dumps(["-1"])
            ret_json["install_event_owners"] = json.dumps(["-1"])

            ret_json["permit_to_city_details"] = "Address:\n " + app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            ret_json["final_inspection_details"] = "Address:\n " + app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            ret_json["install_details"] = "Address:\n " + app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            events = CalendarEvent.query(
                ndb.AND(
                    CalendarEvent.field_app_identifier == self.request.get("identifier"),
                    CalendarEvent.event_key.IN(["permit_to_city", "install", "final_inspection"])
                )
            )
            for ev in events:
                ret_json[ev.event_key + "_event_owners"] = ev.owners
                ret_json[ev.event_key + "_details"] = ev.details

        comm_log_items = CustomerNote.query(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "cust_comm"
            )
        )

        comm_items = []
        comm_ids_to_query = ["-1"]
        comm_response_kv_keys = ["-1"]
        comm_identifier_idx_dict = {}
        for item in comm_log_items:
            obj = {}
            obj["identifier"] = item.identifier
            obj["content"] = json.loads(item.content)["txt"][0]
            obj["timestamp"] = item.inserted_pacific
            obj["type"] = "n/a"
            obj["response"] = "?"
            comm_ids_to_query.append("cust_comm_note_type_" + item.identifier)
            comm_response_kv_keys.append("cust_response_to_note_" + item.identifier)
            comm_identifier_idx_dict[item.identifier] = len(comm_items)
            comm_items.append(obj)

        kv_items5 = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(comm_ids_to_query))
        for kv in kv_items5:
            key_items =  kv.keyy.split("_")
            note_identifier = key_items[len(key_items) - 1]
            idx = comm_identifier_idx_dict[note_identifier]
            comm_items[idx]["type"] = kv.val

        kv_items6 = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(comm_response_kv_keys))
        for kv in kv_items6:
            key_items = kv.keyy.split("_")
            note_identifier = key_items[len(key_items) - 1]
            idx = comm_identifier_idx_dict[note_identifier]
            comm_items[idx]["response"] = ["No", "Yes"][int(kv.val)]

        comm_items = Helpers.bubble_sort(comm_items, "timestamp")
        for item in comm_items:
            ts = str(item["timestamp"])
            if "." in ts:
                ts = ts.split(".")[0]
            item["timestamp"] = ts

        ret_json["comm_items"] = comm_items

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_project_management_item":
        identifier = self.request.get("identifier")
        
        if self.request.get("drop_reroof") == "1":
            roof_item = RoofWorkItem.first(RoofWorkItem.field_app_identifier == self.request.get("identifier"))
            if not roof_item is None:
                roof_item.key.delete()
        
        key = self.request.get("key")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
        if (not app_entry is None) and (not proposal is None) and (not pp_sub is None):
            sub_info = json.loads(pp_sub.extra_info)
            p_info = json.loads(proposal.info)
            if not "project_management_specifics" in sub_info.keys():
                sub_info["project_management_specifics"] = {}

            if key == "project_manager":
                pm2 = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("value"))
                if not pm2 is None:
                    new_note = CustomerNote(
                        identifier=Helpers.guid(),
                        field_app_identifier=pp_sub.field_application_identifier,
                        inserted_pacific=Helpers.pacific_now(),
                        inserted_utc=datetime.now(),
                        author="-1",
                        perms="public",
                        content=json.dumps({"txt": ["This project was assigned to " + pm2.first_name.strip().title() + " " + pm2.last_name.strip().title() + "."]}),
                        blob_count=0,
                        note_key="panel_work",
                        read=True
                    )
                    new_note.put()


            if key == "customer_address":
                app_entry.customer_address = self.request.get("value")
                app_entry.put()
            elif key == "customer_postal":
                app_entry.customer_postal = self.request.get("value")
                app_entry.put()
            elif key == "customer_city":
                app_entry.customer_city = self.request.get("value")
                app_entry.put()
            elif key == "customer_phone":
                app_entry.customer_phone = self.request.get("value")
                app_entry.put()
            elif key == "customer_email":
                digit_cnt = 0
                for char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]:
                    if char in self.request.get("value"):
                        digit_cnt += 1
  
                if digit_cnt < 10:
                    app_entry.customer_email = self.request.get("value")
                app_entry.put()
            elif key == "tier_option":
                usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                if not usr is None:
                    app_entry.tier_option = self.request.get("tier")
                    CustomerTranscriber.transcribe(app_entry, usr, "tier_option_update")
                    app_entry.put()
                app_entry.tier_option = self.request.get("value")
                app_entry.put()
            elif key == "utility_number":
                app_entry.customer_utility_account_number = self.request.get("value")
                app_entry.put()
            elif key == "meter_number":
                meter_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "SDGE_meter_number_" + app_entry.identifier)
                if meter_item is None:
                    meter_item = KeyValueStoreItem(
                        identifier=Helpers.guid(),
                        keyy="SDGE_meter_number_" + app_entry.identifier,
                        expiration=datetime(1970, 1, 1)
                    )
                meter_item.val = self.request.get("value")
                meter_item.put()
            elif key == "offset":
                p_info["offset"] = self.request.get("value")
                proposal.info = json.dumps(p_info)
                proposal.put()
            
            elif key == "electrical":
                electrical_info = json.loads(self.request.get("value"))
                if "electrician" in electrical_info.keys():
                    elecs = Helpers.read_setting("electricians")
                    for elec in elecs:
                        if elec["name"] == electrical_info["electrician"]:
                            electrical_info["electrician"] = elec
                            if electrical_info["panel_work_required"]:
                                elec_email = elec["email"]
                                e_note = electrical_info["electrical_note"]
                                e_note = e_note.replace("\r", "")
                                e_note = e_note.replace("\n", "\r\n")
                                if "project_manager" in sub_info.keys():                                    
                                    pm = FieldApplicationUser.first(FieldApplicationUser.identifier == sub_info["project_manager"])
                                    if not pm is None:
                                        Helpers.send_email(elec_email, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " Electrical Work Update", e_note + "\r\n\r\nProject Manager: " + pm.first_name.strip().title() + " " + pm.last_name.strip().title())
                                else:
                                    Helpers.send_email(elec_email, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " Electrical Work Update", e_note + "\r\n\r\n(Project Manager not yet assigned.)")

                if "attachment_type" in electrical_info.keys():
                    if electrical_info["attachment_type"] == "Other":
                        notification = Notification.first(Notification.action_name == "Other Attachment Type Selected")
                        if not notification is None:
                            for person in notification.notification_list:
                                Helpers.send_email(person.email_address, "Other Attachment Type Selected", "Other attachment type was selected for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())

                        if "project_manager" in sub_info.keys():
                            pm = FieldApplicationUser.first(FieldApplicationUser.identifier == sub_info["project_manager"])
                            if not pm is None:
                                Helpers.send_email(pm.rep_email, "Other Attachment Type Selected", "Other attachment type was selected for customer " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title())


                if electrical_info["panel_work_required"]:
                    #pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
                    #if not pp_sub is None:
                        #info = json.loads(pp_sub.extra_info)
                        #if not "extra_project_specifics" in info.keys():
                            #info["extra_project_specifics"] = []
                        #info["extra_project_specifics"].append({"name": self.request.get("name"), "type": "checkbox", "key": self.request.get("name").lower().replace(" ", "_")})
                        #pp_sub.extra_info = json.dumps(info)
                        #pp_sub.put()

                    items_dict = {}
                    items_dict["MPU"] = [{"name": "Meter Spot Completed", "type": "checkbox", "key": "meter_spot_completed"}, {"name": "MPU Completed", "type": "checkbox", "key": "mpu_completed"}]
                    items_dict["RMA/GMA"] = [{"name": "Meter Spot Completed", "type": "checkbox", "key": "meter_spot_completed"}, {"name": "RMA/GMA Completed", "type": "checkbox", "key": "rma/gma_completed"}]
                    items_dict["Derate"] = [{"name": "Derate Completed", "type": "checkbox", "key": "derate_completed"}]
                    items_dict["Bus Certification"] = [{"name": "Bus Certification Completed", "type": "checkbox", "key": "bus_certification_completed"}]

                    keys_to_delete = ["meter_spot_completed", "mpu_completed", "rma/gma_completed", "derate_completed", "bus_certification_completed"]

                    if not "extra_project_specifics" in sub_info.keys():
                        sub_info["extra_project_specifics"] = []
                    
                    extras_cpy = []
                    for extra_item in sub_info["extra_project_specifics"]:
                        if not extra_item["key"] in keys_to_delete:
                            extras_cpy.append(extra_item)

                    sub_info["extra_project_specifics"] = extras_cpy
                    if electrical_info["pm_panel_work_reqd_extra"] in items_dict.keys():
                        for new_item in items_dict[electrical_info["pm_panel_work_reqd_extra"]]:
                            sub_info["extra_project_specifics"].append(new_item)



                sub_info["project_management_specifics"]["electrical"] = electrical_info
                pp_sub.extra_info = json.dumps(sub_info)
                pp_sub.put()


                notification = Notification.first(Notification.action_name == "Panel Assessment Updated")
                if not notification is None:
                    for person in notification.notification_list:
                        Helpers.send_email(person.email_address, "Panel Assessment Completed", app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s panel assessment was completed")

            elif key == "fund":
                booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
                if not booking is None:
                    usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
                    if not usr is None:
                        booking.fund = self.request.get("value")
                        booking.put()
                        CustomerTranscriber.transcribe(app_entry, usr, "fund_set")

                        funds = Helpers.list_funds()
                        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == booking.field_app_identifier)
                        if not app_entry is None:
                            user2 = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                            if not user2 is None:
                                for f in funds:
                                    if f["value"] == booking.fund:
                                        msg = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s fund has been set to " + f["value_friendly"] + "."
                                        t = "t"#Helpers.send_sms(user2.rep_phone, msg)

            elif key == "permitting":
                permit_info = json.loads(self.request.get("value"))
                sub_info["project_management_specifics"]["permit_number"] = permit_info["permit_number"]
                if not "permit_history" in sub_info["project_management_specifics"].keys():
                    sub_info["project_management_specifics"]["permit_history"] = []
                sub_info["project_management_specifics"]["permit_history"].append({"status": permit_info["permit_status"], "date": permit_info["permit_date"]})
                pp_sub.extra_info = json.dumps(sub_info)
                pp_sub.put()
            elif key == "project_manager":
                if len(str(self.request.get("value"))) == 128:
                    sub_info["project_manager"] = self.request.get("value")
                    pp_sub.extra_info = json.dumps(sub_info)
                    pp_sub.put()

                    app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == pp_sub.field_application_identifier)
                    if not app_entry is None:
                        rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                        if not rep is None:
                            pm = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("value"))
                            if not pm is None:

                                extra_msg = ""
                                p_info = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == pp_sub.field_application_identifier)
                                if not p_info is None:
                                    decoded = json.loads(p_info.info)
                                    if "panel_qty_override" in decoded.keys():                                    
                                        if decoded["panel_qty_override"] == True:
                                            original_qty = int(decoded["panel_qty"])
                                            new_qty = int(decoded["new_panel_qty"])
                                            if new_qty < original_qty:
                                                extra_msg = "\n\nThe panel quantity for this deal was lowered. The original count was " + str(original_qty) + " panels, the new panel count is " + str(new_qty) + "."

                                Helpers.send_email(pm.rep_email, "Field App Update", "You have just been assigned as the project manager for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s account. The rep is " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + ". The audio recording can be found here:\r\n\r\n" + "https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/AudioRecordings/wc/" + pp_sub.field_application_identifier + ".mp3" + extra_msg)
                                Helpers.send_sms(pm.rep_phone, "you are the project manager for " +  app_entry.customer_first_name.strip().lower() + " " + app_entry.customer_last_name.strip().lower() + ", " + rep.first_name.lower() + " " + rep.last_name.lower() + "'s customer." + extra_msg)
                                

                            notification = Notification.first(Notification.action_name == "Project Manager Assigned")
                            if not notification is None:
                                for person in notification.notification_list:
                                    Helpers.send_email(person.email_address, "PM Assignment", app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " => " + pm.first_name.strip().title() + " " + pm.last_name.strip().title())

            elif key == "panel_qty":
                original_panel_qty = p_info["panel_qty"]
                if "new_panel_qty" in p_info.keys():
                    original_panel_qty = p_info["new_panel_qty"]

                original_panel_qty = str(original_panel_qty).replace(",", "").replace("$", "")
                original_panel_qty = float(original_panel_qty)
                original_production = p_info["year_one_production"].replace("$", "").replace(",", "")
                original_production = float(original_production)

                new_production = (original_production * float(self.request.get("value"))) / original_panel_qty
                new_production = int(new_production)
                new_production = str(new_production)              

                p_info["panel_qty"] = self.request.get("value")
                p_info["new_panel_qty"] = self.request.get("value")
                p_type = p_info["panel_type"]
                if "[[[" in p_type:
                    subbed = p_type[p_type.index("[[["):]
                    subbed = subbed.replace("[[[", "").replace("]]]", "")
                    p_info["system_size"] = str((float(subbed) / float(1000)) * float(p_info["panel_qty"]))
                    p_info["year_one_production"] = new_production
                   
                    proposal.info = json.dumps(p_info)
                    proposal.put()

            if key in ["signed_date", "welcome_call_date", "new_layout_needed", "roof_work_needed", "commission_reviewed", "jurisdiction", "verified_by", "greensky_amount_correct", "roof_work_needed_v2"]:
                sub_info["project_management_specifics"][key] = self.request.get("value")
                pp_sub.extra_info = json.dumps(sub_info)
                pp_sub.put()

    elif self.request.get("fn") == "welcome_call_not_complete_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/welcome_call_not_complete", params={})

    

    elif self.request.get("fn") == "set_jurisdiction_for_customer":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if not "project_management_specifics" in info.keys():
                info["project_management_specifics"] = {}
            info["project_management_specifics"]["jurisdiction"] = self.request.get("value")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "get_updated_system_details_info":
        time.sleep(3)
        identifier = self.request.get("identifier")
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
        self.response.content_type = "application/json"
        ret_json = {}

        if (not app_entry is None) and (not proposal is None) and (not booking is None):
            market_identifier = "-1"
            ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
            if not ol is None:
                market_identifier = ol.parent_identifier
            proposal.fix_additional_amount()
            proposal.fix_system_size()
            pricing_structures = Helpers.get_pricing_structures()
            funds = Helpers.list_funds()

            info = json.loads(proposal.info)
            ret_json["total_system_cost"] = Helpers.crunch("fx_Total_System_Cost", market_identifier, app_entry, booking, info, pricing_structures, funds)
            ret_json["system_size"] = info["system_size"]
            ret_json["gs_incentive"] = 0.3 * ret_json["total_system_cost"] * 0.0042 * 2
            ret_json["production"] = info["year_one_production"]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") ==  "notify_calendar_event_owners":
        owners = json.loads(self.request.get("owners"))
        details = self.request.get("details")
        name = self.request.get("name")
        start_time = self.request.get("start_time")
        end_time = self.request.get("end_time")
        if self.request.get("type") == "one_time":
            start_date = self.request.get("start_date")
            end_date = self.request.get("end_date")

            users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(owners))
            for user in users:
                subject = "You were tagged in an event: " + name
                msg = "Start Time: " + start_date + " @ " + start_time + "\n\nEnd Time: " + end_date + " @ " + end_time + "\n\nDetails:\n" + details
                Helpers.send_email(user.rep_email, subject, msg)

        elif self.request.get("type") == "repeated":
            users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(owners))
            for user in users:
                subject = "You were tagged in an event: " + name
                msg = "This event repeats on the following days of the week: " + self.request.get("dow") + "\n\n"
                msg +=  "Start Time: " + start_time + "\n\nEnd Time: " + end_time + "\n\nDetails:\n" + details
                Helpers.send_email(user.rep_email, subject, msg)

    elif self.request.get("fn") == "project_management_item_checkoff":
        deetails = str(self.request.get("details")) + "\n"
        event_owners = json.dumps(["-1"])
        if str(self.request.get("owners")).lower() == "" or str(self.request.get("owners")).lower() == "none":
            event_owners = json.dumps(["-1"])
        else:
            event_owners = self.request.get("owners")
        if len(event_owners) == 0:
            event_owners = json.dumps(["-1"])
        self.response.content_type = "application/json"
        ret_json = {}
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        aa = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if (not pp_sub is None) and (not aa is None) and (not proposal is None):
            proposal.fix_additional_amount()
            proposal.fix_system_size()
            info = json.loads(pp_sub.extra_info)
            prop_info = json.loads(proposal.info)

            if len(deetails) == 1:
                deetails += aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title()
                deetails += "\n"
                deetails += aa.customer_address + "\n" + aa.customer_city + ", " + aa.customer_state + "\n" + aa.customer_postal
                deetails += "\n"
                prop_info = json.loads(proposal.info)
                deetails += "System Size: " + str(prop_info["system_size"]) 
                deetails += "\n"
                p_qty = str(0)
                if "panel_qty" in prop_info.keys():
                    p_qty = str(prop_info["panel_qty"])    
                if "new_panel_qty" in prop_info.keys():
                    p_qty = str(prop_info["new_panel_qty"])
                deetails += "Panels: " + p_qty
                
            if not "project_management_checkoffs" in info.keys():
                info["project_management_checkoffs"] = {}
            checked = (self.request.get("checked") == "1")
            if  self.request.get("key") == "install":                    
                    if not aa is None:
                        rr = FieldApplicationUser.first(
                            ndb.AND
                            (
                                FieldApplicationUser.rep_id == aa.rep_id,
                                FieldApplicationUser.current_status == 0
                            )
                        )
                        if not rr is None:
                            Helpers.send_email(rr.rep_email, "Installation (Re)Scheduled for your customer", aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + "'s installation date has been rescheduled for " + self.request.get("date"))
                            email_dt_vals = self.request.get("date").split("-")

                            notes_str = ""
                            notes = CustomerNote.query(
                                ndb.AND(
                                    CustomerNote.field_app_identifier == self.request.get("identifier"),
                                    CustomerNote.note_key == "panel_work"
                                )
                            )
                            for note in notes:
                                note_list = json.loads(note.content)["txt"]
                                for n in note_list:
                                    notes_str += n
                                    notes_str += "\r\n\r\n"

                            if checked:
                                notification = Notification.first(Notification.action_name == "Installation Completed")
                                if not notification is None:
                                    for person in notification.notification_list:
                                        x = 5
                                        #Helpers.send_email(person.email_address, "Construction Complete for " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title(), "Construction was completed on " + email_dt_vals[1] + "/" + email_dt_vals[2] + "/" + email_dt_vals[0] + ".\r\nNotes:\r\n\r\n" + notes_str)
                            

            if self.request.get("key") == "welcome_email_sent":
                if checked:
                    if not aa is None:
                        subj = "Welcome Call Complete " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title()
                        email_dt_vals = self.request.get("date").split("-")
                        msg = "Welcome Call was completed on "
                        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
                        if not booking is None:
                            signed_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_signature_" + self.request.get("identifier"))
                            if not signed_kv is None:
                                signed_dt_vals = str(signed_kv.modified.date()).split("-")
                                msg = email_dt_vals[1] + "/" + email_dt_vals[2] + "/" + email_dt_vals[0] + ". The contract was signed on " + signed_dt_vals[1] + "/" + signed_dt_vals[2] + "/" + signed_dt_vals[0] + "."
                                msg += "\r\n"
                                msg += "Fund: "
                                funds = Helpers.list_funds()
                                for fund in funds:
                                    if fund["value"] == booking.fund:
                                        msg += fund["value_friendly"]
                                msg += "\r\n"
                                msg += "System Size: "
                                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
                                if not proposal is None:
                                    proposal.fix_additional_amount()
                                    proposal.fix_system_size()
                                    prop_info = json.loads(proposal.info)
                                    msg += str(prop_info["system_size"])
                                    msg += "kW"
                                    msg += "\r\n"
                                    msg += "Commission: "
                                    if aa.tier_option == "A":
                                        msg += "Standard"
                                    else:
                                        msg += "Reduced"
                                    msg += "\r\n"
                                    o_loc = OfficeLocation.first(OfficeLocation.identifier == aa.office_identifier)
                                    if not o_loc is None:
                                        market_key = o_loc.parent_identifier
                                        pricing_structures = Helpers.get_pricing_structures()
                                        msg += "System Cost: " + Helpers.currency_format(float(Helpers.crunch("fx_Total_System_Cost", market_key, aa, booking, prop_info, pricing_structures, funds)))
                                        msg += "\r\n"
                                        watts = float(prop_info["system_size"]) * float(1000)
                                        price_per_watt = float(Helpers.crunch("fx_Total_System_Cost", market_key, aa, booking, prop_info, pricing_structures, funds)) / watts
                                        msg += "Price Per Watt: "
                                        msg += Helpers.currency_format(price_per_watt)
                                        msg += "\r\n"
                                        msg += "Notes:"
                                        msg += "\r\n"
                                        msg += "\r\n"
                                        notes = CustomerNote.query(
                                            ndb.AND(
                                                CustomerNote.field_app_identifier == self.request.get("identifier"),
                                                CustomerNote.note_key == "panel_work"
                                            )
                                        )
                                        for note in notes:
                                            note_list = json.loads(note.content)["txt"]
                                            for n in note_list:
                                                msg += n
                                                msg += "\r\n\r\n"

                                        msg = msg.replace(u'\u202d', u'').replace(u'\u202c', u'').replace(u'\u00A0', u'')
                                        notification = Notification.first(Notification.action_name == "Welcome Call Completed")
                                        if not notification is None:
                                            for person in notification.notification_list:
                                                Helpers.send_email(person.email_address, "Welcome Call Complete " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title(), msg)

            if self.request.get("key") in ["permit_status", "permit_to_city"] and checked:
                notification = Notification.first(Notification.action_name == "Permitting Status Update")
                if not notification is None:
                    for person in notification.notification_list:
                        Helpers.send_email(person.email_address, "Permitting Update",
                                        "The following item for " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + " has been checked:\r\n\r\n" + " ".join(self.request.get("key").split("_")).title())

            if self.request.get("key") == "plan_set_completed" and checked:
                if "project_manager" in info.keys():
                    pm = FieldApplicationUser.first(FieldApplicationUser.identifier == info["project_manager"])
                    if not pm is None:
                        msg = "The plan set for " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + " has been completed."
                        Helpers.send_sms(pm.rep_phone, msg)
                        Helpers.send_email(pm.rep_email, "Plan set completed", msg)

            info["project_management_checkoffs"][self.request.get("key")] = {"checked": checked, "date": self.request.get("date")}
            existing_lb_stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.field_app_identifier == self.request.get("identifier"),
                    LeaderBoardStat.metric_key == "install_completed"
                )
            )
            for existing_lb_stat in existing_lb_stats:
                existing_lb_stat.key.delete()

            dt_vals = self.request.get("date").split("-")
            new_lb_stat = LeaderBoardStat(
                identifier=Helpers.guid(),
                rep_id=aa.rep_id,
                dt=datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), 12, 0, 0),
                metric_key="install_completed",
                office_identifier=aa.office_identifier,
                field_app_identifier=aa.identifier,
                in_bounds=True,
                pin_identifier="-1"
            )
            if checked and (self.request.get("key") == "install"):
                new_lb_stat.put()

                assignerr = "38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c"
                from google.appengine.api import app_identity
                if app_identity.get_application_id() == "npfieldapp":
                    assignerr = "3e9226f571e6bde4aab097e9df3aedb1046a358a31165cb0b21bf082f2153c8cd1b64d1ebdf6754fba5e0ac956aa367e1b5592402064371cebf86965a2f18808"
                ownerr = None
                if "project_manager" in info.keys():
                    ownerr = info["project_manager"]

                if not ownerr is None:
                    check_signatures_todo = ToDoItem(
                        identifier=Helpers.guid(),
                        owner=ownerr,
                        assigner=assignerr,
                        field_app_identifier=pp_sub.field_application_identifier,
                        name="Check installation complete signatures for " + aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title(),
                        completed=False,
                        notes="",
                        completed_dt=datetime(1970, 1, 1),
                        reminder_sent=False,
                        daily_reminder=True,
                        weekly_reminder=False,
                        monthly_reminder=False,
                        linked_identifiers="[]"
                    )

                check_signatures_todo.reminder_dt = Helpers.pacific_now() + timedelta(hours=-48)
                check_signatures_todo.due_dt = Helpers.pacific_now() + timedelta(days=2)

                check_signatures_todo.put()



            if checked and (self.request.get("key") == "plan_set_received"):
                plan_set = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
                if not plan_set is None:
                    plan_set.active = False
                    plan_set.put()

            elif (not checked) and (self.request.get("key") == "plan_set_received"):
                plan_set = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
                if not plan_set is None:
                    plan_set.active = True
                    plan_set.put()

            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()
            ret_json["date"] = self.request.get("date")
            
            if self.request.get("key") in ["install", "welcome_email_sent"]:
                state_key_mapping2 = {"install": "final_payment_requested_received", "welcome_email_sent": "welcome_call_completed"}
                payroll_state = PayrollCustomerState.first(
                    ndb.AND(
                        PayrollCustomerState.field_app_identifier == self.request.get("identifier"),
                        PayrollCustomerState.state_key == state_key_mapping2[self.request.get("key")]
                    )
                )

                if self.request.get("checked") == "1":
                    if payroll_state is None:
                        payroll_state = PayrollCustomerState(
                            identifier=Helpers.guid(),
                            field_app_identifier=self.request.get("identifier"),
                            archived=False,
                            save_me=False
                        )

                    payroll_state.state_key = self.request.get("key")
                    if payroll_state.state_key == "install":
                        payroll_state.state_key = "final_payment_requested_received"
                    if payroll_state.state_key == "welcome_email_sent":
                        payroll_state.state_key = "welcome_call_completed"

                    description_key_mapping = {"welcome_call_completed": "rep_sales_commission_1A", "final_payment_requested_received": "rep_sales_commission_1B"}
                    v2transaction = MonetaryTransactionV2.first(
                        ndb.AND(
                            MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                            MonetaryTransactionV2.description_key == description_key_mapping[payroll_state.state_key]
                        )
                    )
                    if v2transaction is None:
                        payroll_state.put()
                else:
                    if not payroll_state is None:
                        payroll_state.key.delete()

            wc_lb_stat = LeaderBoardStat.first(
                ndb.AND(
                    LeaderBoardStat.metric_key == "wc_complete",
                    LeaderBoardStat.field_app_identifier == self.request.get("identifier")
                )
            )
            if wc_lb_stat is None and checked:
                dt_vals = self.request.get("date").split("-")
                wc_lb_stat_dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                wc_lb_stat = LeaderBoardStat(
                    identifier=Helpers.guid(),
                    dt = wc_lb_stat_dt,
                    field_app_identifier=self.request.get("identifier"),
                    metric_key="wc_complete",
                    office_identifier=aa.office_identifier,
                    rep_id=aa.rep_id,
                    in_bounds=True,
                    pin_identifier="-1"
                )
                wc_lb_stat.put()

            elif (not wc_lb_stat is None) and checked:
                dt_vals = self.request.get("date").split("-")
                wc_lb_stat_dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                wc_lb_stat.dt = wc_lb_stat_dt
                wc_lb_stat.put()

            try_event_modification = True
            dt_vals = self.request.get("date").split("-")
            event_start_dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))

            old_start_dt = None
            old_end_dt = None
            if self.request.get("key") in ["final_inspection", "install", "permit_to_city"]:
                try_event_modification = False
                event_mapping = {"final_inspection": "Final Inspection", "install": "Installation", "permit_to_city": "Permit to City"}
                color_mapping = {"final_inspection": "red", "install": "orange", "permit_to_city": "blue"}
                event = CalendarEvent.first(
                    ndb.AND(
                        CalendarEvent.field_app_identifier == self.request.get("identifier"),
                        CalendarEvent.event_key == self.request.get("key")
                    )
                )
                event_created = False                
                if event is None:
                    event_created = True
                    event = CalendarEvent(
                        identifier=Helpers.guid(),
                        field_app_identifier=self.request.get("identifier"),
                        name=aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + " - " + event_mapping[self.request.get("key")],
                        all_day=True,
                        calendar_key="main",
                        event_key=self.request.get("key"),
                        repeated=False,
                        repeated_days="[]",
                        details=deetails,
                        color=color_mapping[self.request.get("key")],
                        exception_dates="[]",
                        google_series_id="-1",
                        owners=json.dumps(["-1"])
                    )
                    if self.request.get("key") in ["final_inspection", "install", "permit_to_city"]:
                        event.owners = event_owners
                    event.start_dt = event_start_dt
                    event.end_dt = event_start_dt
                    event.details = deetails
                    event.put()
                    from google.appengine.api import taskqueue
                    taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "create_one_time_event"})
                else:
                    old_start_dt = event.start_dt
                    old_end_dt = event.end_dt

                    old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
                    old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)

                    event.start_dt = event_start_dt
                    event.end_dt = event_start_dt
                    event.details = deetails
                    
                    if self.request.get("key") in ["final_inspection", "install", "permit_to_city"]:
                        event.owners = event_owners
                    event.put()

                    from google.appengine.api import taskqueue
                    taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "update_one_time_event", "old_start_dt": old_start_dt_str, "old_end_dt": old_end_dt_str})        

            if try_event_modification:
                event = CalendarEvent.first(
                    ndb.AND(
                        CalendarEvent.field_app_identifier == self.request.get("identifier"),
                        CalendarEvent.event_key == self.request.get("key")
                    )
                )
                if not event is None:
                    old_start_dt = event.start_dt
                    old_end_dt = event.end_dt

                    old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
                    old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)
                    
                    event.start_dt = event_start_dt
                    event.end_dt = event_start_dt
                    event.details = deetails
                    
                    if self.request.get("key") in ["final_inspection", "install", "permit_to_city"]:
                        event.owners = event_owners
                    event.put()
                    
                    from google.appengine.api import taskqueue
                    taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "update_one_time_event", "old_start_dt": old_start_dt_str, "old_end_dt": old_end_dt_str})

            if self.request.get("key") == "install":
                if not aa is None:
                    if not checked:
                        if not self.request.get("date") == "1970-01-1":
                            user2 = FieldApplicationUser.first(FieldApplicationUser.rep_id == aa.rep_id)
                            if not user2 is None:
                                msg = aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + "'s install date has been set to " + self.request.get("date")
                                Helpers.send_sms(user2.rep_phone, msg)
                    else:
                        user2 = FieldApplicationUser.first(FieldApplicationUser.rep_id == aa.rep_id)
                        if not user2 is None:
                            msg = aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + "'s installation has been completed"
                            Helpers.send_sms(user2.rep_phone, msg)

            if self.request.get("key") == "received_pto" and checked:
                user2 = FieldApplicationUser.first(FieldApplicationUser.rep_id == aa.rep_id)
                if not user2 is None:
                    msg = aa.customer_first_name.strip().title() + " " + aa.customer_last_name.strip().title() + " received PTO"
                    Helpers.send_sms(user2.rep_phone, msg)
          
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_additional_pm_todo_item":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if not "extra_project_specifics" in info.keys():
                info["extra_project_specifics"] = []
            info["extra_project_specifics"].append({"name": self.request.get("name"), "type": "checkbox", "key": self.request.get("name").lower().replace(" ", "_")})
            if not "project_management_checkoffs" in info.keys():
                info["project_management_checkoffs"] = {}
            info["project_management_checkoffs"][self.request.get("name").lower().replace(" ", "_")] = {"checked": False, "date": self.request.get("new_dt")}            


            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()
        
        if str(self.request.get("create_event")) == "1":
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                new_dt_vals = self.request.get("new_dt").split("-")                
                start_dt = datetime(int(new_dt_vals[0]), int(new_dt_vals[1]), int(new_dt_vals[2]))
                event = CalendarEvent(
                    identifier=Helpers.guid(),
                    field_app_identifier=self.request.get("identifier"),
                    name=app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " - " + self.request.get("name"),
                    start_dt=start_dt,
                    end_dt=start_dt,
                    all_day=True,
                    calendar_key="main",
                    event_key=self.request.get("name").lower().replace(" ", "_"),
                    repeated=False,
                    repeated_days="[]",
                    details=self.request.get("details"),
                    color=self.request.get("color"),
                    exception_dates="[]",
                    google_series_id="-1",
                    owners=self.request.get("owners")
                )
                event.put()

                from google.appengine.api import taskqueue
                taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "create_one_time_event"})

    elif self.request.get("fn") == "create_one_time_event":
        event_owners = json.dumps(["-1"])
        if (not str(self.request.get("owners")).lower() == "") and (not str(self.request.get("owners")).lower() == ""):
            event_owners = self.request.get("owners")
        if len(event_owners) == 0:
            event_owners = json.dumps(["-1"])
        start_vals1 = self.request.get("start").split(" ")[0]
        start_vals2 = self.request.get("start").split(" ")[1]
        start_days = start_vals1.split("-")
        start_time = start_vals2.split(":")

        start = datetime(int(start_days[0]), int(start_days[1]), int(start_days[2]), int(start_time[0]), int(start_time[1]))

        end_vals1 = self.request.get("end").split(" ")[0]
        end_vals2 = self.request.get("end").split(" ")[1]
        end_days = end_vals1.split("-")
        end_time = end_vals2.split(":")

        end = datetime(int(end_days[0]), int(end_days[1]), int(end_days[2]), int(end_time[0]), int(end_time[1]))



        event = CalendarEvent(
            identifier=Helpers.guid(),
            field_app_identifier=self.request.get("field_app_identifier"),
            name=self.request.get("name"),
            start_dt=start,
            end_dt=end,
            all_day=False,
            calendar_key=self.request.get("key"),
            event_key="custom_event",
            repeated=False,
            repeated_days="[]",
            details=self.request.get("details"),
            color=self.request.get("color"),
            exception_dates="[]",
            google_series_id="-1",
            owners=event_owners
        )
        event.put()
        
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "create_one_time_event"})

    elif self.request.get("fn") == "edit_one_time_event":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            event_owners = json.dumps(["-1"])
            if (not str(self.request.get("owners")).lower() == "") and (not str(self.request.get("owners")).lower() == ""):
                event_owners = self.request.get("owners")
            
            if len(event_owners) == 0:
                event_owners = json.dumps(["-1"])

            old_start_dt = event.start_dt
            old_end_dt = event.end_dt
            start_vals1 = self.request.get("start").split(" ")[0]
            start_vals2 = self.request.get("start").split(" ")[1]
            start_days = start_vals1.split("-")
            start_time = start_vals2.split(":")

            start = datetime(int(start_days[0]), int(start_days[1]), int(start_days[2]), int(start_time[0]), int(start_time[1]))

            end_vals1 = self.request.get("end").split(" ")[0]
            end_vals2 = self.request.get("end").split(" ")[1]
            end_days = end_vals1.split("-")
            end_time = end_vals2.split(":")

            end = datetime(int(end_days[0]), int(end_days[1]), int(end_days[2]), int(end_time[0]), int(end_time[1]))

            event.name = self.request.get("name")
            event.start_dt = start
            event.end_dt = end
            event.details = self.request.get("details")
            event.color = self.request.get("color")
            event.owners = event_owners
            
            event.put()


            old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
            old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)

            from google.appengine.api import taskqueue
            taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "update_one_time_event", "old_start_dt": old_start_dt_str, "old_end_dt": old_end_dt_str})
            
            if (not event.field_app_identifier == "-1"):
                pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == event.field_app_identifier)
                if not pp_sub is None:
                    info = json.loads(pp_sub.extra_info)
                    if "project_management_checkoffs" in info.keys():
                        if event.event_key in info["project_management_checkoffs"].keys():
                            if "date" in info["project_management_checkoffs"][event.event_key].keys():
                                info["project_management_checkoffs"][event.event_key]["date"] = str(event.start_dt.date())
                                pp_sub.extra_info = json.dumps(info)
                                pp_sub.put()
    
    elif self.request.get("fn") == "add_calendar_event_exception":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            exception_dates = json.loads(event.exception_dates)
            exception_dates.append(self.request.get("date"))
            event.exception_dates = json.dumps(exception_dates)
            event.put()

            from google.appengine.api import taskqueue
            taskqueue.add(url="/tq/google_calendar", params={"fn": "update_repeated_event", "identifier": event.identifier})

    elif self.request.get("fn") == "create_repeated_event":
        event_owners = json.dumps(["-1"])
        if (not str(self.request.get("owners")).lower() == "") and (not str(self.request.get("owners")).lower() == ""):
            event_owners = self.request.get("owners")

        if len(event_owners) == 0:
            event_owners = json.dumps(["-1"])

        start_hours = self.request.get("start").split("_")[0]
        start_mins = self.request.get("start").split("_")[1]

        end_hours = self.request.get("end").split("_")[0]
        end_mins = self.request.get("end").split("_")[1]
         
        start = datetime(2000, 1, 1, int(start_hours), int(start_mins))
        end = datetime(2000, 1, 1, int(end_hours), int(end_mins))

        event = CalendarEvent(
            identifier=Helpers.guid(),
            field_app_identifier=self.request.get("field_app_identifier"),
            name=self.request.get("name"),
            start_dt=start,
            end_dt=end,
            all_day=False,
            calendar_key=self.request.get("key"),
            event_key="custom_event_repeated",
            repeated=True,
            repeated_days=self.request.get("dow"),
            details=self.request.get("details"),
            color=self.request.get("color"),
            exception_dates="[]",
            google_series_id="-1",
            owners=event_owners
        )
        event.put()
        
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/google_calendar", params={"fn": "create_repeated_event", "identifier": event.identifier})

    elif self.request.get("fn") == "edit_repeated_event":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            event_owners = json.dumps(["-1"])
            if (not str(self.request.get("owners")).lower() == "") and (not str(self.request.get("owners")).lower() == ""):
                event_owners = self.request.get("owners")

            if len(event_owners) == 0:
                event_owners = json.dumps(["-1"])

            start_hours = self.request.get("start").split("_")[0]
            start_mins = self.request.get("start").split("_")[1]

            end_hours = self.request.get("end").split("_")[0]
            end_mins = self.request.get("end").split("_")[1]
            
            start = datetime(2000, 1, 1, int(start_hours), int(start_mins))
            end = datetime(2000, 1, 1, int(end_hours), int(end_mins))

            event.name = self.request.get("name")
            event.start_dt = start
            event.end_dt = end
            event.repeated_days = self.request.get("dow")
            event.details = self.request.get("details")
            event.color = self.request.get("color")
            event.owners = event_owners
            
            event.put()
            
            from google.appengine.api import taskqueue
            taskqueue.add(url="/tq/google_calendar", params={"identifier": event.identifier, "fn": "update_repeated_event"})

    elif self.request.get("fn") == "remove_permit_history_item_pm":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "project_management_specifics" in info.keys():
                if "permit_history" in info["project_management_specifics"].keys():
                    try:
                        del info["project_management_specifics"]["permit_history"][int(self.request.get("idx"))]
                    except:
                        info = info
                    pp_sub.extra_info = json.dumps(info)
                    pp_sub.put()

    elif self.request.get("fn") == "eric_deronda":
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == "DERO0518")
        data = []
        for app_entry in app_entries:
            obj = {"name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()}
            obj["address"] = app_entry.customer_address
            obj["city"] = app_entry.customer_city
            obj["state"] = app_entry.customer_state
            obj["postal"] = app_entry.customer_postal
            obj["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            data.append(obj)

        self.response.out.write(json.dumps(data))


    elif self.request.get("fn") == "user_office_reassignment":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            old_office = OfficeLocation.first(OfficeLocation.identifier == user.main_office)
            if not old_office is None:
                old_office.purge_yielder(user.identifier)
            user.main_office = self.request.get("office")
            user.put() 

    elif self.request.get("fn") == "get_last_month_and_year":
        now = Helpers.pacific_now()
        this_month = now.month
        month_change = False
        while not month_change:
            now = now + timedelta(days=-1)
            month_change = not (now.month == this_month)

        months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]

        ret_json = {"result": months[now.month - 1] + " " + str(now.year)}
        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))
        

    elif self.request.get("fn") == "get_payroll_tab_details_v3":
        ret_json = {}
        self.response.content_type = "application/json"
        ret_json["Reimbursements"] = []
        ret_json["Payouts"] = []
        ret_json["Construction Complete"] = []

        h_p_n = Helpers.pacific_now()
        while not h_p_n.isoweekday() == 5:
            h_p_n = h_p_n + timedelta(days=1)

        rep_ids_to_query = ["-1"]
        transactions = []
        pending_reimbursements = []
        rep_identifier_rep_name_dict1 = {}
        reimbursements = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.approved == False,
                MonetaryTransactionV2.denied == False
            )
        )
        for r in reimbursements:
            if "reimbursement" in r.description_key:
                total_cents = (r.dollars * 100) + r.cents
                dummy_transaction = (total_cents >= -500 and total_cents <= 25)
                
                if dummy_transaction:
                    r.cents = 0
                    r.dollars = 0

                if not r.recipient in rep_ids_to_query:
                    rep_ids_to_query.append(r.recipient)                
                pending_reimbursements.append(r)
        

        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_rep_name_dict1[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        try:
            v3transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.payout_date == h_p_n.date(),
                    MonetaryTransactionV2.approved == True,
                    MonetaryTransactionV2.denied == False
                )
            )
        except:
            v3transactions = []

        rep_ids_to_query2 = ["-1"]
        transactions = []
        for t in v3transactions:                        
            total_cents = (t.dollars * 100) + t.cents
            dummy_transaction = (total_cents >= -500 and total_cents <= 25)
            
            if dummy_transaction:
                t.cents = 0
                t.dollars = 0


            if not t.recipient in rep_ids_to_query2:
                rep_ids_to_query2.append(t.recipient)
            transactions.append(t)
        
        rep_id_transaction_total_dict = {}     
        rep_id_transaction_tally_dict = {}
        rep_id_reimbursement_total_dict = {}
        reimbursements = []
        for t2 in transactions:
            if not t2.recipient in rep_id_transaction_total_dict.keys():
                rep_id_transaction_total_dict[t2.recipient] = float(0)
            if not t2.recipient in rep_id_transaction_tally_dict.keys():
                rep_id_transaction_tally_dict[t2.recipient] = 0
            if not t2.recipient in rep_id_reimbursement_total_dict.keys():
                rep_id_reimbursement_total_dict[t2.recipient] = float(0)
            
            rep_id_transaction_tally_dict[t2.recipient] += 1
            if not t.recipient in rep_ids_to_query:
                rep_ids_to_query.append(t2.recipient)

            rep_id_transaction_total_dict[t2.recipient] += (float(t2.dollars) + (float(t2.cents) * 0.01)) * float(int(not "reimbursement" in t2.description_key))
            if "reimbursement" in t2.description_key:
                rep_id_reimbursement_total_dict[t2.recipient] += (float(t2.dollars) + (float(t2.cents) * 0.01))

        
        rep_identifier_payouts_idx_dict = {}
        rep_identifier_rep_name_dict2 = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query2))
        for rep in reps:
            item = {}            
            item["date"] = str(h_p_n.date())
            item["debt_items"] = []
            item["identifier"] = rep.identifier
            item["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            item["last_name_lowered"] = rep.last_name.strip().lower()
            item["paid"] = False
            item["reimbursements"] = rep_id_reimbursement_total_dict[rep.identifier]
            item["tally"] = rep_id_transaction_tally_dict[rep.identifier]
            item["total"] = rep_id_transaction_total_dict[rep.identifier]
            item["total_debt"] = float(0)
            rep_identifier_rep_name_dict2[rep.identifier] = item["name"]
            rep_identifier_payouts_idx_dict[rep.identifier] = len(ret_json["Payouts"])
            ret_json["Payouts"].append(item)

        for e in pending_reimbursements:
            item = {}
            item["identifier"] = e.identifier
            item["created"] = e.created
            item["description"] = e.description
            item["amount"] = float(float(e.dollars))
            item["amount"] += float(e.cents) / (float(100))
            item["rep"] = rep_identifier_rep_name_dict1[e.recipient]
            item["recipient"] = e.recipient
            item["extra_info"] = json.loads(e.extra_info)
            ret_json["Reimbursements"].append(item)

        ret_json["Reimbursements"] = Helpers.bubble_sort(ret_json["Reimbursements"], "created")

        for e in ret_json["Reimbursements"]:
            e["created"] = str(e["created"].date())

        debts = UserDebt.query(UserDebt.field_app_identifier.IN(rep_ids_to_query2))
        for debt in debts:
            ret_json["Payouts"][rep_identifier_payouts_idx_dict[debt.field_app_identifier]]["total_debt"] = debt.total
            ret_json["Payouts"][rep_identifier_payouts_idx_dict[debt.field_app_identifier]]["debt_items"] = json.loads(debt.items)


        states = PayrollCustomerStateV3.query()
        for state in states:
            obj = {}
            obj["date"] = "1970-01-01"
            obj["field_app_identifier"] = state.field_app_identifier
            obj["identifier"] = state.identifier
            obj["name_lowered"] = state.customer_first_name.strip() + " " + state.customer_last_name.strip()
            obj["first_name"] = state.customer_first_name.strip().title()
            obj["last_name"] = state.customer_last_name.strip().title()
            obj["name"] = obj["first_name"] + " " + obj["last_name"]
            ret_json["Construction Complete"].append(obj)

        ret_json["Construction Complete"] = Helpers.bubble_sort(ret_json["Construction Complete"], "name_lowered")

        ret_json["Payouts"] = Helpers.bubble_sort(ret_json["Payouts"], "last_name_lowered")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_construction_complete_dates":
        ret_json = []
        self.response.content_type = "application/json"
        identifiers = json.loads(self.request.get("identifiers"))
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(identifiers))
        for pp_sub in pp_subs:
            dt = "1970-01-01"
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "install" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["install"].keys():
                        if info["project_management_checkoffs"]["install"]["checked"]:
                            if "date" in info["project_management_checkoffs"]["install"].keys():
                                dt = info["project_management_checkoffs"]["install"]["date"]

            ret_json.append({"identifier": pp_sub.field_application_identifier, "date": dt})
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_payroll_tab_details":
        ret_json = {}
        self.response.content_type = "application/json"
        ret_json["WC Complete"] = []
        ret_json["Construction Complete"] = []
        ret_json["Reimbursements"] = []
        ret_json["Projects Pending Payout"] = []
        ret_json["Payouts"] = []

        existing_pending_app_identifier = []

        app_ids_to_query = ["-1"]
        payroll_states = PayrollCustomerState.query(
            ndb.AND
            (
                PayrollCustomerState.state_key.IN(["welcome_call_completed", "final_payment_requested_received"]),
                PayrollCustomerState.archived == False,
                PayrollCustomerState.save_me == False
            )
        )
        app_identifier_state_key_dict = {}
        for ps in payroll_states:
            app_ids_to_query.append(ps.field_app_identifier)
            app_identifier_state_key_dict[ps.field_app_identifier] = ps.state_key

        ###
        ###

        app_identifier_info_dict = {}
        app_entries = FieldApplicationEntry.query(
           FieldApplicationEntry.identifier.IN(app_ids_to_query)
        )

        for app_entry in app_entries:
            app_identifier_info_dict[app_entry.identifier] = {"name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), "identifier": app_entry.identifier}


        subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for sub in subs:
            info = json.loads(sub.extra_info)
            date_to_show = None
            is_wc_complete = (app_identifier_state_key_dict[sub.field_application_identifier] == "welcome_call_completed")
            is_construction_complete = (app_identifier_state_key_dict[sub.field_application_identifier] == "final_payment_requested_received")
            if "project_management_checkoffs" in info.keys():
                if "welcome_call_completed" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["welcome_call_completed"].keys():
                        if info["project_management_checkoffs"]["welcome_call_completed"]["checked"]:
                            #is_wc_complete = True
                            date_to_show = info["project_management_checkoffs"]["welcome_call_completed"]["date"]

                if "install" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["install"].keys():
                        if info["project_management_checkoffs"]["install"]["checked"]:
                            #is_construction_complete = True
                            date_to_show = info["project_management_checkoffs"]["install"]["date"]

                if is_construction_complete:
                    obj = app_identifier_info_dict[sub.field_application_identifier]
                    obj["date"] = date_to_show
                    ret_json["Construction Complete"].append(obj)

                elif is_wc_complete:
                    obj = app_identifier_info_dict[sub.field_application_identifier]
                    obj["date"] = date_to_show
                    ret_json["WC Complete"].append(obj)

        h_p_t = Helpers.pacific_today()
        distincts = ["-1"]
        transactions = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.paid == False,
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.denied == False,
                MonetaryTransactionV2.description_key.IN(["closers_bonus_A","closers_bonus_B","rep_sales_commission_1A","rep_sales_commission_1B","commission_miscellaneous_payout_A","commission_miscellaneous_payout_B","construction_complete_mgr_override", "const_complete_override"]),
                MonetaryTransactionV2.payout_date >= h_p_t
            )
        )        
        for t in transactions:

            if "reimbursement" in t.description_key:
                continue

            if not (t.field_app_identifier in distincts):
                distincts.append(t.field_app_identifier)

        pending_payout_identifier_idx_dict = {}
        app_entries2 = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(distincts))
        for app_entry in app_entries2:
            pending_payout_identifier_idx_dict[app_entry.identifier] = len(ret_json["Projects Pending Payout"])
            ret_json["Projects Pending Payout"].append({"name": app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title(), "identifier": app_entry.identifier})

        pp_subs2 = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(distincts))
        for pp_sub in pp_subs2:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "welcome_call_completed" in info["project_management_checkoffs"].keys():
                    if info["project_management_checkoffs"]["welcome_call_completed"]["checked"]:
                        ret_json["Projects Pending Payout"][pending_payout_identifier_idx_dict[pp_sub.field_application_identifier]]["date"] = info["project_management_checkoffs"]["welcome_call_completed"]["date"]
                        ret_json["Projects Pending Payout"][pending_payout_identifier_idx_dict[pp_sub.field_application_identifier]]["step"] = "A"
                    
                if "final_payment_requested_received" in info["project_management_checkoffs"].keys():
                    if info["project_management_checkoffs"]["final_payment_requested_received"]["checked"]:
                        if "install" in info["project_management_checkoffs"].keys():
                            ret_json["Projects Pending Payout"][pending_payout_identifier_idx_dict[pp_sub.field_application_identifier]]["step"] = "B"
                            ret_json["Projects Pending Payout"][pending_payout_identifier_idx_dict[pp_sub.field_application_identifier]]["date"] = info["project_management_checkoffs"]["install"]["date"]

        expenses2 = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.approved == False,
                MonetaryTransactionV2.denied == False
            )
        )
        expenses = []
        rep_ids_to_query2 = []
        for e in expenses2:
            item = {}
            item["identifier"] = e.identifier
            item["created"] = e.created
            item["description"] = e.description
            item["amount"] = float(float(e.dollars))
            item["amount"] += float(e.cents) / (float(100))
            item["rep"] = ""
            item["recipient"] = e.recipient
            item["extra_info"] = json.loads(e.extra_info)
            expenses.append(item)
            rep_ids_to_query2.append(e.recipient)

        expenses = Helpers.bubble_sort(expenses, "created")
        if len(rep_ids_to_query2) > 0:
            reps2 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query2))
            for rep2 in reps2:
                for ee in expenses:
                    if ee["recipient"] == rep2.identifier:
                        ee["rep"] = rep2.first_name + " " + rep2.last_name

        for e in expenses:
            e["created"] = str(e["created"].date())
            ret_json["Reimbursements"].append(e)

        this_friday = Helpers.pacific_today()
        while not (this_friday.isoweekday() == 5):
            this_friday = this_friday + timedelta(days=1)

        transactions3 = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.payout_date == this_friday
            )
        )
        reps_pending_payout = {}
        rep_identifier_payout_total_dict = {}
        rep_identifier_reimbursement_total_dict = {}
        for t in transactions3:
            if not t.recipient in reps_pending_payout.keys():
                reps_pending_payout[t.recipient] = 0
            if not t.recipient in rep_identifier_payout_total_dict.keys():
                rep_identifier_payout_total_dict[t.recipient] = float(0)

            if not t.recipient in rep_identifier_reimbursement_total_dict.keys():
                rep_identifier_reimbursement_total_dict[t.recipient] = float(0)

            is_reimbursement = ("reimbursement" in t.description_key.lower())
            is_not_reimbursement = not is_reimbursement

            reps_pending_payout[t.recipient] += 1
            rep_identifier_payout_total_dict[t.recipient] += (float(t.dollars) * float(int(is_not_reimbursement)))
            rep_identifier_payout_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(is_not_reimbursement)))
            
            rep_identifier_reimbursement_total_dict[t.recipient] += float(t.dollars * int(is_reimbursement))
            rep_identifier_reimbursement_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(is_reimbursement)))

        rep_identifier_idx_dict = {}
        rep_ids_to_query3 = reps_pending_payout.keys()
        if len(rep_ids_to_query3) > 0:
            reps3 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query3))
            for rep3 in reps3:
                item = {}
                item["identifier"] = rep3.identifier
                item["tally"] = reps_pending_payout[rep3.identifier]
                item["date"] = str(this_friday)
                item["total"] = rep_identifier_payout_total_dict[rep3.identifier]
                item["reimbursements"] = rep_identifier_reimbursement_total_dict[rep3.identifier]
                item["name"] = rep3.first_name.strip().title() + " " + rep3.last_name.strip().title()
                item["last_name_lowered"] = rep3.last_name.strip().lower()
                item["paid"] = False
                ret_json["Payouts"].append(item)
                rep_identifier_idx_dict[item["identifier"]] = len(ret_json["Payouts"]) - 1

            debts = UserDebt.query(UserDebt.field_app_identifier.IN(rep_ids_to_query3))
            for debt in debts:
                ret_json["Payouts"][rep_identifier_idx_dict[debt.field_app_identifier]]["total_debt"] = debt.total
                ret_json["Payouts"][rep_identifier_idx_dict[debt.field_app_identifier]]["debt_items"] = json.loads(debt.items)

            checks = CheckPayment.query(
                ndb.AND
                (
                    CheckPayment.check_date == this_friday,
                    CheckPayment.recipient.IN(rep_ids_to_query3)
                )
            )
            for check in checks:
                ret_json["Payouts"][rep_identifier_idx_dict[check.recipient]]["paid"] = True

        ret_json["Payouts"] = Helpers.bubble_sort(ret_json["Payouts"], "last_name_lowered")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "test_deal_points":
        Helpers.get_points_for_deal(CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == "dc73d9a63874c71525c372175289116b2dd8173ae3b78c4fb59510379e1b2ca6fb947ae45c6e7255d9302a6f2b525cd1b343cb70cc6087c726626fe2c7275a1c"))

    
    elif self.request.get("fn") == "auto_archive_ptos":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/auto_archive_ptos", params={})

    elif self.request.get("fn") == "welcome_call_construction_complete_details_v3":
        ret_json = {}
        self.response.content_type = "application/json"
        identifier = self.request.get("identifier")
        rep_identifier = "-1"
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
        pp = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
        include_overrides = True

        o_locations = OfficeLocation.query(OfficeLocation.is_parent == False)

        if (not app_entry is None) and (not booking is None) and (not proposal is None) and (not pp is None):
            market_identifier = "-1"
            ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if (not rep is None) and (not ol is None):
                market_identifier = ol.parent_identifier
                marquet = OfficeLocation.first(OfficeLocation.identifier == market_identifier)
                if not marquet is None:
                    include_overrides = (marquet.residual_overrides == False)
                pricing_structures = Helpers.get_pricing_structures()
                funds = Helpers.list_funds()                

                if app_entry.baseline_price > float(0):
                    ret_json["baseline_price"] = str(app_entry.baseline_price)
                    
                rep_identifier = rep.identifier
                ret_json["rep"] = {"name": rep.first_name.strip().title() + " " + rep.last_name.strip().title(), "identifier": rep.identifier}
                for item in ["customer_address", "customer_postal", "customer_city", "customer_state", "tier_option", "customer_first_name", "customer_last_name"]:
                    ret_json[item] = getattr(app_entry, item)

                ret_json["solar_pro"] = None
                if not app_entry.lead_generator == "-1":
                    solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not solar_pro is None:
                        ret_json["solar_pro"] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

                pp_info = json.loads(pp.extra_info)
                proposal.fix_additional_amount()
                proposal.fix_system_size()

                ret_json["price_per_kw"] = Helpers.crunch("fx_Commission_Price_Per_Kw", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                ret_json["ppa_price_per_kw"] = Helpers.crunch("fx_Commission_Price_Per_Kw_Leaase_PPA", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                ret_json["commission_options"] = {"A": float(0), "B": float(0), "C": float(0), "D": float(0), "E": float(0)}
                #ret_json["cost_per_point"] = round(float(Helpers.read_setting("services_point_cost")), 2)
                #ret_json["deal_points"] = round(Helpers.get_points_for_deal(proposal), 2)
                if market_identifier in pricing_structures.keys():
                    if "baseline_commission" in pricing_structures[market_identifier].keys():
                        ret_json["commission_options"]["A"] = float(pricing_structures[market_identifier]["baseline_commission"])
                    for letter in ["B", "C", "D", "E"]:
                        tier_key = "commission_tier_" + letter.lower()
                        if tier_key in pricing_structures[market_identifier].keys():
                            ret_json["commission_options"][letter] = float(pricing_structures[market_identifier][tier_key])


                ret_json["welcomecalldate"] = str(date(1970, 1, 1))
                try:
                    ret_json["welcomecalldate"] = pp_info["project_management_checkoffs"]["welcome_call_completed"]["date"]
                except:
                    ret_json = ret_json

                ret_json["system_size"] = json.loads(proposal.info)["system_size"]
                ret_json["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
                ret_json["email"] = app_entry.customer_email
                ret_json["fund"] = booking.fund
                ret_json["project_manager"] = {"name": "Unknown", "email": "Unknown", "phone": "Unknown"}
                pm = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_info["project_manager"])
                if not pm is None:
                    ret_json["project_manager"] = {"name": pm.first_name.strip().title() + " " + pm.last_name.strip().title(), "email": pm.rep_email, "phone": pm.rep_phone}
                ret_json["signed_date"] = None
                ret_json["total_system_cost"] = float(0)
                try:                    
                    ret_json["total_system_cost"] = Helpers.crunch("fx_Total_System_Cost", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                except:
                    ret_json = ret_json

                kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_signature_" + app_entry.identifier)
                if not kv_item is None:
                    ret_json["signed_date"] = str(kv_item.modified.date())

                ret_json["greensky_amount_correct"] = False
                ret_json["commission_reviewed"] = False

                if "project_management_specifics" in pp_info.keys():
                    if "greensky_amount_correct" in pp_info["project_management_specifics"].keys():
                        ret_json["greensky_amount_correct"] = (pp_info["project_management_specifics"]["greensky_amount_correct"] == "1")
                    if "commission_reviewed" in pp_info["project_management_specifics"].keys():
                        ret_json["commission_reviewed"] = (pp_info["project_management_specifics"]["commission_reviewed"] == "1")
               
                ret_json["funds"] = funds
                if ret_json["tier_option"] == "n/a":
                    ret_json["tier_option"] = "A"

                ret_json["legacy_overrides"] = []

                h_p_t = Helpers.pacific_today()

                #the legacy overrides

                identifier_to_check = app_entry.lead_generator
                if identifier_to_check == "-1":
                    identifier_to_check = ret_json["rep"]["identifier"]

                override_rep_ids_to_query = ["-1"]
                ret_json["suggested_overrides"] = []
                for o_location in o_locations:
                    override_data = o_location.get_override_data()
                    if identifier_to_check in override_data["yielders"]:
                        if identifier_to_check in override_data["data"].keys():
                            for item in override_data["data"][identifier_to_check]:
                                if float(item["amount"]) > float(0):
                                    fund_name_components = booking.fund.split("_")
                                    multip_factor = 1.0
                                    if "lease" in fund_name_components or "ppa" in fund_name_components:
                                        if market_identifier in pricing_structures.keys():
                                            if "ppa_override_multiplication_factor" in pricing_structures[market_identifier].keys():
                                                multip_factor = float(pricing_structures[market_identifier]["ppa_override_multiplication_factor"])

                                    gross = multip_factor * float(item["amount"]) * float(ret_json["system_size"])
                                    gross = round(gross, 2)
                                    dollarss = int(gross)
                                    centss = gross - dollarss
                                    centss *= 100
                                    centss = int(centss)

                                    descrip = "Legacy override for " + ret_json["rep"]["name"] + " selling a " + str(ret_json["system_size"]) + " KW system to " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ". " + str(multip_factor) + " * " + Helpers.currency_format(float(item["amount"])) + " * " + str(ret_json["system_size"]) + " = " + Helpers.currency_format(gross) + "."

                                    override_obj = {"identifier": item["identifier"], "amount": str(gross), "base_amount": str(float(item["amount"]) * multip_factor), "description_key": "legacy_override", "description": descrip}
                                    if dollarss > 0 or centss > 0:
                                        ret_json["legacy_overrides"].append(override_obj)
                                        if not item["identifier"] in override_rep_ids_to_query:
                                            override_rep_ids_to_query.append(item["identifier"])

                rep_identifier_name_dict = {}
                override_reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(override_rep_ids_to_query))
                for rep in override_reps:
                    rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

                for override in ret_json["legacy_overrides"]:
                    override["recipient_name"] = rep_identifier_name_dict[override["identifier"]]

                # the solar pro commissions and solar pro manager overrides

                ret_json["solar_pro_commissions"] = []
                ret_json["solar_pro_overrides"] = []

                if not (app_entry.lead_generator == "-1"):
                    market_key = market_identifier
                    sp = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not sp is None:
                        per_kw_pay = float(0)
                        base_pay = float(0)

                        manager = (sp.user_type == "solar_pro_manager")
                        if market_key in pricing_structures.keys():
                            base_pay_key = ["solar_pro_flat_amount_per_install", "solar_pro_manager_flat_amount_per_install"][int(manager)]
                            per_kw_key = ["solar_pro_per_kw_amount_per_install", "solar_pro_manager_per_kw_amount_per_install"][int(manager)]

                            if base_pay_key in pricing_structures[market_key].keys():
                                if per_kw_key in pricing_structures[market_key].keys():
                                    per_kw_pay = float(pricing_structures[market_key][per_kw_key].replace("$", "").replace(",", ""))
                                    base_pay = float(pricing_structures[market_key][base_pay_key].replace("$", "").replace(",", ""))

                                    kv1 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "pay_per_install_" + sp.identifier)
                                    if not kv1 is None:
                                        base_pay = float(kv1.val.replace("$", "").replace(",", ""))

                                    kv2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "pay_per_install_per_kw_" + sp.identifier)
                                    if not kv2 is None:
                                        per_kw_pay = float(kv2.val.replace("$", "").replace(",", ""))

                                    gross = base_pay + (per_kw_pay * float(ret_json["system_size"]))
                                    gross = round(gross, 2)
                                    dollarss = int(gross)
                                    centss = gross - dollarss
                                    centss *= 100
                                    centss = int(centss)

                                    descrip = "Commission for " + ret_json["rep"]["name"] + " selling a " + str(ret_json["system_size"]) + " system to " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "."
                                    descrip += " A flat amount of " + Helpers.currency_format(base_pay) + " is awarded."
                                    if per_kw_pay > float(0):
                                        descrip += " An additional per KW bonus of " + Helpers.currency_format(per_kw_pay) + " is added."
                                        descrip += " " + str(per_kw_pay) + " * " + str(ret_json["system_size"]) + " = " + Helpers.currency_format(per_kw_pay * float(ret_json["system_size"])) + "."

                                    if dollarss > 0 or centss > 0:
                                        obj = {"identifier": sp.identifier, "recipient_name": sp.first_name.strip().title() + " " + sp.last_name.strip().title(), "amount": str(gross), "description_key": "solar_pro_sales_commission", "description": descrip}
                                        ret_json["solar_pro_commissions"].append(obj)

                        managers = FieldApplicationUser.query(
                            ndb.AND(
                                FieldApplicationUser.user_type == "solar_pro_manager",
                                FieldApplicationUser.current_status == 0,
                                FieldApplicationUser.main_office == app_entry.office_identifier
                            )
                        )

                        sp_managers = []
                        for manager in managers:
                            sp_managers.append({"identifier": manager.identifier, "name": manager.first_name.strip().title() + " " + manager.last_name.strip().title()})

                        if len(sp_managers) > 0:
                            if market_key in pricing_structures.keys():
                                if "solar_pro_managers_override_amount" in pricing_structures[market_identifier].keys():
                                    descrip = "SP Manager override for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s install. "
                                    
                                    amount = pricing_structures[market_identifier]["solar_pro_managers_override_amount"]
                                    amount = amount.replace("$", "")
                                    amount = amount.replace(",", "")
                                    amount = float(amount)

                                    gross = amount / float(len(sp_managers))
                                    gross = round(gross, 2)
                                    dollarss = int(gross)
                                    centss = gross - dollarss
                                    centss *= 100
                                    centss = int(centss)

                                    descrip += "An amount of " + Helpers.currency_format(amount) + " is divided into " + str(len(sp_managers)) + " equal part(s) amongst ("
                                    names = []
                                    for item in sp_managers:
                                        names.append(item["name"])
                                    descrip += (", ".join(names))
                                    descrip += ")."
                                    descrip += " Amount is " + Helpers.currency_format(gross)
                                    descrip += "."

                                    for manager in sp_managers:
                                        obj = {"identifier": manager["identifier"], "recipient_name": manager["name"], "amount": str(gross), "description_key": "solar_pro_manager_override", "description": descrip}
                                        ret_json["solar_pro_overrides"].append(obj)

                #the energy expert/sales manager commissions
                ret_json["rep_commissions"] = []
                rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
                if not rep is None:
                    user_type = rep.user_type

                o_location = OfficeLocation.first(OfficeLocation.identifier == rep.main_office)
                if not o_location is None:
                    market_key = o_location.parent_identifier

                    per_kw_amount = str(0)

                    if user_type == "energy_expert":
                        if app_entry.lead_generator == "-1":
                            if market_key in pricing_structures.keys():
                                if "energy_expert_self_gen_commission_per_kw" in pricing_structures[market_key].keys():
                                    per_kw_amount = str(pricing_structures[market_key]["energy_expert_self_gen_commission_per_kw"]).replace("$", "").replace(",", "")
                                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commission_per_self_gen_sale_" + rep.identifier)
                                    if not kv is None:
                                        per_kw_amount = str(kv.val).replace("$", "").replace(",", "")
                        else:
                            if market_key in pricing_structures.keys():
                                if "energy_expert_commission_per_kw" in pricing_structures[market_key].keys():
                                    per_kw_amount = str(pricing_structures[market_key]["energy_expert_commission_per_kw"]).replace("$", "").replace(",", "")
                                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commission_per_lead_sale_" + rep.identifier)
                                    if not kv is None:
                                        per_kw_amount = str(kv.val).replace("$", "").replace(",", "")

                    elif user_type == "sales_manager":
                        if app_entry.lead_generator == "-1":
                            if market_key in pricing_structures.keys():
                                if "sales_manager_self_gen_commission_per_kw" in pricing_structures[market_key].keys():
                                    per_kw_amount = str(pricing_structures[market_key]["sales_manager_self_gen_commission_per_kw"]).replace("$", "").replace(",", "")
                                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commission_per_self_gen_sale_" + rep.identifier)
                                    if not kv is None:
                                        per_kw_amount = str(kv.val).replace("$", "").replace(",", "")
                        else:
                            if market_key in pricing_structures.keys():
                                if "sales_manager_commission_per_kw" in pricing_structures[market_key].keys():
                                    per_kw_amount = str(pricing_structures[market_key]["sales_manager_commission_per_kw"]).replace("$", "").replace(",", "")
                                    kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commission_per_lead_sale_" + rep.identifier)
                                    if not kv is None:
                                        per_kw_amount = str(kv.val).replace("$", "").replace(",", "")

                    fund_name_components = booking.fund.split("_")
                    if "ppa" in fund_name_components or "lease" in fund_name_components:
                        per_kw_amount = "0"
                        if market_key in pricing_structures.keys():
                            if "ppa_commission" in pricing_structures[market_key].keys():
                                per_kw_amount = str(pricing_structures[market_key]["ppa_commission"]).replace("$", "").replace(",", "")

                    per_kw_amount = float(per_kw_amount)

                    tier_option = app_entry.tier_option.lower()
                    if not tier_option == "a":
                        if market_key in pricing_structures.keys():
                            if "commission_tier_" + tier_option in pricing_structures[market_key].keys():
                                parsed = float(pricing_structures[market_key]["commission_tier_" + tier_option].replace("$", "").replace(",", ""))
                                per_kw_amount -= abs(parsed)

                    if per_kw_amount > float(0):
                        if app_entry.lead_generator == "-1":
                            gross = round(float(ret_json["system_size"]) * per_kw_amount, 2)
                            dollarss = int(gross)
                            centss = gross - dollarss
                            centss *= 100
                            centss = int(centss)

                            descrip = "Sold a " + str(ret_json["system_size"]) + " KW system to " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ". " + str(per_kw_amount) + " per KW is awarded. "
                            descrip += Helpers.currency_format(per_kw_amount) + " * " + str(ret_json["system_size"]) + " = " + Helpers.currency_format(gross)
                            descrip += "."
                            obj = {"identifier": rep.identifier, "recipient_name": rep.first_name.strip().title() + " " + rep.last_name.strip().title(), "amount": str(gross), "description_key": "rep_sales_commission_C", "description": descrip}
                            if dollarss > 0 or centss > 0:
                                ret_json["rep_commissions"].append(obj)
                        else:
                            solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                            if not solar_pro is None:
                                gross = float(ret_json["system_size"]) * per_kw_amount
                                gross = round(gross, 2)
                                dollarss = int(gross)
                                centss = gross - dollarss
                                centss *= 100
                                centss = int(centss)

                                descrip = "Sold a " + str(ret_json["system_size"]) + " KW system to " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " via " + solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title() + "'s AB. " + Helpers.currency_format(per_kw_amount) + " per KW is awarded. "
                                descrip += Helpers.currency_format(per_kw_amount) + " * " + str(ret_json["system_size"]) + " = " + Helpers.currency_format(gross)
                                descrip += "."

                                obj = {"identifier": rep.identifier, "recipient_name": rep.first_name.strip().title() + " " + rep.last_name.strip().title(), "amount": str(gross), "description_key": "rep_sales_commission_C", "description": descrip}
                                if dollarss > 0 or centss > 0:
                                    ret_json["rep_commissions"].append(obj)

        ret_json["custom_transactions"] = []
        custom_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "v3_construction_complete_custom_transactions_" + app_entry.identifier)
        if not custom_kv is None:
            ret_json["custom_transactions"] = json.loads(custom_kv.val)

        ret_json["previous_transactions"] = []

        rep_ids_to_query_5 = ["-2"]
        existing_transactions = MonetaryTransactionV2.query(MonetaryTransactionV2.field_app_identifier == app_entry.identifier)
        for t in existing_transactions:
            obj = {"description": t.description}
            obj["amount"] = float(t.dollars)
            obj["amount"] += float(t.cents * float(0.01))
            obj["amount"] = round(obj["amount"], 2)
            obj["dt"] = str(t.payout_date)
            obj["recipient_identifier"] = t.recipient
            ret_json["previous_transactions"].append(obj)
            if not t.recipient in rep_ids_to_query_5:
                rep_ids_to_query_5.append(t.recipient)

        rep_identifier_name_dict_5 = {}
        reps5 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query_5))
        for rep5 in reps5:
            rep_identifier_name_dict_5[rep5.identifier] = rep5.first_name.strip().title() + " " + rep5.last_name.strip().title()

        for obj2 in ret_json["previous_transactions"]:
            obj2["recipient"] = rep_identifier_name_dict_5[obj2["recipient_identifier"]]

                
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "v3_commit_transactions_for_cc":
        h_p_n = Helpers.pacific_now()

        transactions = []
        docs_to_put = []

        items = json.loads(self.request.get("payload"))
        for item in items:
            split_money_values = item["amount"].split(".")
            dollarss = int(split_money_values[0])
            centss = int(split_money_values[1])
            if dollarss < 0:
                centss *= -1

            dt_vals = item["dt"].split("-")

            payout_dt = date(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))

            

            
            transaction = MonetaryTransactionV2(
                approved=True,
                cents=centss,
                check_number=-1,
                created=h_p_n,
                denied=False,
                description=item["description"],
                description_key=item["description_key"],
                dollars=dollarss,
                extra_info="{}",
                field_app_identifier=self.request.get("identifier"),
                identifier=Helpers.guid(),
                paid=False,
                payout_date=payout_dt,
                recipient=item["identifier"]
            )
            transactions.append(transaction)

            docs_to_put.append(
                search.Document(
                    fields=[
                        search.TextField(name="identifier", value=transaction.identifier),
                        search.TextField(name="description", value=transaction.description)
                    ]
                )
            )

        if len(transactions) == 1:
            transactions[0].put()
        elif len(transactions) > 1:
            ndb.put_multi(transactions)

        s_index = search.Index(name="v2_transactions")

        if len(docs_to_put) > 0:
            s_index.put(docs_to_put)

        self.response.content_type = "application/json"
        ret_json = {}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_custom_transaction_to_cc_complete_v3":
        self.response.content_type = "application/json"
        custom_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "v3_construction_complete_custom_transactions_" + self.request.get("identifier"))
        if custom_kv is None:
            custom_kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="v3_construction_complete_custom_transactions_" + self.request.get("identifier"),
                val="[]",
                expiration=Helpers.pacific_now() + timedelta(days=180)
            )
        items = json.loads(custom_kv.val)

        obj = {"identifier": self.request.get("rep_identifier")}
        obj["amount"] = str(round(float(self.request.get("amount")), 2))
        obj["description_key"] = "cc_custom"
        obj["description"] = self.request.get("description")
        obj["recipient_name"] = self.request.get("name")

        items.append(obj)
        custom_kv.val = json.dumps(items)
        custom_kv.put()

        self.response.out.write(json.dumps({}))

    elif self.request.get("fn") == "welcome_call_construction_complete_details":
        ret_json = {}
        self.response.content_type = "application/json"
        identifier = self.request.get("identifier")
        rep_identifier = "-1"
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
        pp = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
        include_overrides = True

        o_locations = OfficeLocation.query(OfficeLocation.is_parent == False)

        if (not app_entry is None) and (not booking is None) and (not proposal is None) and (not pp is None):
            market_identifier = "-1"
            ol = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if (not rep is None) and (not ol is None):
                market_identifier = ol.parent_identifier
                marquet = OfficeLocation.first(OfficeLocation.identifier == market_identifier)
                if not marquet is None:
                    include_overrides = (marquet.residual_overrides == False)
                pricing_structures = Helpers.get_pricing_structures()
                funds = Helpers.list_funds()                

                if app_entry.baseline_price > float(0):
                    ret_json["baseline_price"] = str(app_entry.baseline_price)
                    
                rep_identifier = rep.identifier
                ret_json["rep"] = {"name": rep.first_name.strip().title() + " " + rep.last_name.strip().title(), "identifier": rep.identifier}
                for item in ["customer_address", "customer_postal", "customer_city", "customer_state", "tier_option", "customer_first_name", "customer_last_name"]:
                    ret_json[item] = getattr(app_entry, item)

                ret_json["solar_pro"] = None
                if not app_entry.lead_generator == "-1":
                    solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not solar_pro is None:
                        ret_json["solar_pro"] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

                pp_info = json.loads(pp.extra_info)
                proposal.fix_additional_amount()
                proposal.fix_system_size()

                ret_json["price_per_kw"] = Helpers.crunch("fx_Commission_Price_Per_Kw", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                ret_json["ppa_price_per_kw"] = Helpers.crunch("fx_Commission_Price_Per_Kw_Leaase_PPA", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                ret_json["commission_options"] = {"A": float(0), "B": float(0), "C": float(0), "D": float(0), "E": float(0)}
                ret_json["cost_per_point"] = round(float(Helpers.read_setting("services_point_cost")), 2)
                ret_json["deal_points"] = round(Helpers.get_points_for_deal(proposal), 2)
                if market_identifier in pricing_structures.keys():
                    if "baseline_commission" in pricing_structures[market_identifier].keys():
                        ret_json["commission_options"]["A"] = float(pricing_structures[market_identifier]["baseline_commission"])
                    for letter in ["B", "C", "D", "E"]:
                        tier_key = "commission_tier_" + letter.lower()
                        if tier_key in pricing_structures[market_identifier].keys():
                            ret_json["commission_options"][letter] = float(pricing_structures[market_identifier][tier_key])


                ret_json["closer"] = None
                if "closer" in pp_info.keys():
                    closer = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_info["closer"])
                    if not closer is None:
                        ret_json["closer"] = {"name": closer.first_name.strip().title() + " " + closer.last_name.strip().title(), "identifier": closer.identifier}

                ret_json["welcomecalldate"] = str(date(1970, 1, 1))
                try:
                    ret_json["welcomecalldate"] = pp_info["project_management_checkoffs"]["welcome_call_completed"]["date"]
                except:
                    ret_json = ret_json

                ret_json["system_size"] = json.loads(proposal.info)["system_size"]
                ret_json["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
                ret_json["email"] = app_entry.customer_email
                ret_json["fund"] = booking.fund
                ret_json["project_manager"] = {"name": "Unknown", "email": "Unknown", "phone": "Unknown"}
                pm = FieldApplicationUser.first(FieldApplicationUser.identifier == pp_info["project_manager"])
                if not pm is None:
                    ret_json["project_manager"] = {"name": pm.first_name.strip().title() + " " + pm.last_name.strip().title(), "email": pm.rep_email, "phone": pm.rep_phone}
                ret_json["signed_date"] = None
                ret_json["total_system_cost"] = float(0)
                try:                    
                    ret_json["total_system_cost"] = Helpers.crunch("fx_Total_System_Cost", market_identifier, app_entry, booking, json.loads(proposal.info), pricing_structures, funds)
                except:
                    ret_json = ret_json

                kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "customer_signature_" + app_entry.identifier)
                if not kv_item is None:
                    ret_json["signed_date"] = str(kv_item.modified.date())

                ret_json["greensky_amount_correct"] = False
                ret_json["commission_reviewed"] = False

                if "project_management_specifics" in pp_info.keys():
                    if "greensky_amount_correct" in pp_info["project_management_specifics"].keys():
                        ret_json["greensky_amount_correct"] = (pp_info["project_management_specifics"]["greensky_amount_correct"] == "1")
                    if "commission_reviewed" in pp_info["project_management_specifics"].keys():
                        ret_json["commission_reviewed"] = (pp_info["project_management_specifics"]["commission_reviewed"] == "1")

                ret_json["temp_transactions_A"] = []
                kv_item2 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "temp_commission_transactions_A_" + app_entry.identifier)
                if not kv_item2 is None:
                    ret_json["temp_transactions_A"] = json.loads(kv_item2.val)

                ret_json["temp_transactions_B"] = []
                kv_item3 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "temp_commission_transactions_B_" + app_entry.identifier)
                if not kv_item3 is None:
                    ret_json["temp_transactions_B"] = json.loads(kv_item3.val)


                kv_item4 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commissions_paid_out_A_" + app_entry.identifier)
                kv_item5 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commissions_paid_out_B_" + app_entry.identifier)
                ret_json["paid_out_A"] = (not kv_item4 is None)
                ret_json["paid_out_B"] = (not kv_item5 is None)
               
                ret_json["funds"] = funds
                if ret_json["tier_option"] == "n/a":
                    ret_json["tier_option"] = "A"

                h_p_t = Helpers.pacific_today()

                v2transactions = MonetaryTransactionV2.query(
                    ndb.AND
                    (
                        MonetaryTransactionV2.approved == True,
                        MonetaryTransactionV2.denied == False,
                        MonetaryTransactionV2.paid == False,
                        MonetaryTransactionV2.field_app_identifier == self.request.get("identifier")
                    )
                )

                ret_json["pending_transactions"] = []
                ret_json["pending_recipients_map"] = {}
                rep_identifiers_to_query = []
                transacts = []
                eligible_keys = ["closers_bonus_A", "closers_bonus_B", "rep_sales_commission_1A", "rep_sales_commission_1B", "commission_miscellaneous_payout_A", "commission_miscellaneous_payout_B", "construction_complete_mgr_override", "const_complete_override"]
                for mtv2 in v2transactions:
                    if not (mtv2.description_key in eligible_keys):
                        continue

                    transacts.append(mtv2)

                transacts = Helpers.bubble_sort(transacts, "payout_date")
                for tt in transacts:
                    rep_identifiers_to_query.append(tt.recipient)
                    d = {}
                    d["identifier"] = tt.identifier
                    d["payout_date"] = str(tt.payout_date)
                    d["amount"] = float(tt.dollars) + float(float(tt.cents) / float(100))
                    d["description"] = tt.description
                    d["recipient"] = tt.recipient
                    ret_json["pending_transactions"].append(d)

                if len(rep_identifiers_to_query) > 0:
                    repps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_identifiers_to_query))
                    for repp in repps:
                        ret_json["pending_recipients_map"][repp.identifier] = repp.first_name.strip().title() + " " + repp.last_name.strip().title()

                ret_json["suggested_overrides"] = []
                for o_location in o_locations:
                    override_data = o_location.get_override_data()
                    if ret_json["rep"]["identifier"] in override_data["yielders"]:
                        if ret_json["rep"]["identifier"] in override_data["data"].keys():
                            for item in override_data["data"][ret_json["rep"]["identifier"]]:
                                if float(item["amount"]) > float(0):
                                    fund_name_components = booking.fund.split("_")
                                    multip_factor = 1.0
                                    if "lease" in fund_name_components or "ppa" in fund_name_components:
                                        if market_identifier in pricing_structures.keys():
                                            if "ppa_override_multiplication_factor" in pricing_structures[market_identifier].keys():
                                                multip_factor = float(pricing_structures[market_identifier]["ppa_override_multiplication_factor"])
                                    if include_overrides:
                                        ret_json["suggested_overrides"].append({"identifier": item["identifier"], "amount": str(multip_factor * (float(item["amount"]) * float(ret_json["system_size"]))), "base_amount": str(float(item["amount"]) * multip_factor)})

                override_recipient_idxs_map = {}
                distinct_override_recipients = ["-1"]
                cnt2 = 0
                for item in ret_json["suggested_overrides"]:
                    if not item["identifier"] in override_recipient_idxs_map:
                        override_recipient_idxs_map[item["identifier"]] = []
                    override_recipient_idxs_map[item["identifier"]].append(cnt2)
                    distinct_override_recipients.append(item["identifier"])
                    cnt2 += 1

                override_recipients = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(distinct_override_recipients))
                for override_r in override_recipients:
                    for idx in override_recipient_idxs_map[override_r.identifier]:
                        ret_json["suggested_overrides"][idx]["name"] = override_r.first_name.strip().title() + " " + override_r.last_name.strip().title()

                ret_json["paid_and_scheduled_transactions_A"] = []
                ret_json["paid_and_scheduled_transactions_B"] = []
                distinct_paid_and_scheduled_reps = ["-1"]
                if ret_json["paid_out_A"]:
                    paid_out_transactions_A = MonetaryTransactionV2.query(
                        ndb.AND
                        (
                            MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                            MonetaryTransactionV2.description_key.IN(["closers_bonus_A", "rep_sales_commission_1A", "commission_miscellaneous_payout_A"])
                        )
                    )
                    for t in paid_out_transactions_A:
                        distinct_paid_and_scheduled_reps.append(t.recipient)
                        ret_json["paid_and_scheduled_transactions_A"].append({"recipient": t.recipient, "amount": str(float(t.dollars) + float(t.cents / float(100))), "description_key": t.description_key, "description": t.description})

                if ret_json["paid_out_B"]:
                    paid_out_transactions_B = MonetaryTransactionV2.query(
                        ndb.AND
                        (
                            MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                            MonetaryTransactionV2.description_key.IN(["closers_bonus_B", "rep_sales_commission_1B", "commission_miscellaneous_payout_B", "construction_complete_mgr_override", "const_complete_override"])
                        )
                    )
                    for t in paid_out_transactions_B:
                        distinct_paid_and_scheduled_reps.append(t.recipient)
                        ret_json["paid_and_scheduled_transactions_B"].append({"recipient": t.recipient, "amount": str(float(t.dollars) + float(t.cents / float(100))), "description_key": t.description_key, "description": t.description})

                if len(distinct_paid_and_scheduled_reps) > -1:
                    d_reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(distinct_paid_and_scheduled_reps))
                    d_rep_identifier_name_dict = {}
                    for d_rep in d_reps:
                        d_rep_identifier_name_dict[d_rep.identifier] = d_rep.first_name.strip().title() + " " + d_rep.last_name.strip().title()
                    d_keys = d_rep_identifier_name_dict.keys()
                    
                    for ch in ["A", "B"]:
                        for item in ret_json["paid_and_scheduled_transactions_" + ch]:
                            if item["recipient"] in d_keys:
                                item["recipient"] = d_rep_identifier_name_dict[item["recipient"]]
                            else:
                                item["recipient"] = "{{ Error }}"
                

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_temporary_commission_transactions_A":
        kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "temp_commission_transactions_A_" + self.request.get("identifier"))
        if kv_item is None:
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="temp_commission_transactions_A_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365)
            )
        kv_item.val=self.request.get("transactions")
        kv_item.put()

    elif self.request.get("fn") == "update_temporary_commission_transactions_B":
        kv_item = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "temp_commission_transactions_B_" + self.request.get("identifier"))
        if kv_item is None:
            kv_item = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="temp_commission_transactions_B_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=365)
            )
        kv_item.val=self.request.get("transactions")
        kv_item.put()

    elif self.request.get("fn") == "create_check_payment":
        cp = CheckPayment(
            identifier=Helpers.guid(),
            recipient="0dfb32c952e5d244b043e66893b8eb2cb805844c500d40f5ca58e4d7fe353e6d3cba8413a1638438fc8e32966e919508f466c94407a7b736591fca22f6141386",
            check_number=-1,
            check_date=date(2016, 9, 2)
        )
        cp.put()
    elif self.request.get("fn") == "schedule_transactions_for_payout_at_commission":
        transaction_index = search.Index(name="v2_transactions")
        docs_to_put = []
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        ret_json["error_message"] = "Unknown error"
        h_p_n = Helpers.pacific_now()
        transactions = json.loads(self.request.get("transactions"))
        identifier = self.request.get("identifier")
        step = self.request.get("step")
        kv_item1 = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "commissions_paid_out_" + step + "_" + identifier)
        if kv_item1 is None:
            kv_item2 = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="commissions_paid_out_" + step + "_" + identifier,
                val="1",
                expiration=Helpers.pacific_now() + timedelta(days=365)
            )

            transactions_to_put = []
            throw_error = False
            last_recipient = ""
            last_date = date(1970, 1, 1)
            for t in transactions:
                if throw_error:
                    continue

                last_recipient = t["recipient"]
                d_vals = t["date"].split("-")
                pd = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
                last_date = pd
                cp = CheckPayment.first(
                    ndb.AND
                    (
                        CheckPayment.recipient == t["recipient"],
                        CheckPayment.check_date == pd
                    )
                )
                if not throw_error:
                   throw_error =  (not cp is None)

                dec_vals = str("{0:.2f}".format(t["amount"])).split(".")
                d = int(dec_vals[0])
                c = int(dec_vals[1])
                mtv2 = MonetaryTransactionV2(
                    identifier=Helpers.guid(),
                    description=t["description"],
                    dollars=d,
                    cents=c,
                    approved=True,
                    denied=False,
                    description_key=t["description_key"],
                    recipient=t["recipient"],
                    created=h_p_n,
                    check_number=-1,
                    payout_date=pd,
                    paid=False,
                    field_app_identifier=identifier,
                    extra_info="{}"
                )
                transactions_to_put.append(mtv2)

            if not throw_error:
                saved_identifiers = ["-1"]
                brake = False
                for item in transactions_to_put:
                    if not brake:
                        try:
                            item.put()
                            saved_identifiers.append(item.identifier)
                            docs_to_put.append(
                                search.Document(
                                    fields=[
                                        search.TextField(name="identifier", value=item.identifier),
                                        search.TextField(name="description", value=item.description)
                                    ]
                                )
                            )
                        except:
                            brake = True
                if brake:
                    del_items = MonetaryTransactionV2.query(MonetaryTransactionV2.identifier.IN(saved_identifiers))
                    for del_item in del_items:
                        del_item.key.delete()

                else:
                    transaction_index.put(docs_to_put)
                    state_key_dict = {"A": "welcome_call_completed", "B": "final_payment_requested_received"}
                    kv_item2.put()
                    payroll_item = PayrollCustomerState.first(
                        ndb.AND
                        (
                            PayrollCustomerState.state_key == state_key_dict[step],
                            PayrollCustomerState.field_app_identifier == identifier
                        )
                    )
                    if not payroll_item is None:
                        payroll_item.key.delete()

                    ret_json["success"] = True
                    if step == "B":
                        # generate the residual payments
                        a_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
                        if not a_entry is None:
                            generate_residuals = True
                            lead_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_status_" + a_entry.identifier)
                            if not lead_kv is None:
                                if lead_kv.val == "1":
                                    generate_residuals = False
                            booking = SurveyBooking.first(SurveyBooking.field_app_identifier == a_entry.identifier)
                            if not booking is None:
                                fund_name_components = booking.fund.split("_")
                                if (not "ppa" in fund_name_components) and (not "lease" in fund_name_components):
                                    u = FieldApplicationUser.first(FieldApplicationUser.rep_id == a_entry.rep_id)
                                    if not u is None:
                                        t_recip = u.identifier
                                        o_loc = OfficeLocation.first(OfficeLocation.identifier == a_entry.office_identifier)
                                        if not o_loc is None:
                                            mkt = OfficeLocation.first(OfficeLocation.identifier == o_loc.parent_identifier)
                                            if not mkt is None:
                                                proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == a_entry.identifier)
                                                if not proposal is None:
                                                    proposal.fix_additional_amount()
                                                    proposal.fix_system_size()
                                                    
                                                    months = 18
                                                    description_key_prefix = "residual_pay"
                                                    if generate_residuals:
                                                        months = months
                                                        #Helpers.generate_residual_payments_for_deal(t_recip, a_entry, mkt.identifier, proposal, months, description_key_prefix)                                                    
                                                    prop_infoo = json.loads(proposal.info)

                                                    o_locationss = OfficeLocation.query(OfficeLocation.is_parent == False)
                                                    for o_locationnn in o_locationss:
                                                        override_data = o_locationnn.get_override_data()
                                                        if t_recip in override_data["yielders"]:
                                                            if t_recip in override_data["data"].keys():
                                                                for item in override_data["data"][t_recip]:
                                                                    if float(item["amount"]) > float(0):
                                                                        fund_name_components = booking.fund.split("_")
                                                                        multip_factor = 1.0
                                                                        if (not "lease" in fund_name_components) and (not "ppa" in fund_name_components):
                                                                            amountt = multip_factor * float(item["amount"]) * float(prop_infoo["system_size"])                                                                            
                                                                            ret_json["suggested_overrides"].append({"identifier": item["identifier"], "amount": str(multip_factor * (float(item["amount"]) * float(ret_json["system_size"]))), "base_amount": str(float(item["amount"]) * multip_factor)})

                                                #the residual overrides
                                                #if mkt.residual_overrides:
                                                #    o_locationss = OfficeLocation.query(OfficeLocation.is_parent == False)
                                                #    for o_locationnn in o_locationss:
                                                #        override_data = o_locationnn.get_override_data()
                                                #        if t_recip in override_data["yielders"]:
                                                #            if t_recip in override_data["data"].keys():
                                                #                for item in override_data["data"][t_recip]:
                                                #                    if float(item["amount"]) > float(0):
                                                #                        fund_name_components = booking.fund.split("_")
                                                #                        multip_factor = 1.0
                                                #                        if (not "lease" in fund_name_components) and (not "ppa" in fund_name_components):
                                                #                            amountt = multip_factor * float(item["amount"]) * float(prop_infoo["system_size"])
                                                #                            if generate_residuals:
                                                #                                x = 5
                                                                                #Helpers.generate_residual_override_payments(amountt, 18, item["identifier"], u, a_entry)
                                                                                #comment below should stay commented
                                                                            #ret_json["suggested_overrides"].append({"identifier": item["identifier"], "amount": str(multip_factor * (float(item["amount"]) * float(ret_json["system_size"]))), "base_amount": str(float(item["amount"]) * multip_factor)})


                        ret_json["install_date"] = str(date(1970, 1, 1))
                        final_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == identifier)
                        if not final_sub is None:
                            final_info = json.loads(final_sub.extra_info)
                            if "project_management_checkoffs" in final_info.keys():
                                if "install" in final_info["project_management_checkoffs"].keys():
                                    if "checked" in final_info["project_management_checkoffs"]["install"].keys():
                                        if final_info["project_management_checkoffs"]["install"]["checked"]:
                                            ret_json["install_date"] = final_info["project_management_checkoffs"]["install"]["date"]
            else:
                last_user = FieldApplicationUser.first(FieldApplicationUser.identifier == last_recipient)
                if not last_user is None:
                    ret_json["error_message"] = "The transactions could not be applied because " + last_user.first_name + " " + last_user.last_name + "'s check for " + str(last_date) + " was already issued."


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "active_reps_json":
        self.response.content_type = "application/json"
        ret_json = []
        reps = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        for rep in reps:
            if not rep.user_type == "super":
                item = {"name": rep.first_name.strip().title() + " " + rep.last_name.strip().title(), "email": rep.rep_email.lower()}
                ret_json.append(item)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_transaction_payout_date":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        ret_json["error_message"] = "Unknown error"
        d_vals = self.request.get("new_date").split("-")
        new_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        trans = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not trans is None:
            check_payment = CheckPayment.first(
                ndb.AND
                (
                    CheckPayment.recipient == trans.recipient,
                    CheckPayment.check_date == new_date
                )
            )
            if (not check_payment is None):
                ret_json["error_message"] = "A check has already been issued for that transaction"
            else:
                if trans.paid == False:
                    trans.payout_date = new_date
                    trans.put()
                    ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "custom_report_xxx":
        data = []
        stats = LeaderBoardStat.query(
            ndb.AND
            (
                LeaderBoardStat.metric_key == "packets_submitted",
                LeaderBoardStat.recorded_dt >= datetime(2016, 7, 25),
                LeaderBoardStat.recorded_dt <= datetime(2016, 8, 20)
            )
        )
        stat_cpy = []
        rep_ids_to_query = ["-1"]
        for stat in stats:
            logging.info("hit")
            stat_cpy.append(stat)
            rep_ids_to_query.append(stat.rep_id)

        rep_id_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            rep_id_name_dict[rep.rep_id] = rep.first_name + " " + rep.last_name

        rep_id_tally_dict = {}
        for stat in stat_cpy:
            if not stat.rep_id in rep_id_tally_dict.keys():
                rep_id_tally_dict[stat.rep_id] = 0

            rep_id_tally_dict[stat.rep_id] += 1

        for rep_id in rep_id_tally_dict.keys():
            item = {"name": rep_id_name_dict[rep_id], "count": rep_id_tally_dict[rep_id]}
            data.append(item)

        self.response.out.write(json.dumps(data))

    elif self.request.get("fn") == "rep_details_by_identifier":
        self.response.content_type = "application/json"
        ret_json = {}
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            ret_json["name"] = rep.first_name + " " + rep.last_name

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "deny_reimbursement_request":
        mtv2 = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not mtv2 is None:
            mtv2.approved = False
            mtv2.denied = True
            mtv2.put()

    elif self.request.get("fn") == "approve_reimbursement_request":
        d_vals = self.request.get("date").split("-")
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        mtv2 = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not mtv2 is None:
            check_payment = CheckPayment.first(
                ndb.AND
                (
                    CheckPayment.recipient == mtv2.recipient,
                    CheckPayment.check_date == date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
                )
            )
            if check_payment is None:
                mtv2.payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
                mtv2.approved = True
                mtv2.denied = False
                mtv2.put()

                s_index = search.Index(name="v2_transactions")
                s_index.put(
                    [search.Document(
                        fields=[
                            search.TextField(name="identifier", value=mtv2.identifier),
                            search.TextField(name="description", value=mtv2.description)
                        ]
                    )]
                )
                ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "directory_update_rep_details":
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            rep.rep_email = self.request.get("email")
            rep.rep_phone = self.request.get("phone")
            rep.address = self.request.get("address")
            rep.city = self.request.get("city")
            rep.state = self.request.get("state")
            rep.postal = self.request.get("postal")
            rep.put()

    elif self.request.get("fn") == "init_user_debt":
        items_to_put = []
        reps = FieldApplicationUser.query()
        for rep in reps:
            d = UserDebt(
                identifier=Helpers.guid(),
                field_app_identifier=rep.identifier,
                total=float(0),
                items="[]",
                modified=datetime(1970, 1, 1)
            )
            items_to_put.append(d)

        logging.info(len(items_to_put))
        ndb.put_multi(items_to_put)

    elif self.request.get("fn") == "issue_payment":
        d_vals = self.request.get("date").split("-")
        payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        r = self.request.get("identifier")
        check_payment = CheckPayment.first(
            ndb.AND
            (
                CheckPayment.check_date == payout_date,
                CheckPayment.recipient == r
            )
        )
        if check_payment is None:
            cp = CheckPayment(
                identifier=Helpers.guid(),
                recipient=r,
                check_number=-1,
                check_date=payout_date
            )
            v2transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.approved == True,
                    MonetaryTransactionV2.recipient == r,
                    MonetaryTransactionV2.payout_date == payout_date
                )
            )
            ret_json["total"] = float(0)
            transactions_to_save = []
            for trans in v2transactions:
                ret_json["total"] += float(trans.dollars)
                ret_json["total"] += (float(trans.cents) / float(100))
                trans.paid = True

            if ret_json["total"] > float(-0.01):
                if len(transactions_to_save) == 1:
                    transactions_to_save[0].put()
                elif len(transactions_to_save) > 1:
                    ndb.put_multi(transactions_to_save)
                cp.put()

                ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "payout_details_for_rep_v3":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["transactions"] = []
        d_vals = self.request.get("date").split("-")
        payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        upcoming_fri = Helpers.pacific_now()
        while not upcoming_fri.isoweekday() == 5:
            upcoming_fri = upcoming_fri + timedelta(days=1)

        ret_json["can_issue_payment"] = (payout_date == upcoming_fri.date())
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            ret_json["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            ret_json["phone"] = Helpers.format_phone_number(rep.rep_phone)
            ret_json["email"] = rep.rep_email
            ret_json["address"] = ret_json["name"] + "\n" + rep.address + "\n" + rep.city + ", " + rep.state + "\n" + rep.postal
            ret_json["debt"] = float(0)

            debt = UserDebt.first(UserDebt.field_app_identifier == rep.identifier)
            if not debt is None:
                ret_json["debt"] = debt.total

            v2transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.payout_date == payout_date,
                    MonetaryTransactionV2.recipient == self.request.get("identifier"),
                    MonetaryTransactionV2.approved == True,
                )
            )

            transacts = []
            for t in v2transactions:
                total_cents = (t.dollars * 100) + t.cents
                dummy_transaction = (total_cents >= -500 and total_cents <= 25)
                if dummy_transaction:
                    t.dollars = 0
                    t.cents = 0
                    
                transacts.append(t)

            totes = float(0)
            reimbursement_totes = float(0)
            transacts = Helpers.bubble_sort(transacts, "created")
            for tt in transacts:
                is_reimbursement = ("reimbursement" in tt.description_key.lower())
                is_not_reimbursement = not is_reimbursement
                item = {}
                item["identifier"] = tt.identifier
                item["created"] = str(tt.created.date())
                new_total = float(tt.dollars)
                new_total += float(tt.cents) * float(0.01)
                new_total = round(new_total, 2)
                item["total"] = new_total
                item["description"] = tt.description
                item["description_key"] = tt.description_key
                item["payout_date"] = str(tt.payout_date)
                item["recipient"] = tt.recipient
                ret_json["transactions"].append(item)

                totes += (item["total"] * float(int(is_not_reimbursement)))
                reimbursement_totes += (item["total"] * float(int(is_reimbursement)))

            check_payment = CheckPayment.first(
                ndb.AND
                (
                    CheckPayment.recipient == self.request.get("identifier"),
                    CheckPayment.check_date == payout_date
                )
            )
            ret_json["paid"] = (not check_payment is None)
            ret_json["payout_total"] = totes
            ret_json["reimbursement_total"] = reimbursement_totes

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "payout_details_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["transactions"] = []
        d_vals = self.request.get("date").split("-")
        payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        upcoming_fri = Helpers.pacific_now()
        while not upcoming_fri.isoweekday() == 5:
            upcoming_fri = upcoming_fri + timedelta(days=1)

        ret_json["can_issue_payment"] = (payout_date == upcoming_fri.date())
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            ret_json["name"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            ret_json["phone"] = Helpers.format_phone_number(rep.rep_phone)
            ret_json["email"] = rep.rep_email
            ret_json["address"] = ret_json["name"] + "\n" + rep.address + "\n" + rep.city + ", " + rep.state + "\n" + rep.postal
            ret_json["debt"] = float(0)

            debt = UserDebt.first(UserDebt.field_app_identifier == rep.identifier)
            if not debt is None:
                ret_json["debt"] = debt.total

            v2transactions = MonetaryTransactionV2.query(
                ndb.AND
                (
                    MonetaryTransactionV2.payout_date == payout_date,
                    MonetaryTransactionV2.recipient == self.request.get("identifier"),
                    MonetaryTransactionV2.approved == True,
                )
            )

            transacts = []
            for t in v2transactions:
                transacts.append(t)

            totes = float(0)
            reimbursement_totes = float(0)
            transacts = Helpers.bubble_sort(transacts, "created")
            for tt in transacts:
                is_reimbursement = ("reimbursement" in tt.description_key.lower())
                is_not_reimbursement = not is_reimbursement
                item = {}
                item["identifier"] = tt.identifier
                item["created"] = str(tt.created.date())
                item["total"] = float(tt.dollars) + (float(tt.cents) / float(100))
                item["description"] = tt.description
                item["description_key"] = tt.description_key
                item["payout_date"] = str(tt.payout_date)
                item["recipient"] = tt.recipient
                ret_json["transactions"].append(item)

                totes += (item["total"] * float(int(is_not_reimbursement)))
                reimbursement_totes += (item["total"] * float(int(is_reimbursement)))

            check_payment = CheckPayment.first(
                ndb.AND
                (
                    CheckPayment.recipient == self.request.get("identifier"),
                    CheckPayment.check_date == payout_date
                )
            )
            ret_json["paid"] = (not check_payment is None)
            ret_json["payout_total"] = totes
            ret_json["reimbursement_total"] = reimbursement_totes

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "payroll_v3_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/payroll_v3", params={"fn": self.request.get("fn2")})

    elif self.request.get("fn") == "update_transaction_amount":
        t = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not t is None:
            t.dollars = int(self.request.get("dollars"))
            t.cents = int(self.request.get("cents"))
            t.put()
        return

    elif self.request.get("fn") == "update_hk_amount":
        self.response.content_type = "application/json"
        ret_json = {"amount": "undefined", "description": "email or call ray"}
        t = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not t is None:
            hk_amount = int(self.request.get("hks"))
            rep_identifier = t.recipient

            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == rep_identifier)
            if not rep is None:
                office_identifier = rep.main_office
                office_location = OfficeLocation.first(OfficeLocation.identifier == office_identifier)
                if not office_location is None:
                    market_key = office_location.parent_identifier
                    pricing_structures = Helpers.get_pricing_structures()

                    pay_per_hk = float(0)

                    if market_key in pricing_structures.keys():
                        if "solar_pro_pay_per_hk" in pricing_structures[market_key].keys():
                            pay_per_hk = float(pricing_structures[market_key]["solar_pro_pay_per_hk"].replace("$", "").replace(",", ""))

                    if rep.user_type == "solar_pro_manager":
                        if market_key in pricing_structures.keys():
                            if "solar_pro_manager_pay_per_hk" in pricing_structures[market_key].keys():
                                pay_per_hk = float(pricing_structures[market_key]["solar_pro_manager_pay_per_hk"].replace("$", "").replace(",", ""))

                    pay_per_hk_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "pay_per_hk_" + rep_identifier)
                    if not pay_per_hk_kv is None:
                        pay_per_hk = float(pay_per_hk_kv.val.replace("$", "").replace(",", ""))

                    if pay_per_hk > float(0):
                        h_p_t = Helpers.pacific_today()
                        h_p_n = Helpers.pacific_now()

                        start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
                        while not start_dt.isoweekday() == 7:
                            start_dt = start_dt + timedelta(days=-1)

                        start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
                        end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
                        end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

                        start_dt = start_dt + timedelta(days=-7)
                        end_dt = end_dt + timedelta(days=-7)

                        total = float(pay_per_hk) * float(hk_amount)
                        total = round(total, 2)
                        dollarss = int(total)
                        centss = total - dollarss
                        centss *= 100
                        centss = int(centss)
                        descrip = "HK pay for period " + str(start_dt.date()) + " --- " + str(end_dt.date()) + ": " + str(hk_amount) + " @ " + Helpers.currency_format(pay_per_hk) + " per HK = " + Helpers.currency_format(total) + "."
                        t.description = descrip
                        t.dollars = dollarss
                        t.cents = centss

                        ret_json["description"] = t.description
                        ret_json["amount"] = Helpers.currency_format(total).replace("$", "")

                        t.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "suggested_kick_purge":
        today = Helpers.pacific_today()
        kicks = SuggestedKick.query(SuggestedKick.suggested_kick_dt < today)
        for kick in kicks:
            kick.key.delete()

    elif self.request.get("fn") == "suggested_kick_notify":
        kicks_today = SuggestedKick.query(SuggestedKick.suggested_kick_dt == Helpers.pacific_today())

        rep_ids_to_query = ["-1"]
        rep_names = []
        for kick in kicks_today:
            rep_ids_to_query.append(kick.rep_identifier)

        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_names.append(rep.first_name.strip().title() + " " + rep.last_name.strip().title())

        if len(rep_names) > 0:
            notification = Notification.first(Notification.action_name == "Account Deactivation Suggestions")
            if not notification is None:
                subject = "Account Deactivation Suggestions"
                msg = "The following accounts are recommended for deactivation:\r\n\r\n"
                msg += "\r\n".join(rep_names)
                for p in notification.notification_list:
                    Helpers.send_email(p.email_address, subject, msg)


    elif self.request.get("fn") == "suggested_kicks_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/suggested_kicks", params={})

    elif self.request.get("fn") == "contest_deactivation":
        dt_vals = self.request.get("dt").split("-")
        exp = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), 23, 59, 59)
        exp = exp + timedelta(days=3)

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "kick_halt_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="kick_halt_" + self.request.get("identifier"),
                val="1"
            )

        kv.expiration = exp
        kv.put()


    elif self.request.get("fn") == "update_transaction_description":
        t = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not t is None:
            t.description = self.request.get("description")
            t.put()
            idx = search.Index(name="v2_transactions")
            results = idx.search(t.identifier)
            for r in results:
                Helpers.delete_search_document("v2_transactions", r.doc_id)
            idx.put(
                [
                    search.Document(
                        fields=[
                            search.TextField(name="identifier", value=t.identifier),
                            search.TextField(name="description", value=t.description)
                        ]
                    )
                ]
            )

    elif self.request.get("fn") == "purge_transaction":
        t = MonetaryTransactionV2.first(MonetaryTransactionV2.identifier == self.request.get("identifier"))
        if not t is None:
            idx = search.Index(name="v2_transactions")
            results = idx.search(t.identifier)
            for r in results:
                Helpers.delete_search_document("v2_transactions", r.doc_id)
            t.key.delete()

    elif self.request.get("fn") == "payouts_tab_update_v3":
        d_vals = self.request.get("date").split("-")
        payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        self.response.content_type = "application/json"
        ret_json = []

        transactions3 = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.paid == False,
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.payout_date == payout_date
            )
        )
        reps_pending_payout = {}
        rep_identifier_payout_total_dict = {}
        rep_identifier_reimbursement_total_dict = {}
        for t in transactions3:
            total_cents = (t.dollars * 100) + t.cents
            dummy_transaction = (total_cents >= -500 and total_cents <= 25)
            if dummy_transaction:
                t.cents = 0
                t.dollars = 0


            if not t.recipient in reps_pending_payout.keys():
                reps_pending_payout[t.recipient] = 0
            if not t.recipient in rep_identifier_payout_total_dict.keys():
                rep_identifier_payout_total_dict[t.recipient] = float(0)
            reps_pending_payout[t.recipient] += 1
            if not t.recipient in rep_identifier_reimbursement_total_dict.keys():
                rep_identifier_reimbursement_total_dict[t.recipient] = 0
            
            is_reimbursement = ("reimbursement" in t.description_key.lower())
            not_is_reimbursement = not is_reimbursement
            rep_identifier_payout_total_dict[t.recipient] += (float(t.dollars) * float(int(not_is_reimbursement)))
            rep_identifier_payout_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(not_is_reimbursement)))
            rep_identifier_reimbursement_total_dict[t.recipient] += (float(t.dollars) * float(int(is_reimbursement)))
            rep_identifier_reimbursement_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(is_reimbursement)))

        rep_identifier_idx_dict = {}
        rep_ids_to_query3 = reps_pending_payout.keys()
        if len(rep_ids_to_query3) > 0:
            reps3 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query3))
            for rep3 in reps3:
                item = {}
                item["identifier"] = rep3.identifier
                item["tally"] = reps_pending_payout[rep3.identifier]
                item["date"] = str(payout_date)
                item["total"] = rep_identifier_payout_total_dict[rep3.identifier]
                item["reimbursements"] = rep_identifier_reimbursement_total_dict[rep3.identifier]
                item["name"] = rep3.first_name.strip().title() + " " + rep3.last_name.strip().title()
                item["paid"] = False
                item["last_name_lowered"] = rep3.last_name.strip().lower()
                ret_json.append(item)
                rep_identifier_idx_dict[item["identifier"]] = len(ret_json) - 1

            debts = UserDebt.query(UserDebt.field_app_identifier.IN(rep_ids_to_query3))
            for debt in debts:
                ret_json[rep_identifier_idx_dict[debt.field_app_identifier]]["total_debt"] = debt.total
                ret_json[rep_identifier_idx_dict[debt.field_app_identifier]]["debt_items"] = json.loads(debt.items)

        ret_json = Helpers.bubble_sort(ret_json, "last_name_lowered")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "payouts_tab_update":
        d_vals = self.request.get("date").split("-")
        payout_date = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        self.response.content_type = "application/json"
        ret_json = []

        transactions3 = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.paid == False,
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.payout_date == payout_date
            )
        )
        reps_pending_payout = {}
        rep_identifier_payout_total_dict = {}
        rep_identifier_reimbursement_total_dict = {}
        for t in transactions3:
            if not t.recipient in reps_pending_payout.keys():
                reps_pending_payout[t.recipient] = 0
            if not t.recipient in rep_identifier_payout_total_dict.keys():
                rep_identifier_payout_total_dict[t.recipient] = float(0)
            reps_pending_payout[t.recipient] += 1
            if not t.recipient in rep_identifier_reimbursement_total_dict.keys():
                rep_identifier_reimbursement_total_dict[t.recipient] = 0
            
            is_reimbursement = ("reimbursement" in t.description_key.lower())
            not_is_reimbursement = not is_reimbursement
            rep_identifier_payout_total_dict[t.recipient] += (float(t.dollars) * float(int(not_is_reimbursement)))
            rep_identifier_payout_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(not_is_reimbursement)))
            rep_identifier_reimbursement_total_dict[t.recipient] += (float(t.dollars) * float(int(is_reimbursement)))
            rep_identifier_reimbursement_total_dict[t.recipient] += ((float(t.cents) / float(100)) * float(int(is_reimbursement)))

        rep_identifier_idx_dict = {}
        rep_ids_to_query3 = reps_pending_payout.keys()
        if len(rep_ids_to_query3) > 0:
            reps3 = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query3))
            for rep3 in reps3:
                item = {}
                item["identifier"] = rep3.identifier
                item["tally"] = reps_pending_payout[rep3.identifier]
                item["date"] = str(payout_date)
                item["total"] = rep_identifier_payout_total_dict[rep3.identifier]
                item["reimbursements"] = rep_identifier_reimbursement_total_dict[rep3.identifier]
                item["name"] = rep3.first_name.strip().title() + " " + rep3.last_name.strip().title()
                item["last_name_lowered"] = rep3.last_name.strip().lower()
                item["paid"] = False
                ret_json.append(item)
                rep_identifier_idx_dict[item["identifier"]] = len(ret_json) - 1

            debts = UserDebt.query(UserDebt.field_app_identifier.IN(rep_ids_to_query3))
            for debt in debts:
                ret_json[rep_identifier_idx_dict[debt.field_app_identifier]]["total_debt"] = debt.total
                ret_json[rep_identifier_idx_dict[debt.field_app_identifier]]["debt_items"] = json.loads(debt.items)

            checks = CheckPayment.query(
                ndb.AND
                (
                    CheckPayment.check_date == payout_date,
                    CheckPayment.recipient.IN(rep_ids_to_query3)
                )
            )
            for check in checks:
                ret_json[rep_identifier_idx_dict[check.recipient]]["paid"] = True

        ret_json = Helpers.bubble_sort(ret_json, "last_name_lowered")

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_v2_transaction":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False

        d_vals = self.request.get("date").split("-")
        payout = date(int(d_vals[0]), int(d_vals[1]), int(d_vals[2]))
        amt = float(self.request.get("amount"))
        dollas = int(amt)
        centss = float(amt) - float(dollas)
        centss *= float(100)
        centss = round(centss, 0)
        centss = int(centss)        
        #centss = int((float(amt) - float(int(amt))) * float(100))
        debt_to_put = None
        if self.request.get("trans_type") == "collection":
            amt *= -1
            dollas *= -1
            centss *= -1
            debt = UserDebt.first(UserDebt.field_app_identifier == self.request.get("recipient"))
            if not debt is None:
                debt_items = json.loads(debt.items)
                debt_items.append({"date": str(payout), "amount": float(self.request.get("amount")) * float(-1), "description": self.request.get("description")})
                debt.items =  json.dumps(debt_items)
                debt.total += debt_items[len(debt_items) - 1]["amount"]
                debt_to_put = debt

        if self.request.get("trans_type") == "advance":
            debt = UserDebt.first(UserDebt.field_app_identifier == self.request.get("recipient"))
            if not debt is None:
                debt_items = json.loads(debt.items)
                debt_items.append({"date": str(payout), "amount": float(self.request.get("amount")), "description": self.request.get("description")})
                debt.items = json.dumps(debt_items)
                debt.total += debt_items[len(debt_items) - 1]["amount"]
                debt_to_put = debt

        v2trans = MonetaryTransactionV2(
            identifier=Helpers.guid(),
            description=self.request.get("description"),
            dollars=dollas,
            cents=centss,
            approved=True,
            denied=False,
            description_key="n/a",
            recipient=self.request.get("recipient"),
            created=Helpers.pacific_now(),
            check_number=-1,
            payout_date=payout,
            paid=False,
            field_app_identifier="n/a",
            extra_info="{}"
        )
        cp = CheckPayment.first(
            ndb.AND
            (
                CheckPayment.recipient == v2trans.recipient,
                CheckPayment.check_date == v2trans.payout_date
            )
        )
        if cp is None:
            v2trans.put()
            s_index = search.Index(name="v2_transactions")
            s_index.put(
                [search.Document(
                    fields=[
                        search.TextField(name="identifier", value=v2trans.identifier),
                        search.TextField(name="description", value=v2trans.description)
                    ]
                )]
            )
            if not (debt_to_put is None):
                debt_to_put.put()

            ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pull_debt_for_rep":
        self.response.content_type = "application/json"
        ret_json = {}
        debt = UserDebt.first(UserDebt.field_app_identifier == self.request.get("identifier"))
        if not debt is None:
            ret_json["items"] = json.loads(debt.items)
            ret_json["total"] = debt.total
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "add_item_to_rep_debt":
        self.response.content_type = "application/json"
        debt = UserDebt.first(UserDebt.field_app_identifier == self.request.get("identifier"))
        amount = float(self.request.get("amt"))
        if self.request.get("is_collection") == "1":
            amount *= float(-1)

        if not debt is None:
            items = json.loads(debt.items)
            items.append({"date": str(Helpers.pacific_today()), "amount": amount, "description": self.request.get("description")})
            debt.total += amount
            debt.items = json.dumps(items)
            debt.put()
            ret_json = {"total": debt.total}
            self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "delete_payscale":
        users_to_put = []
        us = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.payscale_key == self.request.get("value")
            )
        )
        for u in us:
            u.payscale_key = "n/a"
            users_to_put.append(u)

        ndb.put_multi(users_to_put)

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/ApplicationSettings/payscales_' + app_identity.get_application_id() + '.json'

        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                       max_delay=5.0,
                                       backoff_factor=2,
                                       max_retry_period=15,
                                       urlfetch_timeout=30)

        gcs_file = gcs.open(filename, 'r', retry_params=retryParameters)
        jaysawn = json.loads(gcs_file.read())
        gcs_file.close()
        cpy = []
        for j in jaysawn:
            if not (j["value"] == self.request.get("value")):
                cpy.append(j)

        gcs_file2 = GCSLockedFile("/ApplicationSettings/payscales_" + app_identity.get_application_id() + ".json")
        logging.info(cpy)
        gcs_file2.write(json.dumps(cpy), "text/plain")
        gcs_file2.unlock()

        memcache.delete("list_of_payscales")
        if len(users_to_put) == 1:
            users_to_put[0].put()
        elif len(users_to_put) > 1:
            ndb.put_multi(users_to_put)

    elif self.request.get("fn") == "set_distribution_list_for_office":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.distribution_list = json.dumps(json.loads(self.request.get("list")))
            office.put()

    elif self.request.get("fn") == "set_residual_overrides_for_market":
        ol = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not ol is None:
            ol.residual_overrides = (self.request.get("enabled") == "1")
            ol.put()

    elif self.request.get("fn") == "ak_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/ak_report", params={"identifier": self.request.get("identifier"), "email": self.request.get("email")})

    elif self.request.get("fn") == "office_data_v2":
        self.response.content_type = "application/json"
        ret_json = {"offices": []}
        offices = OfficeLocation.query(OfficeLocation.is_parent == True)
        office_ids_to_query = ["-1"]
        office_identifier_idx_dict = {}
        cnt = 0
        for office in offices:
            ret_json["offices"].append({"residual_overrides": office.residual_overrides, "name": office.name, "identifier": office.identifier, "offices": [], "active": office.active, "distribution_list": json.loads(office.distribution_list), "geo_data": json.loads(office.geo_data)})                        
            office_ids_to_query.append(office.identifier)
            office_identifier_idx_dict[office.identifier] = cnt
            cnt += 1

        offices2 = OfficeLocation.query(OfficeLocation.parent_identifier.IN(office_ids_to_query))
        for office in offices2:
            o_data = {"residual_overrides": office.residual_overrides, "name": office.name, "identifier": office.identifier, "active": office.active, "distribution_list": json.loads(office.distribution_list), "geo_data": json.loads(office.geo_data)}
            o_data["dive_in_weight_list"] = []
            ret_json["offices"][office_identifier_idx_dict[office.parent_identifier]]["offices"].append(o_data)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "dive_in_data":
        self.response.content_type = "application/json"
        ret = {"users": []}
        users = FieldApplicationUser.query(FieldApplicationUser.main_office == self.request.get("identifier"))
        user_identifier_idx_dict = {}
        for user in users:
            if user.accepts_leads:
                user_identifier_idx_dict[user.identifier] = len(ret["users"])
                obj = {"weight": 0}
                obj["identifier"] = user.identifier
                obj["name"] = user.first_name.strip().title() + " " + user.last_name.strip().title()
                ret["users"].append(obj)

        f = GCSLockedFile("/DiveInWeight/weight.json")
        content = f.read()
        f.unlock()
        if not content is None:
            data = json.loads(content)
            for item in data:
                identifier = item["identifier"]
                if identifier in user_identifier_idx_dict.keys():
                    user_idx = user_identifier_idx_dict[identifier]
                    ret["users"][user_idx]["weight"] = item["weight"]

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "set_dive_in_weight":
        f = GCSLockedFile("/DiveInWeight/weight.json")
        content = f.read()
        if content is None:
            content = "[]"
        data = json.loads(content)
        append = True

        for obj in data:
            if obj["identifier"] == self.request.get("identifier"):
                append = False
                obj["weight"] = int(self.request.get("weight"))

        if append:
            obj = {"identifier": self.request.get("identifier"), "weight": int(self.request.get("weight"))}
            data.append(obj)

        f.unlock()
        f.write(json.dumps(data), "application/json", "public-read")

    elif self.request.get("fn") == "rename_office_v2":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.name = self.request.get("name")
            office.put()

    elif self.request.get("fn") == "office_remove_v2":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = False
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            user = FieldApplicationUser.first(FieldApplicationUser.main_office == self.request.get("identifier"))
            if user is None:
                office.key.delete()
                ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "office_reassignment_v2":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            office.parent_identifier = self.request.get("parent")
            office.put()

    elif self.request.get("fn") == "phix_ghosted_transactions":
        transactions = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.paid == False,
                MonetaryTransactionV2.payout_date == date(2016, 9, 9)
            )
        )
        transactions_to_put = []
        for t in transactions:
            t.paid = True
            transactions_to_put.append(t)

        ndb.put_multi(transactions_to_put)
        logging.info(len(transactions_to_put))

    elif self.request.get("fn") == "duplicate_users":
        ids = []
        dupes = []
        users = FieldApplicationUser.query(FieldApplicationUser.identifier != "")
        for u in users:
            if not u.identifier in ids:
                ids.append(u.identifier)
            else:
                dupes.append(u.identifier)

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(dupes))

    elif self.request.get("fn") == "list_users_in_given_office":
        self.response.content_type = "application/json"
        ret_json = []
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.main_office == self.request.get("identifier"),
                FieldApplicationUser.current_status == 0
            )
        )

        for user in users:
            ret_json.append({"identifier": user.identifier, "rep_id": user.rep_id, "name": user.first_name.strip().title() + " " + user.last_name.strip().title()})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "read_pricing_structures":
        self.response.content_type = "application/json"
        ret_json = {"data": Helpers.get_pricing_structures()}        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "list_markets":
        self.response.content_type = "application/json"
        ret_json = {"markets": []}
        markets = OfficeLocation.query(OfficeLocation.is_parent == True)
        for market in markets:
            ret_json["markets"].append({"identifier": market.identifier, "name": market.name})

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_pricing_structure":
        f = GCSLockedFile("/ApplicationSettings/pricing_structures_" + app_identity.get_application_id() + ".json")
        content = f.read()
        if not content is None:
            parsed = json.loads(content)
            if not self.request.get("market") in parsed.keys():
                parsed[self.request.get("market")] = {}
            parsed[self.request.get("market")][self.request.get("key")] = self.request.get("value")
            try:
                f.unlock()
            except:
                f = f

            f2 = GCSLockedFile("/ApplicationSettings/pricing_structures_" + app_identity.get_application_id() + ".json")
            try:
                f2.write(json.dumps(parsed), "text/plain")
                memcache.delete("pricing_structures")
            except:
                f2 = f2

    elif self.request.get("fn") == "ghosted_transactions":
        self.response.content_type = "application/json"
        ret_json = {}
        d_t = self.request.get("date").split("_")
        dayte = date(int(d_t[0]), int(d_t[1]), int(d_t[2]))
        transacts = MonetaryTransactionV2.query(
            ndb.AND
            (
                MonetaryTransactionV2.approved == True,
                MonetaryTransactionV2.denied == False,
                MonetaryTransactionV2.paid == False,                
                MonetaryTransactionV2.payout_date == dayte
            )
        )

        data = []
        cpy = []
        rep_ids_to_query = ["-1"]
        for t in transacts:
            cpy.append(t)
            rep_ids_to_query.append(t.recipient)

        recipient_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for r in reps:
            recipient_name_dict[r.identifier] = r.first_name.strip().title() + " " + r.last_name.strip().title()

        for c in cpy:
            data.append({"identifier": c.identifier,
                         "recipient": recipient_name_dict[c.recipient],
                         "amount": str(float(c.dollars) + float(c.cents / float(100))),
                         "created": str(c.created),
                         "description": c.description
                         })
        self.response.out.write(json.dumps(data))

    elif self.request.get("fn") == "update_doc_display_status":
        doc = ComposedDocument.first(ComposedDocument.identifier == self.request.get("identifier"))
        if not doc is None:
            doc.displayed = (self.request.get("displayed") == "1")
            doc.put()

    elif self.request.get("fn") == "new_usage_info_for_customer":
        self.response.content_type = "application/json"
        ret_json = {}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            try:
                ret_json = {"total_kwhs": app_entry.total_kwhs, "total_dollars": app_entry.total_dollars, "highest_amount": app_entry.highest_amount}
            except:
                ret_json = ret_json

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "upload_contractor_image_data":
        bucket_name = os.environ.get(
                    'BUCKET_NAME',
                    app_identity.get_default_gcs_bucket_name()
                )
        bucket = '/' + bucket_name
        write_retry_params = gcs.RetryParams(backoff_factor=1.1)

        filename = bucket + "/MarketSettings/Contractors/" + self.request.get("sub_folder") + "/" + self.request.get("market") + ".jpg"
        file_content = self.request.POST.multi["img"].file.read()
        gcs_file1 = gcs.open(
            filename,
            'w',
            content_type="image/jpeg",
            options={
                'x-goog-meta-foo': 'foo',
                'x-goog-meta-bar': 'bar',
                'x-goog-acl': 'public-read',
                'cache-control': 'public, max-age=0'
            },
            retry_params=write_retry_params)

        gcs_file1.write(file_content)
        gcs_file1.close()

    elif self.request.get("fn") == "to_do_reminder_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/to_do_reminders", params={})


    elif self.request.get("fn") == "override_data_for_office":
        self.response.content_type = "application/json"
        ret_json = {"data": {}}
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("identifier"))
        if not office is None:
            ret_json["data"] = office.get_override_data()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_assigned_to_dos":
        self.response.content_type = "application/json"
        ret_json = {"to_dos": []}
        todos = ToDoItem.query(ToDoItem.assigner == self.request.get("assigner"))
        app_ids_to_query = ["-1"]
        assigners_to_query = ["-1"]
        owners_to_query = ["-1"]
        app_identifier_name_dict = {"-1": "N/A"}
        owner_identifier_name_dict = {"-1": "N/A"}
        assigner_identifier_name_dict = {"-1": "N/A"}
        linked_identifiers_list = []
        for t in todos:
            if not (t.owner == self.request.get("assigner")):
                collaborative = str(int((len(json.loads(t.linked_identifiers)) > 0)))
                obj = {"identifier": t.identifier, "field_app_identifier": t.field_app_identifier, "name": t.name, "completed": t.completed, "notes": t.notes, "due_dt": str(t.due_dt), "reminder_dt": str(t.reminder_dt), "completed_dt": str(t.completed_dt), "assigner": t.assigner, "owner": t.owner, "daily_reminder": t.daily_reminder, "weekly_reminder": t.weekly_reminder, "monthly_reminder": t.monthly_reminder, "collaborative": collaborative}
                if collaborative == "1":
                    if not t.linked_identifiers in linked_identifiers_list:
                        ret_json["to_dos"].append(obj)
                        linked_identifiers_list.append(t.linked_identifiers)
                else:
                    ret_json["to_dos"].append(obj)
                if not t.identifier in app_ids_to_query:
                    app_ids_to_query.append(t.field_app_identifier)
                if not t.owner in owners_to_query:
                    owners_to_query.append(t.owner)
                if not t.assigner in assigners_to_query:
                    assigners_to_query.append(t.assigner)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        assigners = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(assigners_to_query))
        for assigner in assigners:
            assigner_identifier_name_dict[assigner.identifier] = assigner.first_name.strip().title() + " " + assigner.last_name.strip().title()
        
        owners = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(owners_to_query))
        for owner in owners:
            owner_identifier_name_dict[owner.identifier] = owner.first_name.strip().title() + " " + owner.last_name.strip().title()

        for item in ret_json["to_dos"]:
            item["customer_name"] = app_identifier_name_dict[item["field_app_identifier"]]
            item["assigner_name"] = assigner_identifier_name_dict[item["assigner"]]
            item["owner_name"] = owner_identifier_name_dict[item["owner"]]


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_to_dos":
        self.response.content_type = "application/json"
        ret_json = {"to_dos": []}
        completed = bool(int(self.request.get("completed")))
        todos = ToDoItem.query(
            ndb.AND(
                ToDoItem.owner == self.request.get("identifier"),
                ToDoItem.completed == completed
            )
        )
        app_ids_to_query = ["-1"]
        assigners_to_query = ["-1"]
        owners_to_query = ["-1"]
        app_identifier_name_dict = {"-1": "N/A"}
        owner_identifier_name_dict = {"-1": "N/A"}
        assigner_identifier_name_dict = {"-1": "N/A"}
        for t in todos:
            collaborative = str(int((len(json.loads(t.linked_identifiers)) > 0)))
            obj = {"identifier": t.identifier, "field_app_identifier": t.field_app_identifier, "name": t.name, "completed": t.completed, "notes": t.notes, "due_dt": str(t.due_dt), "reminder_dt": str(t.reminder_dt), "completed_dt": str(t.completed_dt), "assigner": t.assigner, "owner": t.owner, "daily_reminder": t.daily_reminder, "monthly_reminder": t.monthly_reminder, "weekly_reminder": t.weekly_reminder, "collaborative": collaborative}
            ret_json["to_dos"].append(obj)
            if not t.identifier in app_ids_to_query:
                app_ids_to_query.append(t.field_app_identifier)
            if not t.owner in owners_to_query:
                owners_to_query.append(t.owner)
            if not t.assigner in assigners_to_query:
                assigners_to_query.append(t.assigner)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        assigners = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(assigners_to_query))
        for assigner in assigners:
            assigner_identifier_name_dict[assigner.identifier] = assigner.first_name.strip().title() + " " + assigner.last_name.strip().title()
        
        owners = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(owners_to_query))
        for owner in owners:
            owner_identifier_name_dict[owner.identifier] = owner.first_name.strip().title() + " " + owner.last_name.strip().title()

        for item in ret_json["to_dos"]:
            item["customer_name"] = app_identifier_name_dict[item["field_app_identifier"]]
            item["assigner_name"] = assigner_identifier_name_dict[item["assigner"]]
            item["owner_name"] = owner_identifier_name_dict[item["owner"]]


        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_to_do_reminder":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            setattr(to_do, self.request.get("type") + "_reminder", (self.request.get("checked") == "1"))
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    setattr(t, self.request.get("type") + "_reminder", (self.request.get("checked") == "1"))
                    t.put()

    elif self.request.get("fn") == "update_todo_reminder_date":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            old_dt = to_do.reminder_dt
            dt_vals = self.request.get("dt").split("-")
            new_dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), old_dt.hour, old_dt.minute, old_dt.second)
            to_do.reminder_dt = new_dt
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.reminder_dt = new_dt
                    t.put()

    elif self.request.get("fn") == "update_todo_reminder_hour":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            old_dt = to_do.reminder_dt
            new_dt = datetime(old_dt.year, old_dt.month, old_dt.day, int(self.request.get("hour")), 0, 0)
            to_do.reminder_dt = new_dt
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.reminder_dt = new_dt
                    t.put()

    elif self.request.get("fn") == "update_todo_due_date":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            old_dt = to_do.due_dt
            dt_vals = self.request.get("dt").split("-")
            new_dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), old_dt.hour, old_dt.minute, old_dt.second)
            to_do.due_dt = new_dt
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.due_dt = new_dt
                    t.put()

    elif self.request.get("fn") == "update_todo_due_hour":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            old_dt = to_do.due_dt
            new_dt = datetime(old_dt.year, old_dt.month, old_dt.day, int(self.request.get("hour")), 0, 0)
            to_do.due_dt = new_dt
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.due_dt = new_dt
                    t.put()

    elif self.request.get("fn") == "set_notes_for_to_do":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            to_do.notes = self.request.get("notes")
            to_do.put()
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.notes = self.request.get("notes")
                    t.put()

    elif self.request.get("fn") == "reassign_to_do_item":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            to_do.owner = self.request.get("owner")
            to_do.put()

    elif self.request.get("fn") == "rename_to_do_item":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            to_do.name = self.request.get("name")
            to_do.put()

            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.name = self.request.get("name")
                    t.put()

    elif self.request.get("fn") == "create_to_do":
        owners = json.loads(self.request.get("owners"))
        new_identifiers = []
        for owner in owners:
            new_identifiers.append(Helpers.guid())

        linked_identifiers = []
        if self.request.get("mode") == "collaborative":
            linked_identifiers = new_identifiers
        cnt = 0
        for o in owners:
            item = ToDoItem(
                identifier=new_identifiers[cnt],
                owner=o,
                assigner=self.request.get("assigner"),
                field_app_identifier=self.request.get("field_app_identifier"),
                name=self.request.get("name"),
                completed=False,
                notes=self.request.get("notes"),
                completed_dt=datetime(1970, 1, 1),
                reminder_sent=False,
                daily_reminder=(str(self.request.get("daily_reminder")) == "1"),
                weekly_reminder=(str(self.request.get("weekly_reminder")) == "1"),
                monthly_reminder=(str(self.request.get("monthly_reminder")) == "1"),
                linked_identifiers=json.dumps(linked_identifiers)
            )
            reminder_date_vals = self.request.get("reminder_dt").split("-")
            reminder_dt = datetime(int(reminder_date_vals[2]), int(reminder_date_vals[0]), int(reminder_date_vals[1]), int(self.request.get("reminder_hour")), 0, 0)
            
            due_date_vals = self.request.get("due_dt").split("-")
            due_dt = datetime(int(due_date_vals[2]), int(due_date_vals[0]), int(due_date_vals[1]), int(self.request.get("due_hour")), 0, 0)

            item.reminder_dt = reminder_dt
            item.due_dt = due_dt

            item.put()

            if not item.owner == item.assigner:
                owner = FieldApplicationUser.first(FieldApplicationUser.identifier == item.owner)
                assigner = FieldApplicationUser.first(FieldApplicationUser.identifier == item.assigner)
                if (not owner is None) and (not assigner is None):
                    subj = "New To-Do Item from " + assigner.first_name.strip().title() + " " + assigner.last_name.strip().title()
                    msg = item.name + "\r\n\r\n" + item.notes + "\r\n\r\n" + "Due: " + due_dt.strftime("%m/%d/%Y %I:%M %p")
                    Helpers.send_email(owner.rep_email, subj, msg)

            cnt += 1


    elif self.request.get("fn") == "to_do_item_completion_status":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            h_p_n = Helpers.pacific_now()
            to_do.completed = (self.request.get("completed") == "1")
            to_do.completed_dt = h_p_n
            to_do.put()

            if to_do.completed:
                owner = FieldApplicationUser.first(FieldApplicationUser.identifier == to_do.owner)
                assigner = FieldApplicationUser.first(FieldApplicationUser.identifier == to_do.assigner)
                if (not owner is None) and (not assigner is None):
                    if not owner.identifier == assigner.identifier:
                        if not owner.identifier == "-1":
                            if not assigner.identifier == "-1":
                                Helpers.send_sms(assigner.rep_phone, owner.first_name.strip().title() + " " + owner.last_name.strip().title() + " has completed the following to-do item: " + to_do.name)
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = []
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.completed = (self.request.get("completed") == "1")
                    t.completed_dt = h_p_n
                    t.put()

    elif self.request.get("fn") == "drop_to_do":
        to_do = ToDoItem.first(ToDoItem.identifier == self.request.get("identifier"))
        if not to_do is None:
            
            linked_identifiers = json.loads(to_do.linked_identifiers)
            if len(linked_identifiers) > 0:
                cpy = ["-1"]
                for item in linked_identifiers:
                    if not item == to_do.identifier:
                        cpy.append(item)

                to_dos = ToDoItem.query(ToDoItem.identifier.IN(cpy))
                for t in to_dos:
                    t.key.delete()
            
            to_do.key.delete()



    elif self.request.get("fn") == "seed_to_do_items":
        cnt = 0
        while cnt < 50:
            num = cnt + 1
            num = str(num)
            item = ToDoItem(
                identifier=Helpers.guid(),
                owner="38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c",
                field_app_identifier="-1",
                name="Item # " + num,
                completed=False,
                notes="Notes about item #" + num,
                due_dt=(Helpers.pacific_now() + timedelta(days=30)) + timedelta(days=int(num)),
                reminder_dt=(Helpers.pacific_now() + timedelta(days=30)) + timedelta(days=int(num)),
                completed_dt=datetime(1970, 1, 1),
                reminder_sent=False
            )
            item.put()
            cnt += 1

        while cnt < 100:
            num = cnt + 1
            num = str(num)
            item = ToDoItem(
                identifier=Helpers.guid(),
                owner="38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c",
                field_app_identifier="-1",
                name="Item # " + num,
                completed=True,
                notes="Notes about item #" + num,
                due_dt=(Helpers.pacific_now() + timedelta(days=30)) + timedelta(days=int(num)),
                reminder_dt=(Helpers.pacific_now() + timedelta(days=30)) + timedelta(days=int(num)),
                completed_dt=datetime(1970, 1, 1),
                reminder_sent=False
            )
            item.put()
            cnt += 1
        

    elif self.request.get("fn") == "get_rep_names_from_identifiers":
        self.response.content_type = "application/json"        
        ids = json.loads(self.request.get("identifiers"))
        ret_json = {"map": {}}
        if len(ids) > 0:
            users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(ids))
            for u in users:
                ret_json["map"][u.identifier] = u.first_name.strip().title() + " " + u.last_name.strip().title()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_market_ids":
        self.response.content_type = "text/plain"
        buff = ""
        markets = OfficeLocation.query(OfficeLocation.is_parent == True)
        for market in markets:
            buff += market.name + ":\r\n" + market.identifier + "\r\n\r\n\r\n"
        self.response.out.write(buff)

    elif self.request.get("fn") == "closing_details":
        self.response.content_type = "application/json"
        ret_json = {"closer": None}
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "closer" in info.keys():
                rep = FieldApplicationUser.first(FieldApplicationUser.identifier == info["closer"])
                if not rep is None:
                    ret_json["closer"] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "delete_customer_note":
        note = CustomerNote.first(CustomerNote.identifier == self.request.get("identifier"))
        if not note is None:
            note.key.delete()

    elif self.request.get("fn") == "update_customer_note":
        note = CustomerNote.first(CustomerNote.identifier == self.request.get("identifier"))
        if not note is None:
            content = json.loads(note.content)
            content["txt"][0] = self.request.get("content")
            note.content = json.dumps(content)
            note.put()

    elif self.request.get("fn") == "delete_closer":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            if "closer" in info.keys():
                del info["closer"]
                pp_sub.extra_info = json.dumps(info)
                pp_sub.put()

    elif self.request.get("fn") == "assign_as_closer_for_project":
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if not pp_sub is None:
            info = json.loads(pp_sub.extra_info)
            info["closer"] = self.request.get("closer")
            pp_sub.extra_info = json.dumps(info)
            pp_sub.put()

    elif self.request.get("fn") == "drive_rename_test":
        Helpers.rename_file_in_google_drive("kk", "Renamed Folder Part 2")

    elif self.request.get("fn") == "list_required_actions":
        self.response.content_type = "application/json"
        ret_json = {"actions": []}
        actions = RepRequiredAction.query(
            ndb.AND
            (
                RepRequiredAction.action_key == self.request.get("action_key"),
                RepRequiredAction.rep_identifier == self.session["user_identifier"],
                RepRequiredAction.completed == datetime(1970, 1, 1)
            )
        )
        field_app_ids_to_query = ["-1"]        
        field_app_identifier_action_idx_dict = {}
        acts = []
        for action in actions:
            acts.append({"identifier": action.identifier, "message": json.loads(action.message)["required_action"], "field_app_identifier": action.field_app_identifier, "created": action.created})
            field_app_ids_to_query.append(action.field_app_identifier)
            field_app_identifier_action_idx_dict[action.field_app_identifier] = len(field_app_ids_to_query) - 2
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(field_app_ids_to_query))
        for app_entry in app_entries:
            acts[field_app_identifier_action_idx_dict[app_entry.identifier]]["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
        if len(acts) > 1:
            acts = Helpers.bubble_sort(acts, "created")    
        ret_json["actions"] = acts
        for act in acts:
            act["created"] = str(act["created"].date())
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "respond_to_required_action":
        rra = RepRequiredAction.first(RepRequiredAction.identifier == self.request.get("identifier"))
        if not rra is None:
            rra.completed = Helpers.pacific_now()
            msg = json.loads(rra.message)
            msg["rep_response"] = self.request.get("response")
            rra.message = json.dumps(msg)
            rra.put()

        if self.request.get("action_key") == "proposal_incomplete":
            if not rra is None:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == rra.field_app_identifier)
                if not app_entry is None:
                    app_entry.proposal_state = 1
                    app_entry.put()

                    n = Notification.first(Notification.action_name == "Incomplete Proposal Follow-Up")
                    if not n is None:
                        for person in n.notification_list:
                            Helpers.send_email(person.email_address, "Follow-Up on " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s Incomplete Proposal", "Message from Rep:\r\n" + self.request.get("response"))

    elif self.request.get("fn") == "init_market_override_data":
        offices = OfficeLocation.query(OfficeLocation.is_parent == False)
        for office in offices:
            office.set_override_data({"recipients": [], "data": {}, "yielders": [], "other_accounts": {}})

    elif self.request.get("fn") == "test_read_market_data":
        office = OfficeLocation.first(OfficeLocation.is_parent == True)
        if not office is None:
            self.response.out.write(json.dumps(office.get_override_data()))

    elif self.request.get("fn") == "kilowatt_install_report_A":
        app_identifier_rep_id_dict = {}
        app_entries_to_query = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.deal_closed == True)
        for app_entry in app_entries:
            app_entries_to_query.append(app_entry.identifier)
            app_identifier_rep_id_dict[app_entry.identifier] = app_entry.rep_id

        f = GCSLockedFile("/kw_report_1.txt")
        f.write(json.dumps(app_entries_to_query), "text/plain", "public-read")
        f2 = GCSLockedFile("kw_report_2.txt")
        f2.write(json.dumps(app_identifier_rep_id_dict), "text/plain", "public-read")
        time.sleep(5)
        self.redirect("/data?fn=kilowatt_install_report_B")

    elif self.request.get("fn") == "kilowatt_install_report_B":
        new_app_ids = ["-1"]
        f = GCSLockedFile("/kw_report_1.txt")
        app_ids_to_query = json.loads(f.read())
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                checkoff_dict = info["project_management_checkoffs"]
                if ("install" in checkoff_dict.keys() and checkoff_dict["install"]["checked"]) or ("received_pto" in checkoff_dict.keys() and checkoff_dict["received_pto"]["checked"]):
                    new_app_ids.append(pp_sub.field_application_identifier)
        f2 = GCSLockedFile("/kw_report_3.txt")
        f2.write(json.dumps(new_app_ids), "text/plain", "public-read")
        time.sleep(5)
        self.redirect("/data?fn=kilowatt_install_report_C")

    elif self.request.get("fn") == "kilowatt_install_report_C":
        rep_id_total_system_size_dict = {}
        f = GCSLockedFile("/kw_report_2.txt")
        app_identifier_rep_id_dict = json.loads(f.read())
        f2 = GCSLockedFile("/kw_report_3.txt")
        app_ids_to_query = json.loads(f2.read())
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        for proposal in proposals:
            proposal.fix_system_size()
            rep_id = app_identifier_rep_id_dict[proposal.field_app_identifier]
            if not rep_id in rep_id_total_system_size_dict.keys():
                rep_id_total_system_size_dict[rep_id] = float(0)
            rep_id_total_system_size_dict[rep_id] += float(json.loads(proposal.info)["system_size"])
        f3 = GCSLockedFile("/kw_report_4.txt")
        f3.write(json.dumps(rep_id_total_system_size_dict), "text/plain", "public-read")
        time.sleep(5)
        self.redirect("/data?fn=kilowatt_install_report_D")

    elif self.request.get("fn") == "kilowatt_install_report_D":
        rep_id_name_dict = {}
        f = GCSLockedFile("/kw_report_4.txt")
        data = json.loads(f.read())
        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(data.keys()))
        for rep in reps:
            rep_id_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        outp = []
        for item in data.keys():
            try:
                outp.append({"name": rep_id_name_dict[item], "rep_id": item, "total_kw_sold": data[item]})
            except:
                outp.append({"name": "Unknown Person", "rep_id": item, "total_kw_sold": data[item]})
        self.response.out.write(json.dumps(outp))

    elif self.request.get("fn") == "add_override_recipient_o_and_m":
        recipient = self.request.get("identifier")
        ol = OfficeLocation.first(OfficeLocation.identifier == self.request.get("office"))
        users = FieldApplicationUser.query(
            ndb.AND
            (
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.main_office == self.request.get("office")
            )
        )
        if not ol is None:
            o_data = ol.get_override_data()
            o_data["recipients"].append(recipient)
            recipients_cpy = []
            for item in o_data["recipients"]:
                if not item in recipients_cpy:
                    recipients_cpy.append(item)
            o_data["recipients"] = recipients_cpy
            for user in users:
                if not user.identifier in o_data["yielders"]:
                    o_data["yielders"].append(user.identifier)
                if not user.identifier in o_data["data"].keys():
                    o_data["data"][user.identifier] = []
                o_data["data"][user.identifier].append({"identifier": recipient, "amount": self.request.get("amount")})

            yielders_cpy = []
            for item in o_data["yielders"]:
                if not item in yielders_cpy:
                    yielders_cpy.append(item)
            o_data["yielders"] = yielders_cpy

            for key in o_data["data"].keys():
                lst = o_data["data"][key]
                lst_cpy = []
                recipients_found = []
                for item in lst:
                    if not item["identifier"] in recipients_found:
                        lst_cpy.append(item)
                o_data["data"][key] = lst_cpy
            
            ol.set_override_data(o_data)

    elif self.request.get("fn") == "update_override_data_for_office":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("office"))
        if not office is None:
            user = FieldApplicationUser.first(
                ndb.AND
                (
                    FieldApplicationUser.identifier == self.request.get("user"),
                    FieldApplicationUser.main_office == self.request.get("office")
                )
            )
            if not user is None:
                if not user.current_status == -1 and user.main_office == self.request.get("office"):
                    o_data = office.get_override_data()
                    o_data["recipients"].append(self.request.get("recipient"))
                    recipients_cpy = []
                    for item in o_data["recipients"]:
                        if not item in recipients_cpy:
                            recipients_cpy.append(item)
                    o_data["recipients"] = recipients_cpy
                    o_data["yielders"].append(self.request.get("user"))
                    yielders_cpy = []
                    for item in o_data["yielders"]:
                        if not item in yielders_cpy:
                            yielders_cpy.append(item)
                    o_data["yielders"] = yielders_cpy
                    if not self.request.get("user") in o_data["data"].keys():
                        o_data["data"][self.request.get("user")] = []

                    append = True
                    modification_idx = -1
                    cnt = -1
                    for item in o_data["data"][self.request.get("user")]:
                        if modification_idx > -1:
                            continue

                        cnt += 1
                        if item["identifier"] == self.request.get("recipient"):
                            append = False
                            modification_idx = cnt

                    if append:
                        o_data["data"][self.request.get("user")].append({"identifier": self.request.get("recipient"), "amount": self.request.get("amount")})
                    else:
                        o_data["data"][self.request.get("user")][modification_idx]["amount"] = self.request.get("amount")

                    office.set_override_data(o_data)

    elif self.request.get("fn") == "set_other_amount_for_recipient":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("office"))
        if not office is None:
            o_data = office.get_override_data()
            o_data["other_accounts"][self.request.get("recipient")] = self.request.get("amount")
            office.set_override_data(o_data)

    elif self.request.get("fn") == "purge_office_override_recipient":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("office"))
        if not office is None:
            office.purge_recipient(self.request.get("recipient"))

    elif self.request.get("fn") == "purge_office_override_yielder":
        office = OfficeLocation.first(OfficeLocation.identifier == self.request.get("office"))
        if not office is None:
            office.purge_yielder(self.request.get("yielder"))

    elif self.request.get("fn") == "drop_payroll_state_for_customer":
        options_dict = {"WC Complete": "welcome_call_completed", "Construction Complete": "final_payment_requested_received"}
        if self.request.get("option") in options_dict.keys():
            ps = PayrollCustomerState.first(
                ndb.AND(
                    PayrollCustomerState.field_app_identifier == self.request.get("identifier"),
                    PayrollCustomerState.state_key == options_dict[self.request.get("option")]
                )
            )
            if not ps is None:
                ps.key.delete()

                if len(str(self.request.get("user"))) == 128:
                    CustomerTranscriber.transcribe_text(self.request.get("identifier"), self.request.get("user"), "This customer was manually removed from the '" + self.request.get("option") + "' payroll state.")

        if self.request.get("option") == "V3":
            states = PayrollCustomerStateV3.query(PayrollCustomerStateV3.field_app_identifier == self.request.get("identifier"))
            for state in states:
                state.key.delete()

            if len(str(self.request.get("user"))) == 128:
                CustomerTranscriber.transcribe_text(self.request.get("identifier"), self.request.get("user"), "This customer was manually removed from the '" + self.request.get("option") + "' payroll state.")

        self.response.content_type = "application/json"
        ret_json = {}
        self.response.out.write(json.dumps(ret_json))



    elif self.request.get("fn") == "payroll_search":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["results"] = []
        index_dict = {"customer": "cust_names", "rep": "app_users", "description": "v2_transactions"}
        identifier_dict = {"customer": "cust_identifier", "rep": "identifier", "description": "identifier"}

        ids_to_query = ["-1"]
        index = search.Index(name=index_dict[self.request.get("search_type")])

        cursor = search.Cursor()

        while cursor:
            # Build the query using the cursor.
            options = search.QueryOptions(cursor=cursor)
            query = search.Query(query_string=self.request.get("query"), options=options)

            # Get the results and the next cursor
            results = index.search(query)
            cursor = results.cursor

            results = index.search(self.request.get("query"))
            for result in results:
                for field in result.fields:
                    if field.name == identifier_dict[self.request.get("search_type")]:
                        ids_to_query.append(field.value)

        transactions = []
        if self.request.get("search_type") == "customer":
            transactions = MonetaryTransactionV2.query(
                ndb.AND(
                    MonetaryTransactionV2.field_app_identifier.IN(ids_to_query),
                    MonetaryTransactionV2.payout_date >= (Helpers.pacific_now() + timedelta(days=-90)).date(),
                    MonetaryTransactionV2.payout_date <= (Helpers.pacific_now() + timedelta(days=90)).date()
                )
            )#.order(-MonetaryTransactionV2.payout_date)

        elif self.request.get("search_type") == "rep":
            transactions = MonetaryTransactionV2.query(
                ndb.AND(
                    MonetaryTransactionV2.recipient.IN(ids_to_query),
                    MonetaryTransactionV2.payout_date >= (Helpers.pacific_now() + timedelta(days=-90)).date(),
                    MonetaryTransactionV2.payout_date <= (Helpers.pacific_now() + timedelta(days=90)).date()
                )
            )#.order(-MonetaryTransactionV2.payout_date)
        elif self.request.get("search_type") == "description":
            transactions = MonetaryTransactionV2.query(
                ndb.AND(
                    MonetaryTransactionV2.identifier.IN(ids_to_query),
                    MonetaryTransactionV2.payout_date >= (Helpers.pacific_now() + timedelta(days=-90)).date(),
                    MonetaryTransactionV2.payout_date <= (Helpers.pacific_now() + timedelta(days=90)).date()
                )
            )#.order(-MonetaryTransactionV2.payout_date)

        recipients_to_query = ["-1"]
        app_entries_to_query = ["-1"]
        recipient_identifier_idx_list = {}
        customer_identifier_idx_list = {}
        for t in transactions:
            if not t.recipient in recipients_to_query:
                recipients_to_query.append(t.recipient)
            if not t.field_app_identifier == "n/a":
                app_entries_to_query.append(t.field_app_identifier)

                if not t.field_app_identifier in customer_identifier_idx_list.keys():
                    customer_identifier_idx_list[t.field_app_identifier] = []
                customer_identifier_idx_list[t.field_app_identifier].append(len(ret_json["results"]))

            if not t.recipient in recipient_identifier_idx_list.keys():
                recipient_identifier_idx_list[t.recipient] = []

            recipient_identifier_idx_list[t.recipient].append(len(ret_json["results"]))

            result = {"identifier": t.identifier, "amount": str(float(t.dollars) + float(t.cents / float(100))), "description": t.description, "payout_date": str(t.payout_date), "description_key": t.description_key, "recipient": "Unknown Recipient", "customer": "N/A", "dt": t.payout_date}
            ret_json["results"].append(result)

        us = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(recipients_to_query))
        for user in us:
            if user.identifier in recipient_identifier_idx_list.keys():
                for idx in recipient_identifier_idx_list[user.identifier]:
                    ret_json["results"][idx]["recipient"] = user.first_name.strip().title() + " " + user.last_name.strip().title()

        customers = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_entries_to_query))
        for customer in customers:
            if customer.identifier in customer_identifier_idx_list.keys():
                for idx in customer_identifier_idx_list[customer.identifier]:
                    ret_json["results"][idx]["customer"] = customer.customer_first_name.strip().title() + " " + customer.customer_last_name.strip().title()

        #ret_json["results"] = Helpers.bubble_sort(ret_json["results"], "dt")
        for item in ret_json["results"]:
            del item["dt"]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "update_slide_color_options":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("identifier"))
        if not slide is None:
            opts = json.loads(slide.options)
            for key in ["background", "color"]:
                opts[key] = self.request.get(key)
            slide.options = json.dumps(opts)
            slide.put()

    elif self.request.get("fn") == "update_data_binding_for_slide_item_component":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["data_binding"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_data_formatting_for_slide_item_component":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["data_formatting"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()
    elif self.request.get("fn") == "test_delete_doc_from_search":
        idx = search.Index(name="v2_transactions")
        results = idx.search("511025f220fa63c3263b7d44e76864fa7543a3de40fbe2f614cd7b4e7599d1edc4e1094c23c59f03292c0b5708b15beaf20227ddf770cb2e8580e827a1625e27")
        for result in results:
            Helpers.delete_search_document("v2_transactions", result.doc_id)

    elif self.request.get("fn") == "url_shorten_test":
        self.response.out.write(Helpers.shorten_url("http://www.huffingtonpost.com"))
    elif self.request.get("fn") == "shorten_url":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["url"] = Helpers.shorten_url(self.request.get("url"))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "backfill_installs":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill_installs", params={})

    elif self.request.get("fn") == "fix_offsets_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/phix_offsets", params={})

    elif self.request.get("fn") == "oops_i_broke_it":
        yesterday = Helpers.pacific_now() + timedelta(hours=-24)
        yesterday_start = datetime(yesterday.year, yesterday.month, yesterday.day)
        yesterday_end = datetime(yesterday.year, yesterday.month, yesterday.day, 23, 59, 59)
        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.dt >= yesterday_start,
                LeaderBoardStat.dt <= yesterday_end
            )
        )
        for stat in stats:
            if stat.metric_key == "hours_knocked":
                stat.key.delete()

    elif self.request.get("fn") == "record_hours_knocked_kickoff":
        from google.appengine.api import taskqueue
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        user_lst = []
        for user in users:
            user_lst.append(user.identifier)
        if len(user_lst) > 0:
            taskqueue.add(url="/tq/record_hours_knocked", params={"users": json.dumps(user_lst)})

    elif self.request.get("fn") == "record_hours_knocked_v2_kickoff":
        from google.appengine.api import taskqueue
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        user_lst = []
        for user in users:
            user_lst.append(user.identifier)
        if len(user_lst) > 0:
            taskqueue.add(url="/tq/record_hours_knocked_v2", params={"users": json.dumps(user_lst)})

    elif self.request.get("fn") == "seed_search_docs_kicoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/seed_transactions_search", params={})

    elif self.request.get("fn") == "backfill_user_points":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill_user_points", params={})

    elif self.request.get("fn") == "create_super_user":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        user = FieldApplicationUser.first(FieldApplicationUser.rep_id == self.request.get("rep_id"))
        if not user is None:
            ret_json["error_message"] = "A user with the same rep ID already exists"
        else:
            user2 = FieldApplicationUser.first(FieldApplicationUser.rep_email == self.request.get("email").lower().strip())
            if not user2 is None:
                ret_json["error_message"] = "A user with the same email already exists"
            else:
                ret_json["success"] = True
                user_id = Helpers.guid()
                usr = FieldApplicationUser(
                    address=self.request.get("address"),
                    allowed_functions="[]",
                    allowed_offices="[]",
                    automatic_override_amount=float(10),
                    automatic_override_designee="AZ0230",
                    automatic_override_enabled=False,
                    city=self.request.get("city"),
                    current_status=0,
                    first_name=self.request.get("first_name"),
                    identifier=user_id,
                    last_name=self.request.get("last_name"),
                    main_office=self.request.get("office"),
                    password=Helpers.hash_pass(hashlib.md5(user_id).hexdigest().lower()),
                    payscale_key="n/a",
                    postal=self.request.get("postal"),
                    recruiter_rep_id="AZ0230",
                    registration_date=Helpers.pacific_today(),
                    rep_email=self.request.get("email"),
                    rep_id=self.request.get("rep_id"),
                    rep_phone=self.request.get("phone"),
                    sales_rabbit_id=-1,
                    state=self.request.get("state").upper(),
                    user_type="super",
                    is_manager=False,
                    is_project_manager=False,
                    accepts_leads=False
                )
                usr.put()
                points_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "user_points_" + user_id)
                if points_kv is None:
                    points_kv = KeyValueStoreItem(
                        identifier=Helpers.guid(),
                        keyy="user_points_" + user_id,
                        val="0",
                        expiration=datetime(1970, 1, 1)
                    )
                    points_kv.put()
                Helpers.send_email(self.request.get("email"), "New Power Field App Admin Account", "Below are your account details for https://" + app_identity.get_application_id() + ".appspot.com\r\n\r\nLogin: " + self.request.get("email") + "\r\nPassword: " + hashlib.md5(user_id).hexdigest().lower())
                ret_json["identifier"] = user_id

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "enumerate_child_only_offices":
        self.response.content_type = "application/json"
        ret_json = {"offices": []}
        ols = OfficeLocation.query(
            ndb.AND
            (
                OfficeLocation.is_parent == False,
                OfficeLocation.active == True
            )
        )
        for ol in ols:
            ret_json["offices"].append({"identifier": ol.identifier, "name": ol.name, "lowered": ol.name.lower()})

        if len(ret_json["offices"]) > 0:
            ret_json["offices"] = Helpers.bubble_sort(ret_json["offices"], "lowered")
            for o in ret_json["offices"]:
                del o["lowered"]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "reassign_customer_office":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier1"))
        if not app_entry is None:
            app_entry.office_identifier = self.request.get("identifier2")
            usr = FieldApplicationUser.first(FieldApplicationUser.identifier == self.session["user_identifier"])
            if not usr is None:
                CustomerTranscriber.transcribe(app_entry, usr, "customer_office_reassignment")
                app_entry.put()

    elif self.request.get("fn") == "update_presentation_item_graph":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            item = views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]
            data = json.loads(self.request.get("data"))
            for key in data.keys():
                v = data[key]
                if key in ["width", "height"]:
                    v = int(v)

                item[key] = v
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))] = item
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "swap_slide_indexes":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            identifiers = json.loads(slide.slide_identifiers)
            idx1 = int(self.request.get("i1"))
            idx2 = int(self.request.get("i2"))
            id1 = identifiers[idx1]
            id2 = identifiers[idx2]

            duped = json.loads(json.dumps(identifiers))
            duped[idx2] = id1
            duped[idx1] = id2
            slide.slide_identifiers = json.dumps(duped)
            slide.put()

            items = SlideItem.query(SlideItem.identifier.IN(duped))
            for item in items:
                item.idx = duped.index(item.identifier)
                item.put()

    elif self.request.get("fn") == "dupe_presentation":
        from google.appengine.api import taskqueue
        identifier = self.request.get("identifier")
        taskqueue.add(url="/tq/duplicate_presentation", params={"identifier": identifier})

    elif self.request.get("fn") == "lb_patch":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/lb_patch", params={})

    elif self.request.get("fn") == "lb_patch_pre":
        stats = LeaderBoardStat.query(
            LeaderBoardStat.metric_key == "packets_submitted"
        )
        for stat in stats:
            stat.key.delete()
        

    elif self.request.get("fn") == "image_comparison_test":
        from PIL import Image, ImageChops
        import math, operator        

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        retryParameters = gcs.RetryParams(initial_delay=0.2,
                                                    max_delay=5.0,
                                                    backoff_factor=2,
                                                    max_retry_period=15,
                                                    urlfetch_timeout=30)


        filename1 = bucket + "/Images/ProfilePictures/Full/0dfb32c952e5d244b043e66893b8eb2cb805844c500d40f5ca58e4d7fe353e6d3cba8413a1638438fc8e32966e919508f466c94407a7b736591fca22f6141386.jpg"
        #filename2 = bucket + "/Images/ProfilePictures/Full/38655a8a3e258861c88e0bb74ba206af08970f499c355ee9739c95c2b39ff5f7f9ecb7adfef8756f33868e7385a2a951190ad97b332a247e2817fc70253f235c.jpg"
        #filename2 = bucket + "/Images/ProfilePictures/Full/1d4cd4aa72c2321cababb0e7faff6b1e073c38ff78a11e85377bd6105dbbb910fccddfd8c3490fed902bf5c7352b787edd6b8a876017dab3a48a35775f6df40d.jpg"
        filename2 = bucket + "/Images/default.jpg"

        f1 = gcs.open(filename1, 'r', retry_params=retryParameters)
        f2 = gcs.open(filename2, 'r', retry_params=retryParameters)
        img_bytes1 = BytesIO(f1.read())
        img_bytes2 = BytesIO(f2.read())
        im1 = Image.open(img_bytes1)
        im2 = Image.open(img_bytes2)

        h = ImageChops.difference(im1, im2).getbbox()

        self.response.out.write(str(h))

        f1.close()
        f2.close()
        img_bytes1.close()
        img_bytes2.close()

    elif self.request.get("fn") == "update_presentation_item_user_input_value":
        slide = SlideItem.first(SlideItem.identifier == self.request.get("slide_item_identifier"))
        if not slide is None:
            views = json.loads(slide.views)
            views[int(self.request.get("subview_index"))][int(self.request.get("item_index"))]["value"] = self.request.get("value")
            slide.views = json.dumps(views)
            slide.put()

    elif self.request.get("fn") == "update_slide_local_definition":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["local_functions"][int(self.request.get("idx"))] = self.request.get("definition")
            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "add_local_function_to_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["local_functions"].append("")
            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "add_web_asset_to_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            options["web_assets"].append(json.loads(self.request.get("asset")))
            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "drop_web_asset_from_slide":
        slide = Slide.first(Slide.identifier == self.request.get("identifier"))
        if not slide is None:
            options = json.loads(slide.options)
            idx = int(self.request.get("idx"))
            try:
                del options["web_assets"][idx]
            except:
                options = options

            slide.options = json.dumps(options)
            slide.put()

    elif self.request.get("fn") == "save_closing_notes":
        notes = self.request.get("notes")
        kv = KeyValueStoreItem(
            identifier=Helpers.guid(),
            expiration=datetime(1970, 1, 1),
            keyy="closing_notes_for_" + self.request.get("identifier"),
            val=notes
        )
        kv.put()

    elif self.request.get("fn") == "provide_rep_goals_and_stats":
        data = json.loads(self.request.get("data"))
        start_date_vals = self.request.get("start_date").split("-")
        start_dt = datetime(int(start_date_vals[0]), int(start_date_vals[1]), int(start_date_vals[2]))
        end_dt = datetime(int(start_date_vals[0]), int(start_date_vals[1]), int(start_date_vals[2])) + timedelta(days=7)
        end_dt = end_dt + timedelta(hours=-1)
        goal = RepGoal(
            identifier=Helpers.guid(),
            rep_identifier=self.request.get("identifier"),
            start_date=start_dt.date(),
            end_date=end_dt.date(),
            goal_info=json.dumps(data["next_weeks_stats"])
        )

        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:

            for item in []:
            #for item in data["last_weeks_stats"]:
                dt_vals = item["date"].split("-")
                dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))                
                appt_stats = []
                #hours_stats = []

                cnt = 0
                while cnt < item["appointments_kept"]:
                    stat = LeaderBoardStat(
                        identifier=Helpers.guid(),
                        rep_id=rep.rep_id,
                        dt=(dt + timedelta(seconds=1)),
                        metric_key="appointments_kept",
                        office_identifier=rep.main_office,
                        field_app_identifier="-1",
                        in_bounds=True,
                        pin_identifier="-1"
                    )
                    appt_stats.append(stat)
                    cnt += 1

                #cnt = 0
                #while cnt < item["hours_knocked"]:
                #    stat = LeaderBoardStat(
                #        identifier=Helpers.guid(),
                #        rep_id=rep.rep_id,
                #        dt=(dt + timedelta(seconds=1)),
                #        metric_key="hours_knocked",
                #        office_identifier=rep.main_office,
                #        field_app_identifier="-1",
                #        in_bounds=True,
                #        pin_identifier="-1"
                #    )
                #    hours_stats.append(stat)
                #    cnt += 1

                if len(appt_stats) > 0:
                    ndb.put_multi(appt_stats)
                #if len(hours_stats) > 0:
                    #ndb.put_multi(hours_stats)

            goal.put()
        
    elif self.request.get("fn") == "saturday_sms_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/saturday_sms", params={})

    elif self.request.get("fn") == "create_update_scheduled_sms":
        new = False
        tally = ScheduledSMS.query().count()
        sms = ScheduledSMS.first(ScheduledSMS.identifier == str(self.request.get("identifier")))
        if sms is None:
            new = True
            sms = ScheduledSMS(
                identifier=Helpers.guid(),
                active=True
            )
        sms.message = self.request.get("message")
        sms.name = self.request.get("name")
        sms.recipient_option = self.request.get("option")
        if len(str(self.request.get("custom_recipients"))) == 0:
            sms.custom_recipients = json.dumps([])
        else:
            sms.custom_recipients = json.dumps((self.request.get("custom_recipients").split(",")))
        if new:
            sms.display_index = tally
        sms.scheduling_enabled = (self.request.get("scheduling_enabled") == "1")
        if sms.scheduling_enabled:
            sms.start_hour = int(self.request.get("time").split("-")[0])
            sms.end_hour = int(self.request.get("time").split("-")[1])
            sms.weekday = int(self.request.get("weekday"))
        else:
            sms.start_hour = -1
            sms.end_hour = -1
            sms.weekday = -1
        
        sms.put()

    elif self.request.get("fn") == "bulk_payroll_export":
        from google.appengine.api import taskqueue

        self.response.content_type = "application/json"
        ret_json = {"success": False, "token": Helpers.guid(), "include_images": int(self.request.get("include_images"))}
        if len(str(self.request.get("year"))) == 4:
            user = FieldApplicationUser.first(
                ndb.AND
                (
                    FieldApplicationUser.rep_email == self.request.get("login"),
                    FieldApplicationUser.password == Helpers.hash_pass(self.request.get("password"))
                )
            )
            if not user is None:
                if user.user_type == "super":
                    ret_json["success"] = True
                    taskqueue.add(url="/tq/bulk_payroll_export", params={"token": ret_json["token"], "year": str(self.request.get("year")), "custom_range": str(self.request.get("custom_range")), "start_month": str(self.request.get("start_month")), "start_year": str(self.request.get("start_year")), "end_month": str(self.request.get("end_month")), "end_year": str(self.request.get("end_year")), "login": self.request.get("login"), "password": self.request.get("password"), "include_images": self.request.get("include_images"), "users_discriminant": str(self.request.get("users_discriminant")), "description_keyword_list": str(self.request.get("description_keyword_list")), "description_keyword_search_mode": str(self.request.get("description_keyword_search_mode"))})

        self.response.out.write(json.dumps(ret_json))
    
    elif self.request.get("fn") == "store_spruce_token":
        Helpers.write_setting("spruce_token", self.request.get("token"))

    elif self.request.get("fn") == "goal_reports_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/email_goal_reports", params={})

    elif self.request.get("fn") == "proposal_exists":
        self.response.content_type = "application/json"
        ret = {"found": True}
        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == self.request.get("identifier"))
        if not proposal is None:
            deserialized = json.loads(proposal.info)
            keys = deserialized.keys()
            if len(keys) < 2:
                ret["found"] = False
        else:
            ret["found"] = False

        self.response.out.write(json.dumps(ret))        

    elif self.request.get("fn") == "preview_system_cost_in_proposal":
        identifier = self.request.get("identifier")
        self.response.content_type = "application/json"
        ret_json = {"result": "0"}

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == identifier)
        if not app_entry is None:
            office = OfficeLocation.first(OfficeLocation.identifier == app_entry.office_identifier)
            if not office is None:
                market = OfficeLocation.first(OfficeLocation.identifier == office.parent_identifier)
                if not market is None:
                    market_key = market.identifier
                    booking = SurveyBooking.first(SurveyBooking.field_app_identifier == identifier)
                    if not booking is None:
                        proposal = CustomerProposalInfo.first(CustomerProposalInfo.field_app_identifier == identifier)
                        if proposal is None:
                            default_info = {"panel_qty": str(self.request.get("panel_qty")), "additional_amount": str("0.00"), "system_size": str(self.request.get("system_size"))}
                            proposal = CustomerProposalInfo(
                                identifier=Helpers.guid(),
                                field_app_identifier=identifier,
                                info=json.dumps(default_info)
                            )
                        info = json.loads(proposal.info)
                        info["panel_qty"] = self.request.get("panel_qty")
                        info["new_panel_qty"] = self.request.get("panel_qty")
                        info["system_size"] = self.request.get("system_size")
                        proposal.info = json.dumps(info)

                        try:
                            proposal.fix_additional_amount()
                            proposal.fix_system_size()
                        except:
                            x = 5

                        pricing_structures = Helpers.get_pricing_structures()
                        funds = Helpers.list_funds()
                        ret_json["result"] = str(Helpers.crunch("fx_Total_System_Cost", market_key, app_entry, booking, info, pricing_structures, funds))
        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "plan_set_exists":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["result"] = False
        planset = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
        if not planset is None:
            ret_json["result"] = True
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "rep_payroll_notify":
        lst = []
        users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        for user in users:
            if not user.user_type == "super":
                lst.append(user.rep_phone)

        dt = Helpers.pacific_now()
        while not dt.isoweekday() == 5:
            dt = dt + timedelta(days=1)

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "paycheck_preview_ready_" + str(dt.date()))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="paycheck_preview_ready_" + str(dt.date()),
                val="1",
                expiration=dt + timedelta(days=14)
            )
            kv.put()

        if len(lst) > 0:
            from google.appengine.api import taskqueue
            vals_dict = {"list": json.dumps(lst)}
            taskqueue.add(url="/tq/rep_payroll_notify", params=vals_dict)

    elif self.request.get("fn") == "sms_blast":
        from google.appengine.api import taskqueue
        message = ScheduledSMS.first(ScheduledSMS.identifier == self.request.get("identifier"))
        if not message is None:
            taskqueue.add(url="/tq/sms_blast", params={"option": self.request.get("option"), "message": self.request.get("message"), "custom_recipients": message.custom_recipients})
        else:
            custom_recips = json.dumps(self.request.get("custom_recipients").split(","))
            taskqueue.add(url="/tq/sms_blast", params={"option": self.request.get("option"), "message": self.request.get("message"), "custom_recipients": custom_recips})
        
    elif self.request.get("fn") == "registration_pw_check":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        passwords = Helpers.read_setting("passwords")
        for password in passwords:
            if password["name"] == "W2 Employee Registration":
                if str(password["password"]) == str(self.request.get("password")):
                    ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "sales_rep_registration_pw_check":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        passwords = Helpers.read_setting("passwords")
        for password in passwords:
            if password["name"] == "Sales Rep Registration":
                if str(password["password"]) == str(self.request.get("password")):
                    ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "password_check":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        passwords = Helpers.read_setting("passwords")
        for password in passwords:
            if password["name"] == self.request.get("name"):
                if str(password["password"]) == str(self.request.get("password")):
                    ret_json["success"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "bulk_sms_poll":
        from google.appengine.api import taskqueue

        now = Helpers.pacific_now()
        end = now + timedelta(hours=1)
        wd = now.isoweekday()

        messages = ScheduledSMS.query(
            ndb.AND(
                ScheduledSMS.start_hour == now.hour,
                ScheduledSMS.end_hour == end.hour,
                ScheduledSMS.weekday == wd,
                ScheduledSMS.active == True
            )
        )

        for message in messages:
            key = "sms_sent_" + message.identifier + "___" + str(now.date()) + "_" + str(now.hour) + "__" + str(end.date()) + "_" + str(end.hour)
            kv_check = KeyValueStoreItem.first(KeyValueStoreItem.keyy == key)
            if kv_check is None:
                save_kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy=key,
                    val="1",
                    expiration=(now + timedelta(days=3))
                )
                save_kv.put()
                taskqueue.add(url="/tq/sms_blast", params={"option": message.recipient_option, "message": message.message, "custom_recipients": message.custom_recipients})

    elif self.request.get("fn") == "sp_daily_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/sp_daily_report", params={})

    elif self.request.get("fn") == "bulk_sms_remove":
        sms = ScheduledSMS.first(ScheduledSMS.identifier == self.request.get("identifier"))
        if not sms is None:
            sms.key.delete()

    elif self.request.get("fn") == "create_plan_set_details":
        from fpdf import FPDF
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            planset = PlanSetDetails.first(PlanSetDetails.field_app_identifier == self.request.get("identifier"))
            if planset is None:
                planset = PlanSetDetails(
                    identifier=Helpers.guid(),
                    field_app_identifier=self.request.get("identifier")
                )

            data = json.loads(self.request.get("data"))
            #handle the file uploads...

            customer_folder = ThirdPartyFolder.first(
                ndb.AND(
                    ThirdPartyFolder.field_app_identifier == self.request.get("identifier"),
                    ThirdPartyFolder.folder_key == "root_folder"
                )
            )
            item_pic_details = {}
            if not customer_folder is None:
                plan_set_details_folder_id = Helpers.create_customer_folder_in_google_drive(app_entry, customer_folder.foreign_id, "Plan Set Details", "plan_set_details")
                for item in ["image_of_layout", "image_of_roof_measurements", "image_of_roof", "image_of_area_around_meter"]:
                    file_content = self.request.POST.multi[item].file.read()
                    file_content_b64 = base64.b64encode(file_content)
                    pic_name = self.request.params[item].filename.lower()
                    name_elements = pic_name.split(".")
                    pic_type = name_elements[len(name_elements) - 1]
                    pic_mime = self.request.POST[item].type
                    pic_ext = "jpg"
                    if "png" in pic_mime.lower():
                        pic_ext = "png"
                    item_pic_details[item] = {}
                    item_pic_details[item]["mime"] = pic_mime
                    item_pic_details[item]["pic_ext"] = pic_ext

                    bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())
                    bucket = '/' + bucket_name
                    filename = bucket + '/PlanSetDetails/' + self.request.get("identifier") + "/" + item + "." + pic_ext

                    write_retry_params = gcs.RetryParams(backoff_factor=1.1)
                    gcs_file = gcs.open(filename,
                                        'w',
                                        content_type=pic_mime,
                                        options={'x-goog-meta-foo': 'foo',
                                                'x-goog-meta-bar': 'bar',
                                                'x-goog-acl': 'public-read'},
                                        retry_params=write_retry_params)
                    gcs_file.write(file_content)
                    gcs_file.close()
                    Helpers.create_file_in_google_drive(plan_set_details_folder_id, (item + "." + pic_ext), file_content_b64, pic_mime)

                for key in item_pic_details.keys():
                    for key2 in item_pic_details[key].keys():
                        data[key][key2] = item_pic_details[key][key2]

                text_content = ""
                ordered_keys = json.loads(self.request.get("key_ordering"))
                
                pdf = FPDF('P', 'in', 'Letter')
                pdf.set_auto_page_break(True, margin = 0.5)
                pdf.add_page()
                pdf.set_font('Arial', 'B', 18.0)
                pdf.set_y(0.5)
                pdf.set_x(1.0)
                pdf.cell(7.5, 0.5, app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " (New Power Inc. Job)", 0, 0, "C")
                pdf.set_y(1.1)
                pdf.set_x(0.5)
                pdf.set_font('Arial', 'I', 16)
                pdf.multi_cell(7.5, 0.25, app_entry.customer_address.strip().title() + "\n" + app_entry.customer_city.strip().title() + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal)
                pdf.ln(0.5)

                for key in ordered_keys:
                    if not key in item_pic_details.keys():
                        split = key.split("_")
                        new_split_vals = []
                        for item in split:
                            new_split_vals.append(item.title())
                        text_content += "-------------------------"
                        text_content += "\r\n"
                        text_content += (" ".join(new_split_vals) + ":")
                        text_content += "\r\n"
                        text_content += data[key]["value"]
                        text_content += "\r\n"
                        text_content += "-------------------------"
                        text_content += "\r\n\r\n"

                        pdf.set_font('Arial', 'B', 14)
                        pdf.set_x(0.5)
                        pdf.set_fill_color(0, 0, 0)
                        pdf.set_text_color(255, 255, 255)
                        pdf.multi_cell(7.5, 0.20, " ".join(new_split_vals), 1, "L", True)
                        pdf.set_text_color(0, 0, 0)
                        pdf.ln(0.2)
                        pdf.set_x(0.5)
                        pdf.multi_cell(7.5, 0.20, data[key]["value"], 0, "L", False)
                        pdf.ln(0.3)

                buff = StringIO.StringIO()
                buff.write(pdf.output('', 'S'))
                buff.seek(2)

                self.response.out.write(buff.getvalue())

                planset.data = json.dumps(data)
                planset.key_ordering = self.request.get("key_ordering")
                planset.created = Helpers.pacific_now()
                planset.active = True

                
                bucket_name = os.environ.get('BUCKET_NAME',
                             app_identity.get_default_gcs_bucket_name())
                bucket = '/' + bucket_name
                filename = bucket + '/PlanSetDetails/' + self.request.get("identifier") + "/details.txt"

                write_retry_params = gcs.RetryParams(backoff_factor=1.1)
                gcs_file = gcs.open(filename,
                                    'w',
                                    content_type="text/plain"
                                    ,
                                    options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params)
                gcs_file.write(str(text_content))
                gcs_file.close()

                gcs_file2 = gcs.open(filename.replace(".txt", ".pdf"),
                                    'w',
                                    content_type="application/pdf",
                                    options={'x-goog-meta-foo': 'foo',
                                            'x-goog-meta-bar': 'bar',
                                            'x-goog-acl': 'public-read'},
                                    retry_params=write_retry_params)

                gcs_file2.write(buff.getvalue())
                gcs_file2.close()
                time.sleep(3)
                attachments = [
                    {"gcs_path": "/PlanSetDetails/" + self.request.get("identifier") + "/details.pdf", "name": "details.pdf"},
                ]

                attachment_data = {}
                attachment_data["data"] = []
                attachment_data["content_types"] = []
                attachment_data["filenames"] = []

                attachment_data["data"].append("https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/PlanSetDetails/" + self.request.get("identifier") + "/details.pdf")
                attachment_data["content_types"].append("application/pdf")
                attachment_data["filenames"].append("details.pdf")

                for item in ["image_of_layout", "image_of_roof_measurements", "image_of_roof", "image_of_area_around_meter"]:
                    #filename = '/PlanSetDetails/' + self.request.get("identifier") + "/" + item + "." + item_pic_details[item]["pic_ext"]
                    #attachments.append({"gcs_path": filename, "name": item + "." + item_pic_details[item]["pic_ext"]})
                    attachment_data["data"].append("https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/PlanSetDetails/" + self.request.get("identifier") + "/" + item + "." + item_pic_details[itm]["pic_ext"])
                    
                    if item_pic_details[itm]["pic_ext"].lower() == "jpg":
                        attachment_data["content_types"].append("image/jpeg")
                    else:
                        attachment_data["content_types"].append("image/png")

                    attachment_data["filenames"].append(item) + item_pic_details[itm]["pic_ext"].lower()

                recipients = data["recipient_email_address"]["value"].replace("\r", "").split("\n")
                for recipient in recipients:
                    if len(recipient.strip()) > 0:
                        Helpers.send_email(recipient.strip(), "New Job for New Power Inc.", "Files attached below...", attachment_data)
                text_content_b64 = base64.b64encode(text_content)
                Helpers.create_file_in_google_drive(plan_set_details_folder_id, "details.txt", text_content_b64, "text/plain")
                planset.put()

    elif self.request.get("fn") == "activate_deactivate_scheduled_sms":
        sms = ScheduledSMS.first(ScheduledSMS.identifier == self.request.get("identifier"))
        if not sms is None:
            sms.active = (self.request.get("active") == "1")
            sms.put()

    elif self.request.get("fn") == "update_bulk_sms_indexes":
        mapping = json.loads(self.request.get("mapping"))
        keys = mapping.keys()
        if len(keys) > 1:
            messages = ScheduledSMS.query(ScheduledSMS.identifier.IN(keys))
            to_save = []
            for message in messages:
                message.display_index = mapping[message.identifier]
                to_save.append(message)

            if len(to_save) == 1:
                to_save[0].put()
            elif len(to_save) > 1:
                ndb.put_multi(to_save)

    elif self.request.get("fn") == "ppa_bonus_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/ppa_bonus", params={})

    elif self.request.get("fn") == "dupe_scheduled_sms":
        sms = ScheduledSMS.first(ScheduledSMS.identifier == self.request.get("identifier"))
        if not sms is None:
            tally = ScheduledSMS.query().count()

            new_sms = ScheduledSMS(
                identifier=Helpers.guid(),
                active=True,
                message=sms.message,
                name=sms.name + " (Copy)",
                recipient_option=sms.recipient_option,
                custom_recipients=sms.custom_recipients,
                display_index=tally,
                scheduling_enabled=sms.scheduling_enabled,
                start_hour=sms.start_hour,
                end_hour=sms.end_hour,
                weekday=sms.weekday
            )
            new_sms.put()

    elif self.request.get("fn") == "enumerate_scheduled_sms":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["messages"] = []
        messages = ScheduledSMS.query()
        for m in messages:
            item = {}
            item["identifier"] = m.identifier
            item["active"] = m.active
            item["message"] = m.message
            item["name"] = m.name
            item["recipient_option"] = m.recipient_option
            item["display_index"] = m.display_index
            item["scheduling_enabled"] = m.scheduling_enabled
            item["start_hour"] = m.start_hour
            item["end_hour"] = m.end_hour
            item["weekday"] = m.weekday
            item["custom_recipients"] = json.loads(m.custom_recipients)

            ret_json["messages"].append(item)

        ret_json["messages"] = Helpers.bubble_sort(ret_json["messages"], "display_index")
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "av_check":
        self.response.content_type = "application/json"
        ret_json = {"identifiers": [], "new": False}
        identifiers = json.loads(self.request.get("identifiers"))
        media = TrainingMedia.query(
            ndb.OR(
                TrainingMedia.type == "audio",
                TrainingMedia.type == "video"
            )
        )
        for m in media:
            ret_json["identifiers"].append(m.identifier)
        for item in ret_json["identifiers"]:
            if not item in identifiers:
                ret_json["new"] = True
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_calendar_events":
        self.response.content_type = "application/json"
        ret_json = {"events": []}
        ret_json["repeated_events"] = []
        events = CalendarEvent.query(
            CalendarEvent.calendar_key == self.request.get("key"),
            CalendarEvent.start_dt >= Helpers.pacific_now() + timedelta(days=-180),
            CalendarEvent.start_dt <= Helpers.pacific_now() + timedelta(days=180)
        ).order(CalendarEvent.start_dt)

        string_to_hash = "foo"
        for e in events:
            obj = {"identifier": e.identifier, "field_app_identifier": e.field_app_identifier, "name": e.name, "start_dt": str(e.start_dt).replace(" ", "T"), "end_dt": str(e.end_dt).replace(" ", "T"), "all_day": e.all_day, "calendar_key": e.calendar_key, "event_key": e.event_key, "details": e.details, "repeated": e.repeated, "repeated_days": json.loads(e.repeated_days), "color": e.color, "owners": json.loads(e.owners)}
            ret_json["events"].append(obj)
            string_to_hash += obj["identifier"] + obj["start_dt"] + obj["end_dt"] + "|"
        
        repeated_events_cpy = []
        repeated_events = CalendarEvent.query(
            ndb.AND(
                CalendarEvent.repeated == True,
                CalendarEvent.calendar_key == self.request.get("key")
            )
        )
        for e in repeated_events:
            repeated_events_cpy.append(e)

        repeated_events = Helpers.bubble_sort(repeated_events_cpy, "identifier")

        for e in repeated_events:
            obj = {"identifier": e.identifier, "field_app_identifier": e.field_app_identifier, "name": e.name, "start_dt": str(e.start_dt).replace(" ", "T"), "end_dt": str(e.end_dt).replace(" ", "T"), "all_day": e.all_day, "calendar_key": e.calendar_key, "event_key": e.event_key, "repeated_days": json.loads(e.repeated_days), "details": e.details, "repeated": e.repeated, "color": e.color, "exception_dates": json.loads(e.exception_dates), "owners": json.loads(e.owners)}
            string_to_hash += obj["identifier"] + obj["start_dt"] + obj["end_dt"] + "|"
            ret_json["repeated_events"].append(obj)
            ret_json["hash"] = hashlib.md5(string_to_hash).hexdigest()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_first_and_last_for_cust":
        self.response.content_type = "application/json"
        ret_json = {}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            ret_json["first"] = app_entry.customer_first_name.strip().title()
            ret_json["last"] = app_entry.customer_last_name.strip().title()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "drop_rep_event":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            event.key.delete()

    elif self.request.get("fn") == "drop_calendar_event":
        event_series_id = "-1"
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            event_series_id = event.google_series_id
            old_start_dt = event.start_dt
            old_end_dt = event.end_dt
            old_start_dt_str = str(old_start_dt.year) + "_" + str(old_start_dt.month) + "_" + str(old_start_dt.day) + "_" + str(old_start_dt.hour) + "_" + str(old_start_dt.minute) + "_" + str(old_start_dt.second)
            old_end_dt_str = str(old_end_dt.year) + "_" + str(old_end_dt.month) + "_" + str(old_end_dt.day) + "_" + str(old_end_dt.hour) + "_" + str(old_end_dt.minute) + "_" + str(old_end_dt.second)

            if (not event.field_app_identifier == "-1"):
                pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == event.field_app_identifier)
                if not pp_sub is None:
                    info = json.loads(pp_sub.extra_info)
                    if "project_management_checkoffs" in info.keys():
                        if event.event_key in info["project_management_checkoffs"].keys():
                            if "date" in info["project_management_checkoffs"][event.event_key].keys():
                                del info["project_management_checkoffs"][event.event_key]["date"]
                                pp_sub.extra_info = json.dumps(info)
                                pp_sub.put()

            event.key.delete()
            if event.repeated == False:
                from google.appengine.api import taskqueue
                taskqueue.add(url="/tq/google_calendar", params={"fn": "delete_one_time_event", "identifier": self.request.get("identifier"), "old_start_dt": old_start_dt_str, "old_end_dt": old_end_dt_str})
            else:
                from google.appengine.api import taskqueue
                taskqueue.add(url="/tq/google_calendar", params={"fn": "delete_repeated_event", "google_series_id": event_series_id})

    elif self.request.get("fn") == "update_calendar_series_id":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            event.google_series_id = self.request.get("id")
            event.put()

    elif self.request.get("fn") == "cal_create":
        event = CalendarEvent.first(CalendarEvent.identifier == self.request.get("identifier"))
        if not event is None:
            if event.repeated:
                Helpers.google_calendar_sync("create_repeated_event", event, Helpers.pacific_now(), Helpers.pacific_now())
            else:
                Helpers.google_calendar_sync("create_one_time_event", event, Helpers.pacific_now(), Helpers.pacific_now())

    elif self.request.get("fn") == "list_event_ids":
        self.response.content_type = "application/json"
        ret_json = []
        events = CalendarEvent.query()
        for e in events:
            ret_json.append(e.identifier)
        self.response.out.write(json.dumps(ret_json))
    
    elif self.request.get("fn") == "pm_item_rename":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/pm_item_rename", params={})

    elif self.request.get("fn") == "update_additional_checkoff_appears_after":
        settings = Helpers.read_setting("project_management_additional_checkoffs")
        for item in settings:
            if item["value"] == self.request.get("val"):
                item["appears_after"] = self.request.get("value")
        Helpers.write_setting("project_management_additional_checkoffs", settings)

    elif self.request.get("fn") == "list_customer_email_templates":
        self.response.content_type = "application/json"
        items = Helpers.list_files_in_gcs_folder("CustomerEmailTemplates", "txt")
        ret_json = []
        for item in items:
            ret_json.append(item.replace(".txt", ""))
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "read_customer_email_template":
        self.response.content_type = "application/json"
        ret_json = {}

        # lock writes
        filename1 = "/CustomerEmailTemplates/" + self.request.get("name") + ".subject"
        filename2 = "/CustomerEmailTemplates/" + self.request.get("name") + ".txt"
        GCSLockedFile.lock_writes([filename1, filename2])


        f1 = GCSLockedFile(filename1)
        f2 = GCSLockedFile(filename2)

        ret_json["subject"] = f1.read()
        ret_json["message"] = f2.read()

        # unlock
        GCSLockedFile.unlock_writes([filename1, filename2])

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "write_customer_email_template":
        # lock reads
        filename1 = "/CustomerEmailTemplates/" + self.request.get("name") + ".subject"
        filename2 = "/CustomerEmailTemplates/" + self.request.get("name") + ".txt"
        GCSLockedFile.lock_reads([filename1, filename2])

        f1 = GCSLockedFile(filename1)
        f2 = GCSLockedFile(filename2)

        f1.write(self.request.get("subject"), "text/plain", "public-read")
        f2.write(self.request.get("message"), "text/plain", "public-read")

        # unlock
        GCSLockedFile.unlock_reads([filename1, filename2])

    elif self.request.get("fn") == "sign_roof_hack":
        self.response.content_type = "application/json"
        ret_json = {"x": 160, "y": 392, "w": 200, "h": 180}

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            roof_item = RoofWorkItem.first(RoofWorkItem.field_app_identifier == app_entry.identifier)
            if not roof_item is None:
                roof_info = json.loads(roof_item.info)

                img_postfix = "reroof_photo"
                if roof_info["rep_selection_one"] == "solar_area_only":
                    img_postfix = "solar_area_photo"
                    i = 2

                filename = '/Images/RoofWorkDetails/' + app_entry.identifier + "/" + img_postfix + ".jpg"

                roof_file = GCSLockedFile(filename)
                roof_data = roof_file.read()

                bytez = BytesIO(roof_data)
                buff = StringIO.StringIO()
                
                img = Image.open(bytez)    
                
                img.save(buff, format="JPEG")
                ret_json["b64"] = base64.b64encode(buff.getvalue())
                roof_file.unlock()
                buff.close()
                bytez.close()

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "send_equipment_ordered_email":
        f1 = GCSLockedFile("/CustomerEmailTemplates/Equipment Ordered.subject");
        f2 = GCSLockedFile("/CustomerEmailTemplates/Equipment Ordered.txt");

        subject = f1.read()
        f1.unlock()

        html = f2.read()
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if (not pp_sub is None) and (not app_entry is None):
            html = Helpers.fill_email_template(pp_sub, app_entry, html)
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="equipment_ordered_email_sent_" + self.request.get("identifier"),
                val=str(Helpers.pacific_today()),
                expiration=datetime(1970, 1, 1)
            )
            kv.put()
            Helpers.send_customer_email(html, subject, app_entry.customer_email, "'Equipment Ordered' email was sent out.", self.request.get("identifier"))


    elif self.request.get("fn") == "send_welcome_email":
        f1 = GCSLockedFile("/CustomerEmailTemplates/Welcome Email.subject");
        f2 = GCSLockedFile("/CustomerEmailTemplates/Welcome Email.txt");

        subject = f1.read()
        f1.unlock()

        html = f2.read()
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if (not pp_sub is None) and (not app_entry is None):
            html = Helpers.fill_email_template(
                pp_sub,
                app_entry,
                html,
                str(self.request.get("pm_extension")),
                str(self.request.get("installation_link")),
                str(self.request.get("solar_warranty_link")),
                str(self.request.get("inverter_warranty_link"))
            )
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="welcome_email_sent_" + self.request.get("identifier"),
                val=str(Helpers.pacific_today()),
                expiration=datetime(1970, 1, 1)
            )
            kv.put()
            Helpers.send_customer_email(html, subject, app_entry.customer_email, "'Welcome Email' was sent out", self.request.get("identifier"))

    elif self.request.get("fn") == "confirmation_blast":
        Helpers.send_sms(self.request.get("phone"), self.request.get("string"))

    elif self.request.get("fn") == "pull_confirmation_details":
        self.response.content_type = "application/json"
        ret_json = {}
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            closer = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("closer"))
            if not closer is None:
                ret_json["closer_first"] = closer.first_name.strip().title()
                ret_json["closer_last"] = closer.last_name.strip().title()
                ret_json["closer_phone"] = closer.rep_phone
                ret_json["closer_phone_formatted"] = Helpers.format_phone_number(closer.rep_phone)
                ret_json["sp2"] = str(app_entry.sp_two_time)
                ret_json["customer_name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
                ret_json["address"] = app_entry.customer_address
                ret_json["city"] = app_entry.customer_city
                ret_json["state"] = app_entry.customer_state
                ret_json["postal"] = app_entry.customer_postal
                ret_json["customer_phone"] = app_entry.customer_phone
                ret_json["customer_phone_formatted"] = Helpers.format_phone_number(app_entry.customer_phone)
                ret_json["total_kwhs"] = str(round(app_entry.total_kwhs, 2))
                ret_json["highest_monthly_bill"] = Helpers.currency_format(app_entry.highest_amount)
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "customer_installation_email_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/customer_installation_email", params={})

    elif self.request.get("fn") == "send_inspection_passed_email":
        f1 = GCSLockedFile("/CustomerEmailTemplates/Inspection Passed.subject");
        f2 = GCSLockedFile("/CustomerEmailTemplates/Inspection Passed.txt");

        subject = f1.read()
        f1.unlock()

        msg = f2.read()
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if (not pp_sub is None) and (not app_entry is None):
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="inspection_passed_email_sent_" + self.request.get("identifier"),
                val=str(Helpers.pacific_today()),
                expiration=datetime(1970, 1, 1)
            )
            kv.put()

            html = Helpers.fill_email_template(
                pp_sub,
                app_entry,
                msg,
                str(self.request.get("pm_extension")),
                str(self.request.get("installation_link")),
                str(self.request.get("solar_warranty_link")),
                str(self.request.get("inverter_warranty_link"))
            )

            Helpers.send_customer_email(html, subject, app_entry.customer_email, "'Inspection Passed' email was sent out.", self.request.get("identifier"))

    elif self.request.get("fn") == "send_pto_received_email":
        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if (not pp_sub is None) and (not app_entry is None):

            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="pto_received_email_sent_" + self.request.get("identifier"),
                val=str(Helpers.pacific_today()),
                expiration=datetime(1970, 1, 1)
            )
            kv.put()
            filename1 = None
            filename2 = None
            if app_entry.utility_provider == "san_diego_gas_&_electric":
                filename1 = "/CustomerEmailTemplates/PTO Received SDGE.subject"
                filename2 = "/CustomerEmailTemplates/PTO Received SDGE.txt"
            elif app_entry.utility_provider == "southern_california_edison":
                filename1 = "/CustomerEmailTemplates/PTO Received Edison.subject"
                filename2 = "/CustomerEmailTemplates/PTO Received Edison.txt"

            if (not filename1 is None) and (not filename2 is None):
                f1 = GCSLockedFile(filename1)
                f2 = GCSLockedFile(filename2)

                subject = f1.read()
                msg = f2.read()

                f1.unlock()
                f2.unlock()

                html = Helpers.fill_email_template(pp_sub, app_entry, msg)

                Helpers.send_customer_email(html, subject, app_entry.customer_email, "'PTO Received' email was sent out.", self.request.get("identifier"))
    
    elif self.request.get("fn") == "send_install_email":
        f1 = GCSLockedFile("/CustomerEmailTemplates/Installation.subject")
        f2 = GCSLockedFile("/CustomerEmailTemplates/Installation.txt")

        subject = f1.read()
        msg = f2.read()

        f1.unlock()
        f2.unlock()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        pp_sub = PerfectPacketSubmission.first(PerfectPacketSubmission.field_application_identifier == self.request.get("identifier"))
        if (not app_entry is None) and (not pp_sub is None):
            kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "install_email_sent_" + self.request.get("identifier"))
            if kv is None:
                kv = KeyValueStoreItem(
                    identifier=Helpers.guid(),
                    keyy="install_email_sent_" + self.request.get("identifier"),
                    expiration=datetime(1970, 1, 1)
                )
            kv.val = str(Helpers.pacific_today())
            kv.put()

            html = Helpers.fill_email_template(pp_sub, app_entry, msg)
            Helpers.send_customer_email(html, subject, app_entry.customer_email, "'Installation' email was sent out.", self.request.get("identifier"))

    elif self.request.get("fn") == "calendar_event_owners_reminder":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/calendar_event_owners_reminder", params={"type": self.request.get("type")})

    elif self.request.get("fn") == "gcs_file_exists":
        self.response.content_type = "application/json"
        ret_json = {"exists": False}
        if Helpers.gcs_file_exists(self.request.get("path")):
            ret_json["exists"] = True

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "install_social_media_file":
        pic_ext = "jpg"

        file_content = self.request.POST.multi['media'].file.read()
        file_content_b64 = base64.b64encode(file_content)        
        pic_name = self.request.params["media"].filename.lower()
        name_elements = pic_name.split(".")
        pic_type = name_elements[len(name_elements) - 1]
        pic_mime = self.request.POST['media'].type        
        if "png" in pic_mime.lower():
            pic_ext = "png"

        if pic_mime == "image/png":
            pic_ext = "png"
        else:
            pic_ext = "jpg"

        bucket_name = os.environ.get('BUCKET_NAME',
                                app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name
        filename = bucket + '/InstallPhotos/' + self.request.get("identifier") + "." + pic_ext

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)
        gcs_file = gcs.open(filename,
                            'w',
                            content_type=pic_mime,
                            options={'x-goog-meta-foo': 'foo',
                                    'x-goog-meta-bar': 'bar',
                                    'x-goog-acl': 'public-read'},
                            retry_params=write_retry_params)
        gcs_file.write(file_content)
        gcs_file.close()

        attachment_data = {}
        attachment_data["data"] = []
        attachment_data["content_types"] = []
        attachment_data["filenames"] = []

        attachment_data["data"].append("https://storage.googleapis.com/" + app_identity.get_application_id() + ".appspot.com/InstallPhotos/" + self.request.get("identifier") + "." + pic_ext)        
        if pic_ext == "jpg":
            attachment_data["content_types"].append("image/jpeg")
        else:
            attachment_data["content_types"].append("image/png")

        attachment_data["filenames"].append("install_photo." + pic_ext)

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            recipients = [app_entry.customer_email, app_entry.rep_email]
            for recipient in recipients:
                if len(recipient.strip()) > 0:
                    Helpers.send_email(recipient.strip(), "Solar panels installed at " + app_entry.customer_last_name.strip().title() + " home.", "Congrats on having your solar panels installed! Attached is a picture you can share on social media!", attachment_data)
    
    elif self.request.get("fn") == "ca_audit_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/ca_audit", params={})

    elif self.request.get("fn") == "thomas_request_10_26":
        ret_json = []
        rep_identifier_name_dict = {
            "0be568f9adfc42cfebddc6a891f52393da151f89723d4b1e43a5c999e17a95b7bef549b0e325534dec52bcacb68bed31771a35d8c41526bc8a890ac3b42f44ae": "Scott Hall",
            "28a8dd2100b1e684257de26b9f8c3ca1d4bcbf4813d3fa94ff85c54918e9dc1925c45fbd7a0c99c9681eb08842035a415a0b83baeb28e3ab63882cd94c2ec5f6": "Connor Craig",
            "41738e1361421e6441dae232a634c3b700b4f660b37daa2710af2d26c12e21fa7fe98010153f66d4a1d04c0fd444752ffe93f16122d29fd0318e98ed0ddd968c": "Adam Hill"
        }
        reps = FieldApplicationUser.query(FieldApplicationUser.main_office == "b9878e9d5d74dbaceb7b7d9c1be74fa5ccd87d6100cad5496d2306366bbcfadafca3d2ae5dcfc3a82c2525650a88e4332cfc11183f8a0fd39071f13614e5806f")
        for rep in reps:
            if not rep.identifier in rep_identifier_name_dict.keys():
                rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_identifier.IN(rep_identifier_name_dict.keys()))
        app_ids_to_query = ["-1"]
        for pp_sub in pp_subs:
            app_ids_to_query.append(pp_sub.field_application_identifier)

        app_identifier_name_dict = {}
        app_identifier_phone_dict = {}
        app_identifier_address_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            app_identifier_phone_dict[app_entry.identifier] = Helpers.format_phone_number(app_entry.customer_phone)
            app_identifier_address_dict[app_entry.identifier] = app_entry.customer_address + " " + app_entry.customer_city + ", " + app_entry.customer_state + " " + app_entry.customer_postal

        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "install" in info["project_management_checkoffs"].keys():
                    if "checked" in info["project_management_checkoffs"]["install"].keys():
                        if "date" in info["project_management_checkoffs"]["install"].keys():
                           if info["project_management_checkoffs"]["install"]["checked"]:
                               ret_json.append({"rep": rep_identifier_name_dict[pp_sub.rep_identifier], "name": app_identifier_name_dict[pp_sub.field_application_identifier], "address": app_identifier_address_dict[pp_sub.field_application_identifier], "phone": app_identifier_phone_dict[pp_sub.field_application_identifier]})
        self.response.out.write(json.dumps(ret_json))
    
    elif self.request.get("fn") == "installs_report_1":
        min_time = int(time.time() * 1000)
        min_time -= (1000 * 60 * 60 * 24 * 365)
        #keyy="customer_signature_" + self.request.get("identifier"),
        rep_ids_to_query = ["-1"]

        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.insert_time >= min_time,
                FieldApplicationEntry.deal_closed == True
            )
        )

        app_identifier_idx_dict = {}
        app_identifier_name_dict = {}
        app_identifier_rep_id_dict = {}
        app_identifier_lead_dict = {}
        app_identifier_fund_dict = {}

        funds = Helpers.list_funds()
        fund_key_fund_name_dict = {}
        for f in funds:
            fund_key_fund_name_dict[f["value"]] = f["value_friendly"]

        rep_id_app_identifier_dict = {}
        ret_json = []
        #cnt = 0
        rep_ids_to_query = ["-1"]
        app_ids_to_query = ["-1"]
        app_identifier_solar_pro_dict = {}
        solar_pro_ids_to_query = ["-1"]
        for app_entry in app_entries:
            #app_identifier_idx_dict[app_entry.identifier] = cnt
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            app_identifier_rep_id_dict[app_entry.identifier] = app_entry.rep_id
            rep_id_app_identifier_dict[app_entry.rep_id] = app_entry.identifier
            app_identifier_lead_dict[app_entry.identifier] = app_entry.is_lead
            rep_ids_to_query.append(app_entry.rep_id)
            app_ids_to_query.append(app_entry.identifier)
            app_identifier_solar_pro_dict[app_entry.identifier] = app_entry.lead_generator
            if not app_entry.lead_generator in solar_pro_ids_to_query:
                solar_pro_ids_to_query.append(app_entry.lead_generator)
            #cnt += 1

        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(app_ids_to_query))
        for booking in bookings:
            app_identifier_fund_dict[booking.field_app_identifier] = fund_key_fund_name_dict[booking.fund]

        solar_pro_identifier_name_dict = {}
        solar_pros = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(solar_pro_ids_to_query))
        for solar_pro in solar_pros:
            solar_pro_identifier_name_dict[solar_pro.identifier] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        rep_identifier_rep_id_dict = {}
        rep_id_rep_identifier_dict = {}
        rep_id_office_dict = {}
        rep_identifier_office_dict = {}
        rep_id_name_dict = {}
        office_ids_to_query = ["-1"]
        for rep in reps:
            rep_identifier_rep_id_dict[rep.identifier] = rep.rep_id
            rep_id_rep_identifier_dict[rep.rep_id] = rep.identifier
            rep_id_office_dict[rep.rep_id] = rep.main_office
            rep_id_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_office_dict[rep.identifier] = rep.main_office
            office_ids_to_query.append(rep.main_office)

        office_identifier_name_dict = {}
        offices = OfficeLocation.query(OfficeLocation.identifier.IN(office_ids_to_query))
        for office in offices:
            office_identifier_name_dict[office.identifier] = office.name

        keepers = []
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(app_ids_to_query))
        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            if "project_management_checkoffs" in info.keys():
                if "install" in info["project_management_checkoffs"].keys():
                    if "date" in info["project_management_checkoffs"]["install"].keys():
                        if "checked" in info["project_management_checkoffs"]["install"].keys():
                            if info["project_management_checkoffs"]["install"]["checked"]:
                                dt_vals = info["project_management_checkoffs"]["install"]["date"].split("-")
                                dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                                if dt.year == int(self.request.get("year")) and dt.month == int(self.request.get("month")):
                                    keepers.append(pp_sub.field_application_identifier)
 
        ret_json = []
        if len(keepers) > 0:
            proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(keepers))
            for proposal in proposals:
                proposal.fix_additional_amount()
                proposal.fix_system_size()

                bool_mapping = {"0": "No", "1": "Yes"}
                info = json.loads(proposal.info)
                obj = {"customer_name": app_identifier_name_dict[proposal.field_app_identifier]}
                obj["fund"] = app_identifier_fund_dict[proposal.field_app_identifier]
                obj["is_lead"] = bool_mapping[str(int(app_identifier_lead_dict[proposal.field_app_identifier]))]
                obj["system_size"] = str(info["system_size"])
                rep_id = app_identifier_rep_id_dict[proposal.field_app_identifier]
                obj["rep_name"] = rep_id_name_dict[rep_id]
                office_identifier = rep_id_office_dict[rep_id]
                obj["rep_office"] = office_identifier_name_dict[office_identifier]
                obj["solar_pro"] = "Nobody"
                lead_generator = app_identifier_solar_pro_dict[proposal.field_app_identifier]
                if not lead_generator == "-1":
                    obj["solar_pro"] = solar_pro_identifier_name_dict[lead_generator]
                ret_json.append(obj)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "installs_report_2":
        min_time = int(time.time() * 1000)
        min_time -= (1000 * 60 * 60 * 24 * 365)
        #keyy="customer_signature_" + self.request.get("identifier"),
        app_identifier_customer_name_dict = {}
        app_identifier_save_me_dict = {}
        app_identifier_archived_dict = {}
        app_identifier_lead_dict = {}
        rep_ids_to_query = ["-1"]

        funds = Helpers.list_funds()
        fund_key_fund_name_dict = {}
        for f in funds:
            fund_key_fund_name_dict[f["value"]] = f["value_friendly"]

        app_entries = FieldApplicationEntry.query(
            ndb.AND
            (
                FieldApplicationEntry.insert_time >= min_time,
                FieldApplicationEntry.deal_closed == True
            )
        )
        keys_to_query = ["-1"]
        app_identifier_solar_pro_dict = {}
        solar_pro_ids_to_query = []
        for app_entry in app_entries:
            app_identifier_customer_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            app_identifier_save_me_dict[app_entry.identifier] = app_entry.save_me
            app_identifier_archived_dict[app_entry.identifier] = app_entry.archived
            app_identifier_lead_dict[app_entry.identifier] = app_entry.is_lead
            app_identifier_solar_pro_dict[app_entry.identifier] = app_entry.lead_generator
            keys_to_query.append("customer_signature_" + app_entry.identifier)
            rep_ids_to_query.append(app_entry.rep_id)
            solar_pro_ids_to_query.append(app_entry.lead_generator)

        solar_pro_identifier_name_dict = {}
        solar_pros = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(solar_pro_ids_to_query))
        for solar_pro in solar_pros:
            solar_pro_identifier_name_dict[solar_pro.identifier] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()

        kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(keys_to_query))
        keeper_ids = ["-1"]
        for kv in kvs:
            modified = kv.modified
            if modified.year == int(self.request.get("year")) and modified.month == int(self.request.get("month")):
                keeper_ids.append(kv.keyy.split("_")[2])

        office_ids_to_query = ["-1"]
        rep_identifier_name_dict = {}
        rep_identifier_office_identifier_dict = {}
        rep_ids_to_query.append("TANN0911")
        reps = FieldApplicationUser.query(FieldApplicationUser.rep_id.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_office_identifier_dict[rep.identifier] = rep.main_office
            office_ids_to_query.append(rep.main_office)

        office_identifier_name_dict = {}
        offices = OfficeLocation.query(OfficeLocation.identifier.IN(office_ids_to_query))
        for office in offices:
            office_identifier_name_dict[office.identifier] = office.name

        app_identifier_system_size_dict = {}
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(keeper_ids))
        app_identifier_rep_identifier_dict = {}
        for proposal in proposals:
            proposal.fix_additional_amount()
            proposal.fix_system_size()
            info = json.loads(proposal.info)
            app_identifier_system_size_dict[proposal.field_app_identifier] = str(info["system_size"])


        app_identifier_fund_dict = {}
        bookings = SurveyBooking.query(SurveyBooking.field_app_identifier.IN(keeper_ids))
        for booking in bookings:
            app_identifier_fund_dict[booking.field_app_identifier] = fund_key_fund_name_dict[booking.fund]

        app_identifier_rep_identifier_dict = {}
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(keeper_ids))
        app_identifier_pto_complete_dict = {}
        app_identifier_pp_sub_extra_info_dict = {}
        for pp_sub in pp_subs:
            app_identifier_rep_identifier_dict[pp_sub.field_application_identifier] = pp_sub.rep_identifier
            info = json.loads(pp_sub.extra_info)
            app_identifier_pp_sub_extra_info_dict[pp_sub.field_application_identifier] = info

        bool_mapping = {"0": "No", "1": "Yes"}
        ret_json = []
        for item in keeper_ids:
            if not item == "-1":
                obj = {}
                try:
                    obj["system_size"] = app_identifier_system_size_dict[item]
                except:
                    obj["system_size"] = "No proposal is available"
                obj["customer_name"] = app_identifier_customer_name_dict[item]
                rep_identifier = app_identifier_rep_identifier_dict[item]
                obj["rep_name"] = rep_identifier_name_dict[rep_identifier]
                rep_office_identifier = rep_identifier_office_identifier_dict[rep_identifier]
                obj["rep_office"] = office_identifier_name_dict[rep_office_identifier]
                obj["save_me"] = bool_mapping[str(int(app_identifier_save_me_dict[item]))]
                obj["fund"] = app_identifier_fund_dict[item]
                obj["is_lead"] = bool_mapping[str(int(app_identifier_lead_dict[item]))]
                obj["solar_pro"] = "Nobody"
                lead_generator = app_identifier_solar_pro_dict[item]
                if not lead_generator == "-1":
                    obj["solar_pro"] = solar_pro_identifier_name_dict[lead_generator]

                cancelled = app_identifier_archived_dict[item]
                if cancelled:
                    if app_identifier_archived_dict[item]:
                        info = app_identifier_pp_sub_extra_info_dict[item]
                        if "project_management_checkoffs" in info.keys():
                            if "received_pto" in info["project_management_checkoffs"].keys():
                                if "checked" in info["project_management_checkoffs"]["received_pto"].keys():
                                    if info["project_management_checkoffs"]["received_pto"]["checked"]:
                                        cancelled = False

                obj["cancelled"] = bool_mapping[str(int(cancelled))]
                ret_json.append(obj)
        
        self.response.out.write(json.dumps(ret_json))
        
    elif self.request.get("fn") == "october_installs_report":
        ret_json = []
        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_submission_date >= Helpers.pacific_now() + timedelta(days=-365))
        app_ids_to_query = ["-1"]
        rep_ids_to_query = ["-1"]
        for pp_sub in pp_subs:
            info = json.loads(pp_sub.extra_info)
            #info["project_management_checkoffs"][self.request.get("key")] = {"checked": checked, "date": self.request.get("date")}
            if "project_management_checkoffs" in info.keys():
                if "install" in info["project_management_checkoffs"].keys():
                    if "date" in info["project_management_checkoffs"]["install"].keys():
                        dt_vals = info["project_management_checkoffs"]["install"]["date"].split("-")
                        dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                        if dt.month == 10 and dt.year == 2017:
                            obj = {"customer_name": pp_sub.field_application_identifier}
                            obj["system_size"] = str(float(0))
                            obj["rep_name"] = pp_sub.rep_identifier                            
                            obj["rep_office"] = "-1"
                            rep_ids_to_query.append(pp_sub.rep_identifier)
                            app_ids_to_query.append(pp_sub.field_application_identifier)
                            ret_json.append(obj)

        app_identifier_name_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
        
        app_identifier_sys_size_dict = {}
        proposals = CustomerProposalInfo.query(CustomerProposalInfo.field_app_identifier.IN(app_ids_to_query))
        for proposal in proposals:
            proposal.fix_additional_amount()
            proposal.fix_system_size()
            info = json.loads(proposal.info)
            app_identifier_sys_size_dict[proposal.field_app_identifier] = str(info["system_size"])

        rep_identifier_name_dict = {}
        rep_identifier_office_identifier_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        office_ids_to_query = ["-1"]
        for rep in reps:
            rep_obj = {}
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_office_identifier_dict[rep.identifier] = rep.main_office
            office_ids_to_query.append(rep.main_office)

        for item in ret_json:
            app_identifier = item["customer_name"]
            rep_identifier = item["rep_name"]
            item["customer_name"] = app_identifier_name_dict[app_identifier]
            item["system_size"] = app_identifier_sys_size_dict[app_identifier]
            item["rep_name"] = rep_identifier_name_dict[rep_identifier]
            item["rep_office"] = rep_identifier_office_identifier_dict[rep_identifier]

        office_identifier_name_dict = {}
        offices = OfficeLocation.query(OfficeLocation.identifier.IN(office_ids_to_query))
        for office in offices:
            office_identifier_name_dict[office.identifier] = office.name

        for item in ret_json:
            office_identifier = item["rep_office"]
            item["rep_office"] = office_identifier_name_dict[office_identifier]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "multiple_debt_records_check":
        app_users = FieldApplicationUser.query(FieldApplicationUser.current_status == 0)
        rep_identifiers = []
        for user in app_users:
            rep_identifiers.append(user.identifier)

        debts = UserDebt.query(UserDebt.field_app_identifier.IN(rep_identifiers))
        distincts = []
        for debt in debts:
            if debt.field_app_identifier in distincts:
                self.response.out.write(debt.field_app_identifier)
                self.response.out.write("\n")
            distincts.append(debt.field_app_identifier)

    elif self.request.get("fn") == "installation_notes_send":
        notification = Notification.first(Notification.action_name == "Installation Notes")
        if not notification is None:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                subject = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s Installation Notes"
                msg = self.request.get("notes")
                for p in notification.notification_list:                    
                    Helpers.send_email(p.email_address, subject, msg)

                    content_dict = {}
                    content_dict["txt"] = [self.request.get("notes")]
                    CustomerTranscriber.transcribe_object(app_entry.identifier, self.request.get("user_identifier"), content_dict, 0, "panel_work")

    elif self.request.get("fn") == "export_event_owners":
        jsonn = {}
        events = CalendarEvent.query()
        for event in events:
            jsonn[event.identifier] = event.owner

        f = GCSLockedFile("cal_events.json")
        f.write(json.dumps(jsonn), "text/plain", "public-read")
        f.unlock()

    elif self.request.get("fn") == "update_event_owners2":
        f = GCSLockedFile("cal_events.json")
        content = json.loads(f.read())

        events = CalendarEvent.query()
        for event in events:
            items = []
            items.append(content[event.identifier])
            event.owners = json.dumps(items)
            event.put()

    elif self.request.get("fn") == "marketing_image_test":
        token = Helpers.guid()
        parameters = {}
        parameters["token"] = token
        parameters["path"] = "/people20.jpg"
        parameters["marketing_key"] = "testing"
        parameters["rep_identifier"] = "-1"

        kv = KeyValueStoreItem(
            identifier=Helpers.guid(),
            keyy="image_processing_" + parameters["token"],
            val="Processing Image...",
            expiration=Helpers.pacific_now() + timedelta(minutes=30)
        )
        kv.put()

        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/marketing_resize_image", params=parameters)

    elif self.request.get("fn") == "zencoder_test":
        from google.appengine.api import taskqueue
        parameters = {}
        parameters["url"] = "https://storage.googleapis.com/devnpfieldapp2.appspot.com/video_test_3.mp4"
        parameters["aspect"] = "landscape"
        parameters["error_message"] = "The video failed to upload. Please ensure the video size is small, and that the duration is less than 30 seconds."
        parameters["token"] = Helpers.guid()
        parameters["rep_identifier"] = "-1"
        parameters["marketing_key"] = "testing"
        kv = KeyValueStoreItem(
            identifier=Helpers.guid(),
            keyy="video_processing_" + parameters["token"],
            val="Processing video...",
            expiration=Helpers.pacific_now() + timedelta(minutes=30)
        )
        kv.put()
        taskqueue.add(url="/tq/marketing_resize_video", params=parameters)

    elif self.request.get("fn") == "marketing":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/marketing", params={})

    elif self.request.get("fn") == "pm_assist":
        from google.appengine.api import taskqueue
        token = Helpers.guid()
        taskqueue.add(url="/tq/pm_assist", params={"token": token, "user": self.request.get("user")})
        self.response.content_type = "application/json"
        ret_json = {"token": token}
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "pm_assist_status":
        ret_json = {"done": False, "data": None}
        self.response.content_type = "application/json"
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "pm_assist_status_" + self.request.get("token"))
        if not kv is None:
            ret_json["done"] = True
            try:
                f = GCSLockedFile("/Temp/pm_assist_" + self.request.get("token") + ".json")
                ret_json["data"] = json.loads(f.read())
                f.unlock()
                bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
                bucket = '/' + bucket_name
                filename = bucket + '/Temp/pm_assist_' + self.request.get("token") + '.json'
                gcs.delete(filename)
            except:
                ret_json = ret_json

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "hours_debugging":
        locations = UserLocationLogItem.query(
            ndb.AND(
                UserLocationLogItem.created >= datetime(2018, 1, 12),
                UserLocationLogItem.created < datetime(2018, 1, 13)
            )
        )

        rep_identifier_knocks_dict = {}
        for l in locations:
            if not l.rep_identifier in rep_identifier_knocks_dict.keys():
                rep_identifier_knocks_dict[l.rep_identifier] = 0
            rep_identifier_knocks_dict[l.rep_identifier] += 1

        self.response.out.write(json.dumps(rep_identifier_knocks_dict))

    elif self.request.get("fn") == "thomas_all_installs":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/thomas_all_installs", params={})

    elif self.request.get("fn") == "taku_abs":
        data = []
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.rep_id == "LOVE0806")
        for app_entry in app_entries:
            item = {}
            item["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            item["email"] = app_entry.customer_email
            item["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            item["address"] = app_entry.customer_address
            item["city"] = app_entry.customer_city
            item["state"] = app_entry.customer_state
            item["postal"] = app_entry.customer_postal
            data.append(item)

        self.response.out.write(json.dumps(data))

    elif self.request.get("fn") == "process_app_entry":
        from google.appengine.api import app_identity
        from datetime import timedelta
        from datetime import datetime
        now = Helpers.pacific_now() + timedelta(hours=1)
        if now.hour > 20 or now.hour < 9:
            now = now + timedelta(days=1)
            now = datetime(now.year, now.month, now.day, 9, 0, 0)

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == str(self.request.get("rep_identifier")))
        if (not app_entry is None) and (not rep is None):
            if not app_entry.processed:
                file_name = "/CampaignJobs/" + str(now.year) + "_" + str(now.month) + "_" + str(now.day) + "_" + str(now.hour) + "_jobs.json"
                f = GCSLockedFile(file_name)
                content = f.read()
                if content is None:
                    content = "[]"

                data = json.loads(content)
                data.append({"field_app_identifier": app_entry.identifier, "rep_identifier": rep.identifier, "key": "introductory_selfie"})
                f.write(json.dumps(data), "application/json", "public-read")

            app_entry.processed = True
            app_entry.put()

            if not rep is None:
                existing_lead = Lead.first(Lead.field_app_identifier == app_entry.identifier)
                if existing_lead is None:
                    lead = Lead(
                        identifier=Helpers.guid(),
                        field_app_identifier=app_entry.identifier,
                        rep_identifier=self.request.get("rep_identifier"),
                        solar_pro_identifier=app_entry.lead_generator,
                        status="unclaimed",
                        dt_accepted=datetime(1970, 1, 1),
                        dt_created=Helpers.epoch_millis_to_pacific_dt(app_entry.insert_time),
                        archived=False,
                        save_me=False
                    )
                    lead.put()

                    url = Helpers.shorten_url("https://" + app_identity.get_application_id() + ".appspot.com/rep?autoload=my_leads")
                    msg_sp = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                    if not msg_sp is None:
                        sp_name = msg_sp.first_name.strip().title() + " " + msg_sp.last_name.strip().title()
                        sp_phone = Helpers.format_phone_number(msg_sp.rep_phone)
                        msg = "New Lead: " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ", SP2 time is " + app_entry.sp_two_time.strftime("%m/%d/%Y %I:%M %p") + " Solar Pro: " + sp_name + ", " + sp_phone + "\n\n" + url                        
                        if not str(self.request.get("skip_text")) == "1":
                            Helpers.send_sms(rep.rep_phone, msg)

            solar_pro = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
            if not solar_pro is None:
                notification = Notification.first(Notification.action_name == "Solar Pro Lead Assigned")
                if not notification is None:
                    for person in notification.notification_list:
                        Helpers.send_email(person.email_address, "Lead Assigned", app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " (" + solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title() + "'s lead) was assigned to " + rep.first_name.strip().title() + " " + rep.last_name.strip().title())
                    

    elif self.request.get("fn") == "dallin_oneoff_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/dallin_oneoff", params={})

    elif self.request.get("fn") == "set_admin_lead_notes":
        note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "admin_lead_notes"
            )
        )
        if note is None:
            content_dict = {}
            content_dict["txt"] = [self.request.get("notes")]            
            CustomerTranscriber.transcribe_object(self.request.get("identifier"),
                                                    self.request.get("user_identifier"),
                                                    content_dict,
                                                    0,
                                                    "admin_lead_notes")
        else:
            content_dict = json.loads(note.content)
            content_dict["txt"][0] = self.request.get("notes")
            note.content = json.dumps(content_dict)
            note.put()

    elif self.request.get("fn") == "add_checklist_item_for_lead":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="lead_checklist_for_" + self.request.get("identifier"),
                expiration=datetime(1970, 1, 1),
                val="[]"
            )
        items = json.loads(kv.val)
        items.append({"name": self.request.get("name"), "date": self.request.get("date"), "checked": False})
        kv.val = json.dumps(items)
        kv.put()

    elif self.request.get("fn") == "drop_checklist_item_for_lead":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if not kv is None:
            value = json.loads(kv.val)
            del value[int(self.request.get("idx"))]
            kv.val = json.dumps(value)
            kv.put()

    elif self.request.get("fn") == "rename_checklist_item_for_lead":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if not kv is None:
            value = json.loads(kv.val)
            value[int(self.request.get("idx"))]["name"] = self.request.get("name")
            kv.val = json.dumps(value)
            kv.put()

    elif self.request.get("fn") == "rep_sp2_text_reminder_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/rep_sp2_text_reminder", params={})

    elif self.request.get("fn") == "checklist_for_lead_item_checkoff":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if not kv is None:
            value = json.loads(kv.val)
            value[int(self.request.get("idx"))]["checked"] = (self.request.get("checked") == "1")
            kv.val = json.dumps(value)
            kv.put()

    elif self.request.get("fn") == "update_lead_checklist_date":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if not kv is None:
            value = json.loads(kv.val)
            value[int(self.request.get("idx"))]["date"] = self.request.get("dt")
            kv.val = json.dumps(value)
            kv.put()

    elif self.request.get("fn") == "get_assigned_leads":
        ret_json = {"leads": []} 
        self.response.content_type = "application/json"
        oset = int(str(self.request.get("offset")))

        app_entries = FieldApplicationEntry.query(
            ndb.AND(
                FieldApplicationEntry.processed == 1
            )
        ).order(-FieldApplicationEntry.sp_two_time).fetch(50, offset=oset)

        app_ids_to_query = ["-1"]
        rep_ids_to_query = ["-1"]
        field_app_identifier_idx_dict = {}
        checklist_keys = ["-1"]
        checklist = Helpers.read_setting("lead_checklist")
        checklist_name_idx_dict = {}
        kv_keys_to_query = ["-1"]
        spanish_keys_to_query = ["-1"]
        for item in checklist:
            checklist_name_idx_dict[item] = len(checklist_name_idx_dict.keys())
            
        for app_entry in app_entries:
            app_ids_to_query.append(app_entry.identifier)
            if not app_entry.lead_generator in rep_ids_to_query:
                    rep_ids_to_query.append(app_entry.lead_generator)
            checklist_keys.append("lead_checklist_for_" + app_entry.identifier)
            spanish_keys_to_query.append(app_entry.identifier + "_espanol")

            field_app_identifier_idx_dict[app_entry.identifier] = len(ret_json["leads"])            
            kv_keys_to_query.append("ab_call_" + app_entry.identifier)

            obj = {}
            obj["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            obj["editable"] = {}
            obj["editable"]["first_name"] = app_entry.customer_first_name.strip().title()
            obj["editable"]["last_name"] = app_entry.customer_last_name.strip().title()
            obj["editable"]["address"] = app_entry.customer_address
            obj["editable"]["city"] = app_entry.customer_city
            obj["editable"]["state"] = app_entry.customer_state
            obj["editable"]["email"] = app_entry.customer_email
            obj["editable"]["phone"] = app_entry.customer_phone
            obj["editable"]["postal"] = app_entry.customer_postal
            obj["identifier"] = app_entry.identifier
            obj["location"] = app_entry.customer_city + ", " + app_entry.customer_state
            obj["address"] = app_entry.customer_address + "\n" + app_entry.customer_city + ", " + app_entry.customer_state + "\n" + app_entry.customer_postal
            obj["phone"] = Helpers.format_phone_number(app_entry.customer_phone)
            obj["email"] = app_entry.customer_email
            obj["solar_pro"] = app_entry.lead_generator
            obj["solar_pro_identifier"] = app_entry.lead_generator
            obj["sp_two_time"] = str(app_entry.sp_two_time).split(".")[0]
            obj["rep_notes"] = ""
            obj["admin_notes"] = ""
            obj["admin_checklist"] = []
            obj["call_completed"] = None
            obj["archived"] = app_entry.archived
            obj["save_me"] = app_entry.save_me
            obj["espanol"] = False

            for item in checklist:
                obj["admin_checklist"].append({"name": item, "checked": False, "date": "1970-01-01"})
            ret_json["leads"].append(obj)

        notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.note_key.IN(["rep_lead_notes", "admin_lead_notes"]),
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )

        for note in notes:
            idx = field_app_identifier_idx_dict[note.field_app_identifier]
            note_key_property_dict = {"rep_lead_notes": "rep_notes", "admin_lead_notes": "admin_notes"}
            ret_json["leads"][idx][note_key_property_dict[note.note_key]] = json.loads(note.content)["txt"][0]

        checklist_kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(checklist_keys))
        for checklist_kv in checklist_kvs:
            identifier = checklist_kv.keyy.split("_")[3]
            idx = field_app_identifier_idx_dict[identifier]
            value = json.loads(checklist_kv.val)
            for item in value.keys():
                cnt = 0
                for item2 in ret_json["leads"][idx]["admin_checklist"]:
                    if item2["name"] == item:
                        ret_json["leads"][idx]["admin_checklist"][checklist_name_idx_dict[item2["name"]]] = value[item]
                    cnt += 1


        ab_kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kv_keys_to_query))
        for kv in ab_kvs:
            keyy = kv.keyy
            identifier = keyy.replace("ab_call_", "")
            idx = field_app_identifier_idx_dict[identifier]
            ret_json["leads"][idx]["call_completed"] = (kv.val == "1")

            #ret_json["leads"][idx]["admin_checklist"] = clist

        spanish_kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(spanish_keys_to_query))
        for kv in spanish_kvs:
            identifier = kv.keyy.replace("_espanol", "")
            idx = field_app_identifier_idx_dict[identifier]
            ret_json["leads"][idx]["espanol"] = True

        rep_identifier_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        for l in ret_json["leads"]:
            try:
                l["solar_pro"] = rep_identifier_name_dict[l["solar_pro_identifier"]]
            except:
                l["solar_pro"] = "n/a"

        rep_ids_to_query2 = ["-1"]

        leads = Lead.query(Lead.field_app_identifier.IN(app_ids_to_query))
        bad_idxs = []
        for lead in leads:
            idx = field_app_identifier_idx_dict[lead.field_app_identifier]
            try:
                ret_json["leads"][idx]["status"] = lead.status
                ret_json["leads"][idx]["claimed_dt"] = str(lead.dt_accepted).split(".")[0]
                ret_json["leads"][idx]["assigned_dt"] = str(lead.dt_created).split(".")[0]
                ret_json["leads"][idx]["rep_identifier"] = lead.rep_identifier
            except:
                bad_idxs.append(idx)

            if not lead.rep_identifier in rep_ids_to_query2:
                rep_ids_to_query2.append(lead.rep_identifier)

        cnt = 0
        new_data = []
        for lead in ret_json["leads"]:
            if not cnt in bad_idxs:
                new_data.append(lead)
            cnt += 1
        ret_json["leads"] = new_data

        rep_identifier_name_dict2 = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query2))
        for rep in reps:
            rep_identifier_name_dict2[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        new_data = []
        for l in ret_json["leads"]:
            if "rep_identifier" in l.keys():
                new_data.append(l)

        ret_json["leads"] = new_data

        for l in ret_json["leads"]:
            rep_identifier = l["rep_identifier"]
            l["rep_name"] = rep_identifier_name_dict2[rep_identifier]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "thomas_report1":
        from google.appengine.api import taskqueue
        parameters = {}
        parameters["floor_year"] = self.request.get("floor_year")
        parameters["floor_month"] = self.request.get("floor_month")
        parameters["floor_day"] = self.request.get("floor_day")
        parameters["ceiling_year"] = self.request.get("ceiling_year")
        parameters["ceiling_month"] = self.request.get("ceiling_month")
        parameters["ceiling_day"] = self.request.get("ceiling_day")
        parameters["delivery"] = self.request.get("delivery")

        taskqueue.add(url="/tq/thomas_report1", params=parameters)

        self.response.out.write("Your report will be emailed to the delivery email specified")

    elif self.request.get("fn") == "save_lead_checklist":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "lead_checklist_for_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="lead_checklist_for_" + self.request.get("identifier"),
                expiration=datetime(1970, 1, 1)
            )
        kv.val = self.request.get("data")
        kv.put()

    elif self.request.get("fn") == "get_unassigned_leads":
        ret_json = {"leads": []}
        self.response.content_type = "application/json"
        leads = FieldApplicationEntry.query(
            ndb.AND(
                FieldApplicationEntry.processed == 0,
                FieldApplicationEntry.is_lead == True,
                FieldApplicationEntry.archived == False,
                FieldApplicationEntry.save_me == False
            )
        ).fetch(50)

        field_app_identifier_idx_dict = {}
        rep_ids_to_query = ["-1"]
        app_ids_to_query = ["-1"]
        kv_keys_to_query = ["-1"]
        for lead in leads:
            if lead.insert_time >= 1516064400000:
                app_ids_to_query.append(lead.identifier)
                kv_keys_to_query.append("ab_call_" + lead.identifier)
                kv_keys_to_query.append(lead.identifier + "_espanol")
                obj = {}
                obj["name"] = lead.customer_first_name.strip().title() + " " + lead.customer_last_name.strip().title()
                obj["editable"] = {}
                obj["editable"]["first_name"] = lead.customer_first_name.strip().title()
                obj["editable"]["last_name"] = lead.customer_last_name.strip().title()
                obj["editable"]["address"] = lead.customer_address
                obj["editable"]["city"] = lead.customer_city
                obj["editable"]["state"] = lead.customer_state
                obj["editable"]["email"] = lead.customer_email
                obj["editable"]["phone"] = lead.customer_phone
                obj["editable"]["postal"] = lead.customer_postal
                obj["identifier"] = lead.identifier
                obj["location"] = lead.customer_city + ", " + lead.customer_state
                obj["address"] = lead.customer_address + "\n" + lead.customer_city + ", " + lead.customer_state + "\n" + lead.customer_postal
                obj["phone"] = Helpers.format_phone_number(lead.customer_phone)
                obj["email"] = lead.customer_email
                obj["solar_pro"] = lead.lead_generator
                obj["solar_pro_identifier"] = lead.lead_generator
                obj["sp_two_time"] = str(lead.sp_two_time).split(".")[0]
                obj["rep_notes"] = ""
                obj["admin_notes"] = ""
                obj["call_completed"] = None
                obj["espanol"] = False

                field_app_identifier_idx_dict[lead.identifier] = len(ret_json["leads"])

                ret_json["leads"].append(obj)

                if not lead.lead_generator in rep_ids_to_query:
                    rep_ids_to_query.append(lead.lead_generator)

        notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.note_key.IN(["rep_lead_notes", "admin_lead_notes"]),
                CustomerNote.field_app_identifier.IN(app_ids_to_query)
            )
        )

        for note in notes:
            idx = field_app_identifier_idx_dict[note.field_app_identifier]
            note_key_property_dict = {"rep_lead_notes": "rep_notes", "admin_lead_notes": "admin_notes"}
            ret_json["leads"][idx][note_key_property_dict[note.note_key]] = json.loads(note.content)["txt"][0]

        kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kv_keys_to_query))
        for kv in kvs:
            keyy = kv.keyy
            identifier = None
            dict_key="call_completed"
            if "ab_call" in kv.keyy:
                identifier = keyy.replace("ab_call_", "")
            elif "espanol" in kv.keyy:
                identifier = keyy.replace("_espanol", "")
                dict_key="espanol"
            
            idx = field_app_identifier_idx_dict[identifier]
            ret_json["leads"][idx][dict_key] = (kv.val == "1")

        rep_identifier_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()            

        for lead in ret_json["leads"]:
            lead["solar_pro"] = rep_identifier_name_dict[lead["solar_pro"]]

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "backfill_quadrants_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill_quadrants", params={})

    elif self.request.get("fn") == "payroll_audit_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/payroll_audit", params={})

    elif self.request.get("fn") == "breadcrumbs_report_kickoff":
        start_dt = self.request.get("start")
        end_dt = self.request.get("end")
        mode = self.request.get("mode")
        recipient = str(self.request.get("recipient"))
        rep_identifier = str(self.request.get("rep_identifier"))
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/breadcrumbs_report", params = {"start_dt": start_dt, "end_dt": end_dt, "mode": mode, "recipient": recipient, "rep_identifier": rep_identifier})

    elif self.request.get("fn") == "solar_pro_bonus_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/solar_pro_bonus", params = {})

    elif self.request.get("fn") == "leads_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/leads_export", params={"start": self.request.get("start"), "end": self.request.get("end") ,"email": self.request.get("email")})

    elif self.request.get("fn") == "solar_pro_weekly_advance_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/solar_pro_weekly_advance", params={})

    elif self.request.get("fn") == "post_recurring_transactions_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/post_recurring_transactions", params={"frequency": self.request.get("frequency")})

    elif self.request.get("fn") == "pto_monthly_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/pto_monthly_report", params={"year": self.request.get("year"), "month": self.request.get("month")})

    elif self.request.get("fn") == "taylor_armstrong_export":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/taylor_armstrong_export", params={})

    elif self.request.get("fn") == "solar_pro_office_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/solar_pro_office_report", params={})

    elif self.request.get("fn") == "converted_aks_abs_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/converted_abs_aks", params={})

    elif self.request.get("fn") == "reps_with_marketing_mms":
        reps = FieldApplicationUser.query(
            ndb.AND(
                FieldApplicationUser.current_status == 0,
                FieldApplicationUser.user_type.IN(["energy_expert", "sales_manager"])
            )
        )
        rep_identifier_name_dict = {}
        rep_identifier_lead_tally = {}
        rep_identifier_own_tally = {}
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_lead_tally[rep.identifier] = False
            rep_identifier_own_tally[rep.identifier] = False

        for rep_identifier in rep_identifier_name_dict.keys():
            rep_identifier_lead_tally[rep_identifier] = Helpers.gcs_file_exists("/MarketingCollateral/introductory_selfie/" + rep_identifier + "/video.3gp")
            rep_identifier_own_tally[rep_identifier] = Helpers.gcs_file_exists("/MarketingCollateral/introductory_selfie_own/" + rep_identifier + "/video.3gp")

        data = []
        self.response.content_type = "application/json"
        for rep_identifier in rep_identifier_name_dict.keys():
            obj = {"name": rep_identifier_name_dict[rep_identifier]}
            obj["self_gen"] = str(rep_identifier_own_tally[rep_identifier]).lower()
            obj["lead"] = str(rep_identifier_lead_tally[rep_identifier]).lower()
            data.append(obj)

        self.response.out.write(json.dumps(data))

    elif self.request.get("fn") == "solar_pro_daily_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/solar_pro_daily_report", params={})

    elif self.request.get("fn") == "isaac_smith_debugging":
        logs_within = UserLocationLogItem.query(
            ndb.AND(
                UserLocationLogItem.rep_identifier == "a5b8e2fddd6d7f9be6257b6f18e0408e5a1ed99241077d025d619e87269da8e81b0b37dace469d447b56794e0f13afcb42f69248d44be491d6bd522af865fecc",
                UserLocationLogItem.created >= datetime(2018, 10, 12, 0, 0, 0),
                UserLocationLogItem.created <= datetime(2018, 10, 12, 23, 59, 59)
            )
        )

        data = []
        for l in logs_within:
            data.append({"in_bounds": l.in_bounds, "dt": str(l.created), "lat": str(l.latitude), "lng": str(l.longitude)})

        data = Helpers.bubble_sort(data, "dt")
        self.response.out.write(json.dumps(data))


    elif self.request.get("fn") == "eric_coomes_debugging":
        from datetime import datetime
        from datetime import timedelta
        from google.appengine.api import taskqueue
        import json

        now = Helpers.pacific_now()
        yesterday = now + timedelta(days=-1)
        yesterday_start = datetime(yesterday.year, yesterday.month, yesterday.day)
        yesterday_end = datetime(yesterday.year, yesterday.month, yesterday.day, 23, 59, 59)

        users = ["b3a1469ffe73e7bd2d50f8a533d1de4811e2cae5c4b1568ee4512fb13ae494c867ff92befa2c78339e16bde1a835858e52dfc682a9e2e923ab213f7623cc84d1"]
        if len(users) > 0:
            identifier = users[0]
            user = FieldApplicationUser.first(FieldApplicationUser.identifier == identifier)
            if not user is None:
                stats_to_put = []
                kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "clock_ins_clock_outs_" + str("2018-08-07") + "_" + identifier)
                if not kv is None:
                    items = json.loads(kv.val)            
                    if len(items) > 0:
                        last_item = items[len(items) - 1]
                        if last_item["status"] == "in":
                            location_logs = UserLocationLogItem.query(
                                ndb.AND(
                                    UserLocationLogItem.rep_identifier == identifier,
                                    UserLocationLogItem.created >= yesterday_start,
                                    UserLocationLogItem.created <= yesterday_end
                                )
                            )
                            cpy = []
                            for log in location_logs:
                                if log.in_bounds and (log.latitude < 400.0):
                                    cpy.append(log)
                            cpy = Helpers.bubble_sort(cpy, "created")
                            cpy.reverse()
                            if len(cpy) > 0:
                                items.append({"status": "out", "dt": str(cpy[0].dt).split(".")[0]})
                            else:
                                last_item2 = json.loads(json.dumps(items[len(items) - 1]))
                                last_item2["status"] = "out"
                                items.append(last_item2)

                        done = False
                        cnt = 0
                        total_seconds = float(0)
                        while not done:
                            start_dt_str = None
                            end_dt_str = None

                            try:
                                start_dt_str = items[cnt]["dt"]
                            except:
                                start_dt_str = None

                            try:
                                end_dt_str = items[cnt + 1]["dt"]
                            except:
                                end_dt_str = None

                            if (not start_dt_str is None) and (not end_dt_str is None):                            
                                start_dt_vals = start_dt_str.split(" ")[0].split("-")
                                start_dt_time_vals = start_dt_str.split(" ")[1].split(":")
                                end_dt_vals = end_dt_str.split(" ")[0].split("-")
                                end_dt_time_vals = end_dt_str.split(" ")[1].split(":")

                                floor = datetime(int(start_dt_vals[0]), int(start_dt_vals[1]), int(start_dt_vals[2]), int(start_dt_time_vals[0]), int(start_dt_time_vals[1]), int(start_dt_time_vals[2]))
                                ceiling = datetime(int(end_dt_vals[0]), int(end_dt_vals[1]), int(end_dt_vals[2]), int(end_dt_time_vals[0]), int(end_dt_time_vals[1]), int(end_dt_time_vals[2]))

                                logs_within = UserLocationLogItem.query(
                                    ndb.AND(
                                        UserLocationLogItem.rep_identifier == identifier,
                                        UserLocationLogItem.created >= floor,
                                        UserLocationLogItem.created <= ceiling
                                    )
                                )
                                log_tally = 0
                                for l in logs_within:
                                    log_tally += int(l.in_bounds and l.latitude < 400.0)

                                if log_tally > 0:
                                    total_seconds += (ceiling - floor).total_seconds()

                            cnt += 1

                            done = (start_dt_str is None) or (end_dt_str is None)

                        minutes = total_seconds / float(60)
                        Helpers.send_email("rnirnber@gmail.com", "minutes", str(minutes))
                        hours = minutes / float(60)
                        hours = round(hours, 0)
                        hours = int(hours)
                        cnt2 = 0
                        while cnt2 < hours:
                            stat = LeaderBoardStat(
                                identifier=Helpers.guid(),
                                dt=datetime(yesterday.year, yesterday.month, yesterday.day, 12, 0, 0),
                                field_app_identifier="-1",
                                metric_key="hours_knocked_v2",
                                office_identifier=user.main_office,
                                rep_id=user.rep_id,
                                in_bounds=True,
                                pin_identifier="-1"
                            )
                            stats_to_put.append(stat)
                            cnt2 += 1

                #if len(stats_to_put) == 1:
                    #stats_to_put[0].put()
                #elif len(stats_to_put) > 1:
                    #ndb.put_multi(stats_to_put)

    elif self.request.get("fn") == "distinct_zip_codes":
        app_entries = FieldApplicationEntry.query().fetch(1000000, projection=[FieldApplicationEntry.customer_postal])
        postals = []
        for app_entry in app_entries:
            if not app_entry.customer_postal in postals:
                postals.append(app_entry.customer_postal)

        self.response.out.write(json.dumps(postals))

    elif self.request.get("fn") == "weekly_surveys_monday_email":
        from google.appengine.api import app_identity
        from google.appengine.api import urlfetch
        sunday = Helpers.pacific_now()
        while (not sunday.isoweekday() == 7):
            sunday = sunday + timedelta(days=-1)
        
        notification = Notification.first(Notification.action_name == "Weekly Survey Delivery")
        if not notification is None:
            emails = []
            for notification_person in notification.notification_list:
                emails.append(notification_person.email_address)
            if len(emails) > 0:
                for email in emails:
                    for key in ["ees+sms", "spms"]:
                        req_headers = {}
                        req_headers["Content-Type"] = "application/x-www-form-urlencoded"

                        form_fields = {}
                        form_fields["fn"] = "d2g_kickoff"
                        form_fields["fn2"] = "weekly_surveys"
                        form_fields["start_dt"] = str(sunday.date())
                        form_fields["type"] = key
                        form_fields["recipient"] = email

                        resp = urlfetch.fetch(
                            url="https://" + app_identity.get_application_id() + ".appspot.com/data",
                            method=urlfetch.POST,
                            payload=urllib.urlencode(form_fields),
                            deadline=40,
                            headers=req_headers,
                            follow_redirects=False)
            

    elif self.request.get("fn") == "d2g_kickoff":
        gett = self.request.GET
        postt = self.request.POST

        parameters = {}
        for key in gett.keys():
            parameters[key] = gett[key]

        for key in postt.keys():
            parameters[key] = postt[key]

        parameters["fn"] = parameters["fn2"]
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/d2g", params=parameters)

    elif self.request.get("fn") == "load_construction_complete_tab":
        self.response.content_type = "application/json"
        ret_json = {"success": False}
        now = Helpers.pacific_now()
        one_year_ago = now + timedelta(days=-365)
        last_month_start = now
        last_month_end = None
        month_change = False
        while not month_change:
            current_month = last_month_start.month
            last_month_start = last_month_start + timedelta(days=-1)
            month_after_subtract = last_month_start.month

            month_change = not (current_month == month_after_subtract)
            if month_change:
                last_month_start_cpy = datetime(last_month_start.year, last_month_start.month, last_month_start.day)
                last_month_start = datetime(last_month_start.year, last_month_start.month, 1)
                last_month_end = datetime(last_month_start_cpy.year, last_month_start_cpy.month, last_month_start_cpy.day, 23, 59, 59)

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "cc_jobs_loaded_" + str(last_month_start.month) + "_" + str(last_month_start.year))
        if kv is None:
            new_kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="cc_jobs_loaded_" + str(last_month_start.month) + "_" + str(last_month_start.year),
                val="1",
                expiration=Helpers.pacific_now() + timedelta(days=90)
            )
            new_kv.put()
            ret_json["success"] = True
            keepers = ["-1"]
            pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.rep_submission_date >= one_year_ago)
            for pp_sub in pp_subs:
                info = json.loads(pp_sub.extra_info)
                if "project_management_checkoffs" in info.keys():
                    if "install" in info["project_management_checkoffs"].keys():
                        if "checked" in info["project_management_checkoffs"]["install"].keys():
                            if info["project_management_checkoffs"]["install"]["checked"]:
                                if "date" in info["project_management_checkoffs"]["install"].keys():
                                    dt_vals = info["project_management_checkoffs"]["install"]["date"].split("-")
                                    dt = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]))
                            
                                    if (dt >= last_month_start) and (dt <= last_month_end):
                                        keepers.append(pp_sub.field_application_identifier)

            states_to_put = []
            app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(keepers))
            for app_entry in app_entries:
                state = PayrollCustomerStateV3(
                    identifier=Helpers.guid(),
                    field_app_identifier=app_entry.identifier,
                    customer_first_name=app_entry.customer_first_name.strip().title(),
                    customer_last_name=app_entry.customer_last_name.strip().title(),
                    state_key="construction_complete"
                )
                states_to_put.append(state)

            if len(states_to_put) == 1:
                states_to_put[0].put()
            elif len(states_to_put) > 1:
                ndb.put_multi(states_to_put)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "create_v3_payroll_state_testing":
        state = PayrollCustomerStateV3(
                identifier=Helpers.guid(),
                field_app_identifier="dc73d9a63874c71525c372175289116b2dd8173ae3b78c4fb59510379e1b2ca6fb947ae45c6e7255d9302a6f2b525cd1b343cb70cc6087c726626fe2c7275a1c",
                customer_first_name="Payrollchanges",
                customer_last_name="Nirnberger",
                state_key="construction_complete"
            )
        state.put()

    elif self.request.get("fn") == "foreign_bucket_test":
        retryParams = gcs.RetryParams(initial_delay=0.2,
                                    max_delay=5.0,
                                    backoff_factor=2,
                                    max_retry_period=15,
                                    urlfetch_timeout=30)

        bucket = '/' + "npfieldapp_datastore_backups"
        filename = bucket + "/2019-01-25T08:00:10_12084/2019-01-25T08:00:10_12084.overall_export_metadata"

        f = gcs.open(filename, 'r', retry_params=retryParams)
        self.response.out.write(f.read())
        f.close()

    elif self.request.get("fn") == "backup_cleanup_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backup_cleanup", params={})

    elif self.request.get("fn") == "normal_availability":
        self.response.content_type = "application/json"
        ret_json = {"closers": []}

        app_entry_sp2_time_values = self.request.get("sp2").split(" ")
        dt_vals = app_entry_sp2_time_values[0].split("-")
        time_vals = app_entry_sp2_time_values[1].split(":")

        app_entry_sp2_time = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), int(time_vals[0]), int(time_vals[1].split(":")[0]))

        users = FieldApplicationUser.query(
            ndb.AND(
                FieldApplicationUser.main_office == self.request.get("identifier"),
                FieldApplicationUser.accepts_leads == True,
                FieldApplicationUser.current_status == 0
            )
        )
        user_identifier_office_dict = {}
        accepting_leads = []
        for user in users:
            user_identifier_office_dict[user.identifier] = user.main_office
            if user.accepts_leads:
                accepting_leads.append(user.identifier)

        f = GCSLockedFile("/AutoAssignStats/" + self.request.get("identifier") + ".json")
        suggested_users = json.loads(f.read())
        f.unlock()




        for user in suggested_users:
            if user["identifier"] in accepting_leads:
                minutes_off = Helpers.get_sp2_special_offset(user_identifier_office_dict[user["identifier"]])
                start_dt = app_entry_sp2_time
                end_dt = start_dt + timedelta(minutes=119 - minutes_off)
                result = Helpers.scheduling_conflict(start_dt, end_dt, user["identifier"])
                if result["success"]:
                    obj = {"identifier": user["identifier"]}
                    obj["name"] = user["name"]
                    obj["weight"] = 0
                    ret_json["closers"].append(obj)

        if len(ret_json["closers"]) > 0:
            ret_json["closers"][0]["name"] = ret_json["closers"][0]["name"] + " Recommended"

        f2 = GCSLockedFile("/DiveInWeight/weight.json")
        content = f2.read()
        f2.unlock()
        if not content is None:
            weight_data = json.loads(content)
            user_identifier_weight_dict = {}
            for item in weight_data:
                user_identifier_weight_dict[item["identifier"]] = item["weight"]

        for closer in ret_json["closers"]:
            if closer["identifier"] in user_identifier_weight_dict.keys():                
                closer["weight"] = user_identifier_weight_dict[closer["identifier"]]

        ret_json["closers"] = Helpers.bubble_sort(ret_json["closers"], "weight")
        ret_json["closers"].reverse()

        self.response.out.write(json.dumps(ret_json))
    
    elif self.request.get("fn") == "closer_same_day_availability":
        self.response.content_type = "application/json"
        ret_json = {"closers": []}

        today = Helpers.pacific_today()
        app_entry_sp2_time_values = self.request.get("sp2").split(" ")
        dt_vals = app_entry_sp2_time_values[0].split("-")
        time_vals = app_entry_sp2_time_values[1].split(":")

        app_entry_sp2_time = datetime(int(dt_vals[0]), int(dt_vals[1]), int(dt_vals[2]), int(time_vals[0]), int(time_vals[1].split(":")[0]))

        users = FieldApplicationUser.query(
            ndb.AND(
                FieldApplicationUser.main_office == self.request.get("identifier"),
                FieldApplicationUser.accepts_leads == True,
                FieldApplicationUser.current_status == 0
            )
        )

        users_cpy = []

        today = Helpers.pacific_today()
        user_identifier_name_dict = {}
        user_identifier_office_dict = {}
        kv_keys_to_query = ["-1"]
        for user in users:
            user_identifier_name_dict[user.identifier] = user.first_name.strip().title() + " " + user.last_name.strip().title()
            user_identifier_office_dict[user.identifier] = user.main_office
            key = "accepts_leads_" + str(today) + "_" + user.identifier
            kv_keys_to_query.append(key)
            users_cpy.append(user)

        
        already_assigned_kv_keys = ["-1"]
        accepting_leads_today = []
        kvs = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(kv_keys_to_query))
        for kv in kvs:
            user_identifier = kv.keyy.split("_")[3]
            time_vals = kv.val.split(":")
            latest_sp2_acceptance = datetime(today.year, today.month, today.day, int(time_vals[0]), int(time_vals[1].split(":")[0]))

            if latest_sp2_acceptance > app_entry_sp2_time:
                accepting_leads_today.append(user_identifier)
                already_assigned_kv_keys.append(user_identifier + "_same_day_assignment_" + str(today))

        already_assigned_identifiers = []
        kvs2 = KeyValueStoreItem.query(KeyValueStoreItem.keyy.IN(already_assigned_kv_keys))
        for kv2 in kvs2:
            user_identifier = kv2.keyy.split("_")[0]
            already_assigned_identifiers.append(user_identifier)

        keepers = []
        for identifier in accepting_leads_today:
            if not identifier in already_assigned_identifiers:
                keepers.append(identifier)

        for keeper in keepers:
            obj = {"identifier": keeper}
            obj["name"] = user_identifier_name_dict[keeper]
            obj["weight"] = 0
            ret_json["closers"].append(obj)

        if len(ret_json["closers"]) == 0:
            if str(self.request.get("override")) == "1":
                for user in users_cpy:
                    minutes_off = Helpers.get_sp2_special_offset(user_identifier_office_dict[user.identifier])
                    start_dt = app_entry_sp2_time
                    end_dt = start_dt + timedelta(minutes=119 - minutes_off)
                    result = Helpers.scheduling_conflict(start_dt, end_dt, user.identifier)
                    if result["success"]:
                        obj = {"identifier": user.identifier}
                        obj["name"] = user_identifier_name_dict[user.identifier]
                        obj["weight"] = 0
                        ret_json["closers"].append(obj)

        f = GCSLockedFile("/AutoAssignStats/" + self.request.get("identifier") + ".json")
        suggested_users = json.loads(f.read())
        f.unlock()

        already_suggested = False
        for suggestion in suggested_users:
            for closer in ret_json["closers"]:
                if closer["identifier"] == suggestion["identifier"]:
                    if not already_suggested:
                        already_suggested = True
                        closer["name"] = closer["name"] + " - Recommended"

        items1 = []
        items2 = []
        for item in ret_json["closers"]:
            if "Recommended" in item["name"]:
                items1.append(item)
            else:
                items2.append(item)

        ret_json["closers"] = items1 + items2

        f2 = GCSLockedFile("/DiveInWeight/weight.json")
        content = f2.read()
        f2.unlock()
        if not content is None:
            weight_data = json.loads(content)
            user_identifier_weight_dict = {}
            for item in weight_data:
                user_identifier_weight_dict[item["identifier"]] = item["weight"]

        for closer in ret_json["closers"]:
            if closer["identifier"] in user_identifier_weight_dict.keys():                
                closer["weight"] = user_identifier_weight_dict[closer["identifier"]]

        ret_json["closers"] = Helpers.bubble_sort(ret_json["closers"], "weight")
        ret_json["closers"].reverse()
        

        self.response.out.write(json.dumps(ret_json))        

    elif self.request.get("fn") == "address_search_field_init":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/address_search_field_init", params={})

    elif self.request.get("fn") == "pm_addy_search":
        ret_json = {"results": []}
        index = search.Index(name="cust_addies2")
        results = index.search(self.request.get("query"))
        eligible_identifiers = json.loads(self.request.get("identifiers"))

        keepers = ["-1"]
        for result in results:
            for field in result.fields:
                if field.name == "identifier":
                    if field.value in eligible_identifiers:
                        keepers.append(field.value)

        self.response.content_type = "application/json"
        ret_json["results"] = []

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(keepers))
        for app_entry in app_entries:
            obj = {"identifier": app_entry.identifier}
            obj["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            obj["address"] = app_entry.customer_address + " - " + app_entry.customer_postal 
            ret_json["results"].append(obj)

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "drop_miles_for_07_08_19":
        self.response.content_type = "text/plain"
        keys_to_delete = []
        plain_text = ""
        transactions = MonetaryTransactionV2.query(MonetaryTransactionV2.payout_date == date(2019, 7, 12))
        for t in transactions:
            if "Mileage reimbursement for weekly reports submitted between" in t.description:
                plain_text += t.description
                t.key.delete()
                plain_text += "\r\n\r\n"
                keys_to_delete.append(t.key)

        self.response.out.write(str(len(keys_to_delete)))        

    elif self.request.get("fn") == "survey_response_check":
        self.response.content_type = "application/json"
        ret_json = {}
        h_p_t = Helpers.pacific_today()
        start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
        while not start_dt.isoweekday() == 7:
            start_dt = start_dt + timedelta(days=-1)

        start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)

        survey = WeeklySurvey.first(
            ndb.AND(
                WeeklySurvey.rep_identifier == self.request.get("identifier"),
                WeeklySurvey.week_dt == start_dt.date()
            )
        )
        ret_json["found"] = not (survey is None)
        if not ret_json["found"]:
            if self.request.get("identifier") in ["4be72a3fad2533e3d7927b665dd6cdc81222a53b973a2f6892292e9a2fba4407c0dab3cdd4fe035f7a9908c3fdc971e00dfb66ce3696f187798749e1e7feb11a", "4ade4b083bfb695de867b1929a869e40ad8f861540fc3e04b655d4a805075b93f9e39a66971af5f43a0c99cd8abd50485fcec8476654632bd354347c15e8d114"]:
                ret_json["found"] = True
                
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "weekly_survey_text_notification_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/weekly_survey_text_notification", params={})

    elif self.request.get("fn") == "pull_stats_for_spm_weekly_survey":
        self.response.content_type = "application/json"
        ret_json = {}

        h_p_t = Helpers.pacific_today()
        start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
        while not start_dt.isoweekday() == 7:
            start_dt = start_dt + timedelta(days=-1)

        start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

        start_dt = start_dt + timedelta(days=-7)
        end_dt = end_dt + timedelta(days=-7)

        keys = ["hours_knocked_v2", "leads_acquired", "appointments_kept", "packets_submitted"]

        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            office = OfficeLocation.first(OfficeLocation.identifier == user.main_office)
            if not office is None:
                ret_json["office"] = office.name

                solar_pros = FieldApplicationUser.query(
                    ndb.AND(
                        FieldApplicationUser.user_type == "solar_pro",
                        FieldApplicationUser.current_status == 0,
                        FieldApplicationUser.main_office == office.identifier
                    )
                )
                solar_pro_rep_ids = []
                solar_pro_rep_id_name_dict = {}
                solar_pro_rep_id_stats_dict = {}
                for solar_pro in solar_pros:
                    solar_pro_rep_ids.append(solar_pro.rep_id)
                    solar_pro_rep_id_name_dict[solar_pro.rep_id] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()
                    obj = {"aks": 0, "hks": 0, "abs": 0, "name": solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()}
                    solar_pro_rep_id_stats_dict[solar_pro.rep_id] = obj

                rep_rep_ids = []
                rep_id_rep_name_dict = {}
                reps = FieldApplicationUser.query(
                    ndb.AND(
                        FieldApplicationUser.user_type.IN(["energy_expert", "sales_manager"]),
                        FieldApplicationUser.current_status == 0,
                        FieldApplicationUser.main_office == office.identifier
                    )
                )
                for rep in reps:
                    rep_rep_ids.append(rep.rep_id)
                    rep_id_rep_name_dict[rep.rep_id] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

                stats = LeaderBoardStat.query(
                    ndb.AND(
                        LeaderBoardStat.dt >= start_dt,
                        LeaderBoardStat.dt <= end_dt,
                        LeaderBoardStat.office_identifier == self.request.get("office_identifier"),
                        LeaderBoardStat.metric_key.IN(keys)
                    )
                )
                ret_json["personal_hks"] = 0
                ret_json["personal_abs"] = 0
                ret_json["personal_aks"] = 0
                ret_json["personal_cds"] = 0
                ret_json["team_hks"] = 0
                ret_json["team_abs"] = 0
                ret_json["team_aks"] = 0
                cd_app_ids_to_query1 = ["-1"]
                ak_app_ids_to_query1 = ["-1"]
                stats_cpy = []
                for stat in stats:
                    stats_cpy.append(stat)
                    if stat.rep_id == user.rep_id:
                        ret_json["personal_hks"] += int(stat.metric_key == "hours_knocked_v2")
                        ret_json["personal_abs"] += int(stat.metric_key == "leads_acquired")

                    if stat.metric_key == "packets_submitted":
                        cd_app_ids_to_query1.append(stat.field_app_identifier)
                    elif stat.metric_key == "appointments_kept":
                        ak_app_ids_to_query1.append(stat.field_app_identifier)
                    elif stat.metric_key == "hours_knocked_v2":
                        if not stat.rep_id in rep_rep_ids:
                            ret_json["team_hks"] += 1
                            if stat.rep_id in solar_pro_rep_id_stats_dict.keys():
                                solar_pro_rep_id_stats_dict[stat.rep_id]["hks"] += 1
                    elif stat.metric_key == "leads_acquired":
                        if not stat.rep_id in rep_rep_ids:
                            ret_json["team_abs"] += 1
                            if stat.rep_id in solar_pro_rep_id_stats_dict.keys():
                                solar_pro_rep_id_stats_dict[stat.rep_id]["abs"] += 1
                    

                ak_app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(ak_app_ids_to_query1))
                ak_app_entries_cpy = []
                lead_generator_tally_dict = {}
                for app_entry in ak_app_entries:
                    ak_app_entries_cpy.append(app_entry)
                    ret_json["personal_aks"] += int(user.identifier == app_entry.lead_generator)
                    ret_json["team_aks"] += int(not app_entry.lead_generator == "-1")
                    if not app_entry.lead_generator == "-1":
                        lead_generator_keys = lead_generator_tally_dict.keys()
                        if not app_entry.lead_generator in lead_generator_keys:
                            lead_generator_tally_dict[app_entry.lead_generator] = 0
                        lead_generator_tally_dict[app_entry.lead_generator] += 1

                identifiers = ["-1"] + lead_generator_tally_dict.keys()
                app_users = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(identifiers))
                for app_user in app_users:
                    rep_id = app_user.rep_id
                    if rep_id in solar_pro_rep_id_stats_dict.keys():
                        solar_pro_rep_id_stats_dict[rep_id]["aks"] = lead_generator_tally_dict[app_user.identifier]

                cd_app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(cd_app_ids_to_query1))
                cd_app_entries_cpy = []
                for app_entry in cd_app_entries:
                    cd_app_entries_cpy.append(app_entry)
                    ret_json["personal_cds"] += int(user.identifier == app_entry.lead_generator)

                ret_json["underperformers"] = []
                for rep_id in solar_pro_rep_id_stats_dict.keys():
                    obj = solar_pro_rep_id_stats_dict[rep_id]
                    if obj["aks"] < 2:
                        ret_json["underperformers"].append(obj)


                self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "miles_driven_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/miles_driven")

    elif self.request.get("fn") == "miles_driven_fix":
        transactions = MonetaryTransactionV2.query(MonetaryTransactionV2.payout_date == date(2019, 6, 14))
        for t in transactions:
            if "ileage reimbursement for weekly reports submitted between 2019-05-01 - 2019-05-31" in t.description:
                extra_info_dct = {}
                extra_info_dct["file_extension"] = "jpg"
                e_info = json.dumps(extra_info_dct)   
                t.extra_info = e_info
                self.response.out.write(t.description + "\r\n\r\n")
                t.put()

    elif self.request.get("fn") == "send_ed_csv":
        import base64
        csv_b64 = base64.b64encode(self.request.get("content"))
        attachment_data = {}
        attachment_data["data"] = [csv_b64]
        attachment_data["content_types"] = ["text/csv"]
        attachment_data["filenames"] = ["ed_export.csv"]

        user = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not user is None:
            Helpers.send_email(user.rep_email, "Employee Directory Export", user.first_name.strip().title() + ",\r\n\r\nPlease see attached CSV file, thanks", attachment_data)

    elif self.request.get("fn") == "lb_care_filter":
        self.response.content_type = "application/json"
        ret_json = {}

        care_notes = CustomerNote.query(
            ndb.AND(
                CustomerNote.field_app_identifier.IN(json.loads(self.request.get("app_identifiers"))),
                CustomerNote.note_key == "welfare"
            )
        )
        care_identifiers = []
        for note in care_notes:
            care_identifiers.append(note.field_app_identifier)

        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.field_app_identifier.IN(json.loads(self.request.get("app_identifiers"))),
                LeaderBoardStat.metric_key == "appointments_kept"
            )
        )

        for stat in stats:            
            if self.request.get("view") == "reps":
                dict_key = stat.rep_id
            else:
                dict_key = stat.office_identifier

            keys = ret_json.keys()
            if not dict_key in keys:
                ret_json[dict_key] = 0
            ret_json[dict_key] += int(stat.field_app_identifier in care_identifiers)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "last_day_worked_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/last_day_worked", params={})

    elif self.request.get("fn") == "get_employment_dates_for_user":
        self.response.content_type = "application/json"
        ret_json = {"data": "Data is Unavailable"}
        filename = "/EmploymentDates/" + self.request.get("identifier") + ".txt"
        if Helpers.gcs_file_exists(filename):
            f = GCSLockedFile(filename)
            content = f.read()
            f.unlock()
            ret_json["data"] = content

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "matt_collins_debugging_cust4":
        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.field_app_identifier == "9070315e761a675f673ef6a11f075ba6393a1b91d3b5a7f5b0d5c2ec89eac3d100267558b544e385e13006c1b2336a5db09a034b167458529e973c8562421f82"
            )
        )

        for stat in stats:
            self.response.out.write(stat.metric_key + str(stat.dt) + "\r\n")

    elif self.request.get("fn") == "ak_lookup":
        from google.appengine.api import search

        app_ids_to_query = ["-99"]

        index = search.Index(name="cust_names")
        results = index.search(self.request.get("query"))

        for result in results:
            for field in result.fields:
                if field.name == "cust_identifier":
                    app_ids_to_query.append(field.value)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))

        self.response.content_type = "application/json"
        ret_json = {"results": []}
        app_identifier_idx_dict = {}
        for app_entry in app_entries:
            app_identifier_idx_dict[app_entry.identifier] = len(ret_json["results"])
            obj = {"identifier": app_entry.identifier}
            obj["solar_pro"] = app_entry.lead_generator
            if not obj["solar_pro"] == "-1":
                sp = FieldApplicationUser.first(FieldApplicationUser.identifier == app_entry.lead_generator)
                if not sp is None:
                    obj["solar_pro"] = sp.first_name.strip().title() + " " + sp.last_name.strip().title()
            else:
                obj["solar_pro"] = "N/A"

            obj["closer"] = "N/A"
            closer = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not closer is None:
                obj["closer"] = closer.first_name.strip().title() + " " + closer.last_name.strip().title()

            obj["usage_type"] = "N/A"
            kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "original_real_or_estimated_" + app_entry.identifier)
            if not kv is None:
                obj["usage_type"] = kv.val.upper()

            obj["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            obj["address"] = app_entry.customer_address + " " + app_entry.customer_city + ", " + app_entry.customer_state
            obj["ak"] = "No"
            obj["ak_date"] = "Not an AK"
            obj["care"] = "No"
            note = CustomerNote.first(
                ndb.AND(
                    CustomerNote.field_app_identifier == app_entry.identifier,
                    CustomerNote.note_key == "welfare"
                )
            )
            if not note is None:
                obj["care"] = "Yes"

            obj["cd"] = "No"
            obj["cd_date"] = "Not a CD"
            cd_stat = LeaderBoardStat.first(
                ndb.AND(
                    LeaderBoardStat.field_app_identifier == app_entry.identifier,
                    LeaderBoardStat.metric_key == "packets_submitted"
                )
            )
            if not cd_stat is None:
                obj["cd"] = "Yes"
                obj["cd_date"] = str(cd_stat.dt.date())

            obj["care_override_code_provided"] = "No"
            care_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ab_override_" + app_entry.identifier)
            if not care_kv is None:
                obj["care_override_code_provided"] = "Yes"

            obj["status"] = "Not Available"
            lead = Lead.first(Lead.field_app_identifier == self.request.get("identifier"))
            if not lead is None:
                obj["status"] = lead.status

            obj["sp2_time"] = str(app_entry.sp_two_time).split(".")[0]

            obj["all_decision_makers_present"] = "Data Unavailable"
            decision_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ak_extras_" + app_entry.identifier)
            if not decision_kv is None:
                deserialized2 = json.loads(decision_kv.val)
                obj["all_decision_makers_present"] = deserialized2["all_present"]


            ret_json["results"].append(obj)

        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.field_app_identifier.IN(app_ids_to_query),
                LeaderBoardStat.metric_key == "appointments_kept"
            )
        )

        for stat in stats:
            good = False
            try:
                idx = app_identifier_idx_dict[stat.field_app_identifier]
                good = True
            except:
                x = 5
            if good:
                ret_json["results"][idx]["ak_date"] = str(stat.dt.date())
                ret_json["results"][idx]["ak"] = "Yes"

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "get_closer_signatures":
        ret_json = {"data": []}
        reps = FieldApplicationUser.query(
            ndb.AND(
                FieldApplicationUser.user_type.IN(["energy_expert", "sales_manager"]),
                FieldApplicationUser.current_status == 0
            )
        )
        for rep in reps:
            obj = {"name": rep.first_name.strip().title() + " " + rep.last_name.strip().title()}
            obj["identifier"] = rep.identifier
            obj["image_exists"] = Helpers.gcs_file_exists("/Images/RepSignatures/" + rep.identifier + ".jpg")
            ret_json["data"].append(obj)

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "yayroll_fix":        
        self.response.content_type = "text/plain"
        transactions = MonetaryTransactionV2.query(
            MonetaryTransactionV2.description_key == "ak_pay",
            MonetaryTransactionV2.payout_date == date(2019, 6, 28)
        )
        for t in transactions:
            if "AK Pay" in t.description:
                if "'s deal" in t.description:
                    self.response.out.write(t.description + "\r\n\r\n")

    elif self.request.get("fn") == "rep_quad_query_rep_portal":
        self.response.content_type = "application/json"
        ret_json = {"quads": []}
        quads = RepQuadrant.query(ndb.AND(
            RepQuadrant.rep_identifier == self.request.get("identifier"),
            RepQuadrant.active == True
        ))
        for quad in quads:
            obj = {}
            obj["identifier"] = quad.identifier
            obj["all_points"] = quad.all_points
            ret_json["quads"].append(obj)

        self.response.out.write(json.dumps(ret_json))


    elif self.request.get("fn") == "drop_quad_fix_results":
        self.response.content_type = "text/plain"
        quadrants = RepQuadrant.query()
        quadrants_found = []
        details = QuadrantAssignmentDetails.query()
        details_found = []

        for quadrant in quadrants:
            quadrants_found.append(quadrant.identifier)
        for detail in details:
            details_found.append(detail.quadrant_identifier)

        output = ""
        for identifier in details_found:
            if not identifier in quadrants_found:
                output += identifier
                output += "\n"

        self.response.out.write("details length: " + str(len(details_found)) + ", quads length: " + str(len(quadrants_found)))
     

    elif self.request.get("fn") == "cole_testing":
        path = Helpers.get_html_path('cole_testing.html')
        self.response.out.write(template.render(path, {}))

    elif self.request.get("fn") == "pull_pins_for_quad":
        ret_json = []
        self.response.content_type = "application/json"
        pins = PinPoint.query(PinPoint.quadrant_identifier == self.request.get("identifier"))
        blacklist = Helpers.read_setting("blacklist_pins")
        blacklist_coords = []
        for p in blacklist:
            blacklist_coords.append(p["geo"])
        for pin in pins:
            obj = {"identifier": pin.identifier}
            obj["lat"] = str(pin.latitude)
            obj["lng"] = str(pin.longitude)
            obj["blacklist"] = False
            combined = obj["lat"] + "_" + obj["lng"]
            if combined in blacklist_coords:
                obj["blacklist"] = True
            ret_json.append(obj)

        self.response.out.write(json.dumps(ret_json))
            
    elif self.request.get("fn") == "add_to_pin_blacklist":
        self.response.content_type = "application/json"
        blacklist = Helpers.read_setting("blacklist_pins")
        obj = {"address": self.request.get("address")}
        obj["geo"] = self.request.get("lat") + "_" + self.request.get("lng")
        blacklist.append(obj)
        Helpers.write_setting("blacklist_pins", blacklist)        
        self.response.out.write(json.dumps({}))

    elif self.request.get("fn") == "get_roof_quote":
        self.response.content_type = "application/json"
        ret_json = {"without_discount": "$0.00", "with_discount": "$0.00", "squares": float(0), "savings": "$0.00"}
        booking = SurveyBooking.first(SurveyBooking.field_app_identifier == self.request.get("identifier"))
        if not booking is None:
            this_fund = booking.fund
            funds = Helpers.list_funds()
            for fund in funds:
                if fund["value"] == this_fund:
                    squares = float(0)
                    if self.request.get("stories") == "one":
                        squares = ((float(self.request.get("sq_feet")) + (float(250) * float(self.request.get("garages")))) * float(1.4)) / float(100) + float(4)
                    elif self.request.get("stories") == "two":
                        squares = (float(self.request.get("sq_feet")) + (float(250) * float(self.request.get("garages")))) / float(100) + float(4)

                    ret_json["squares"] = round(squares, 2)
                    total = squares * float(450)

                    ret_json["without_discount"] = Helpers.currency_format(total)
                    discount_percentage = fund["discount_percentage"]
                    discount_percentage = discount_percentage.replace("%", "")
                    discount_percentage = float(discount_percentage)
                    discount_percentage *= float(0.01)

                    discount_total = total - (total * discount_percentage)
                    discount_total_str = Helpers.currency_format(discount_total)
                    ret_json["with_discount"] = discount_total_str

                    ret_json["savings"] = Helpers.currency_format(total - discount_total)


        self.response.out.write(json.dumps(ret_json))
                        
    elif self.request.get("fn") == "fetch_pending_cds":
        ret_json = {"items": [], "dollars": 100} 
        app_ids_to_query = ["-2"]
        rep_ids_to_query = ["-2"]
        
        pending_cds = PendingCDPayment.query().order(PendingCDPayment.dt)
        for pending_cd in pending_cds:
            obj = {"identifier": pending_cd.identifier, "field_app_identifier": pending_cd.field_app_identifier, "dt": str(pending_cd.dt).split(".")[0]}
            app_ids_to_query.append(pending_cd.field_app_identifier)
            if not pending_cd.rep_identifier in rep_ids_to_query:
                rep_ids_to_query.append(pending_cd.rep_identifier)
            obj["rep_identifier"] = pending_cd.rep_identifier
            if not pending_cd.solar_pro_identifier in rep_ids_to_query:
                rep_ids_to_query.append(pending_cd.solar_pro_identifier)
            obj["solar_pro_identifier"] = pending_cd.solar_pro_identifier
            ret_json["items"].append(obj)

        rep_identifier_name_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()

        app_identifier_name_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        for item in ret_json["items"]:
            item["rep_name"] = rep_identifier_name_dict[item["rep_identifier"]]
            item["solar_pro_name"] = rep_identifier_name_dict[item["solar_pro_identifier"]]        
            item["customer_name"] = app_identifier_name_dict[item["field_app_identifier"]]

        self.response.content_type = "application/json"
        self.response.out.write(json.dumps(ret_json))

        
                        
    elif self.request.get("fn") == "fetch_pending_aks":
        self.response.content_type = "application/json"
        ret_json = {"items": []}
        pending_aks = PendingAK.query().order(PendingAK.dt)
        field_app_identifier_idx_dict = {}
        rep_ids_to_query = ["-2"]
        solar_pro_ids_to_query = ["-2"]
        app_ids_to_query = ["-2"]
        for ak in pending_aks:
            if (not ak.field_app_identifier == "6a85d7f1eeee9ea8532a6404ad1d5d2e327f4f2db5c89c8238c07e34c721bd4bec64c874364d28dfbb0a7088b6141b3e3272f2bdf1ed751fd1b50985ff2fe3d3") and (not ak.field_app_identifier == "3fac379f5af07859bd4fdb193586b5c7ef43988907c1a08df394aba2fe15701d47f61307439e8a9ea8c93c031d05443e7a58cd5df5b97862b1b0589058732a1f"):                    
                field_app_identifier_idx_dict[ak.field_app_identifier] = len(ret_json["items"])
                if not ak.solar_pro_identifier in solar_pro_ids_to_query:
                    solar_pro_ids_to_query.append(ak.solar_pro_identifier)
                if not ak.rep_identifier in rep_ids_to_query:
                    rep_ids_to_query.append(ak.rep_identifier)
                if not ak.field_app_identifier in app_ids_to_query:
                    app_ids_to_query.append(ak.field_app_identifier)

                obj = {"identifier": ak.identifier}
                obj["field_app_identifier"] = ak.field_app_identifier
                obj["dt"] = str(ak.dt).split(".")[0]
                obj["solar_pro_identifier"] = ak.solar_pro_identifier
                obj["rep_identifier"] = ak.rep_identifier
                ret_json["items"].append(obj)

        rep_identifier_name_dict = {}
        rep_identifier_phone_dict = {}
        reps = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(rep_ids_to_query))
        for rep in reps:
            rep_identifier_name_dict[rep.identifier] = rep.first_name.strip().title() + " " + rep.last_name.strip().title()
            rep_identifier_phone_dict[rep.identifier] = rep.rep_phone

        solar_pro_identifier_name_dict = {}
        solar_pro_identifier_phone_dict = {}
        solar_pros = FieldApplicationUser.query(FieldApplicationUser.identifier.IN(solar_pro_ids_to_query))
        for solar_pro in solar_pros:
            solar_pro_identifier_name_dict[solar_pro.identifier] = solar_pro.first_name.strip().title() + " " + solar_pro.last_name.strip().title()
            solar_pro_identifier_phone_dict[solar_pro.identifier] = solar_pro.rep_phone

        for item in ret_json["items"]:
            item["solar_pro_name"] = solar_pro_identifier_name_dict[item["solar_pro_identifier"]]
            item["solar_pro_phone"] = solar_pro_identifier_phone_dict[item["solar_pro_identifier"]]
            item["solar_pro_phone_formatted"] = Helpers.format_phone_number(item["solar_pro_phone"])

            item["rep_name"] = rep_identifier_name_dict[item["rep_identifier"]]
            item["rep_phone"] = rep_identifier_phone_dict[item["rep_identifier"]]
            item["rep_phone_formatted"] = Helpers.format_phone_number(item["rep_phone"])

        app_identifier_name_dict = {}
        app_identifier_sp2_dict = {}
        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            app_identifier_name_dict[app_entry.identifier] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()
            app_identifier_sp2_dict[app_entry.identifier] = str(app_entry.sp_two_time).split(".")[0]

        for item in ret_json["items"]:
            item["customer_name"] = app_identifier_name_dict[item["field_app_identifier"]]
            item["sp2"] = app_identifier_sp2_dict[item["field_app_identifier"]]

        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.field_app_identifier.IN(app_ids_to_query),
                LeaderBoardStat.metric_key == "appointments_kept"
            )
        )
        field_app_identifier_dt_dict = {}
        for stat in stats:
            field_app_identifier_dt_dict[stat.field_app_identifier] = stat.dt

        for item in ret_json["items"]:
            item["ak_recorded"] = str(field_app_identifier_dt_dict[item["field_app_identifier"]]).split(".")[0]            

        self.response.out.write(json.dumps(ret_json))            

    elif self.request.get("fn") == "fix_juan":
        user = FieldApplicationUser.first(FieldApplicationUser.identifier == "9b2e34e9af26286620f241ed92fd3b5f8a22deef3dca4de60c6bd15728e0098e9bba4fead00a5cb628a4f0f43c2b4f9b8c52b8afc18d65c41491748f511e3c2c")
        if not user is None:
            user.registration_date = date(2016, 8, 1)
            user.put()

    elif self.request.get("fn") == "pending_ak_prep_fn1":
        self.response.content_type = "application/json"
        ret_json = {}

        ret_json["usage_type"] = "real"
        ret_json["first_ak"] = False
        usage_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "original_real_or_estimated_" + self.request.get("identifier"))
        if not usage_kv is None:
            ret_json["usage_type"] = usage_kv.val

        ret_json["question_1"] = "Data Unavailable"
        ret_json["question_2"] = "Data Unavailable"
        ret_json["question_3"] = "Data Unavailable"
        ret_json["ran_credit"] = False
        extra_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "ak_extras_" + self.request.get("identifier"))
        if not extra_kv is None:
            deserialized = json.loads(extra_kv.val)
            ret_json["question_1"] = deserialized["got_inside"]
            ret_json["question_2"] = deserialized["decision_makers_tally"]
            ret_json["question_3"] = deserialized["all_present"]
            if "ran_credit" in deserialized.keys():
                if deserialized["ran_credit"]:
                    ret_json["ran_credit"] = True

        ret_json["care"] = True
        welfare_note = CustomerNote.first(
            ndb.AND(
                CustomerNote.field_app_identifier == self.request.get("identifier"),
                CustomerNote.note_key == "welfare"
            )
        )
        if welfare_note is None:
            ret_json["care"] = False

        h_p_t = Helpers.pacific_today()

        start_dt = datetime(h_p_t.year, h_p_t.month, h_p_t.day)
        while not start_dt.isoweekday() == 7:
            start_dt = start_dt + timedelta(days=-1)

        start_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = datetime(start_dt.year, start_dt.month, start_dt.day)
        end_dt = end_dt + timedelta(seconds=-1) + timedelta(days=7)

        sp2 = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
        if not sp2 is None:
            stats = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key == "aks_paid",
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt
                )
            )
            stat_cnt = 0
            for stat in stats:
                if stat.rep_id == sp2.rep_id:
                    stat_cnt += 1

            ret_json["this_week_tally"] = stat_cnt
            ret_json["base_amount"] = float(0)
            ret_json["consecutive_bonus"] = float(0)
            ret_json["real_usage_bonus"] = float(0)

            if stat_cnt == 7:
                ret_json["consecutive_bonus"] = float(800)
            elif stat_cnt > 7:
                ret_json["consecutive_bonus"] = float(100)

            stats2 = LeaderBoardStat.query(
                ndb.AND(
                    LeaderBoardStat.metric_key == "appointments_kept",
                    LeaderBoardStat.dt >= start_dt,
                    LeaderBoardStat.dt <= end_dt
                )
            )
            stats_cpy = []
            for s in stats2:
                if s.rep_id == sp2.rep_id:
                    obj = {}
                    obj["field_app_identifier"] = s.field_app_identifier
                    obj["start_dt"] = s.dt
                    obj["rep_id"] = s.rep_id
                    stats_cpy.append(obj)

            stats_cpy = Helpers.bubble_sort(stats_cpy, "start_dt")            
            if len(stats_cpy) > 0:
                if stats_cpy[0]["field_app_identifier"] == self.request.get("identifier"):
                    ret_json["first_ak"] = True
            
            pricing_structures = Helpers.get_pricing_structures()
            sp = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
            if not sp is None:
                office = OfficeLocation.first(OfficeLocation.identifier == sp.main_office)
                if not office is None:
                    market_key = office.parent_identifier
                    if market_key in pricing_structures.keys():
                        base_amount = str(pricing_structures[market_key][sp.user_type + "_pay_per_ak"])
                        base_amount = base_amount.replace("$", "").replace(",", "")
                        ret_json["base_amount"] = float(base_amount)
                        usage_bonus_amount = str(pricing_structures[market_key][sp.user_type + "_real_usage_ak_bonus"])
                        usage_bonus_amount = usage_bonus_amount.replace("$", "").replace(",", "")
                        ret_json["real_usage_bonus"] = float(usage_bonus_amount)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "ak_quickie":
        from google.appengine.api import app_identity
        if app_identity.get_application_id() == "devnpfieldapp2":
            pending_ak = PendingAK(
                identifier=Helpers.guid(),
                dt=Helpers.pacific_now(),
                field_app_identifier="c545e02de8ea4bb8b825eec7d02caf38cbf346d10b10a68b3b4e05303d42c821e1f9f6d1e37cdf34c9302f044275062a5886b8593936ad8958a706d3a31be428",
                solar_pro_identifier="1a046aa337301bd85fe966408fd0a16d497d583c8883f884bd47dab203ed6813c08d40ec6d163930f63718d0858d738e5034fb96eafa1ed8480a3cfba6d3e9e5",
                rep_identifier="28e700623c13b03b7d077c5106fd93962a5f6ee813429b8659bb76046d4cd68c8fd136c14b661af3f77df190c17f9182cd60e7a2c2e5be91861103486a8f9c14"
            )
            pending_ak.put()
        else:
            pending_ak = PendingAK(
                identifier=Helpers.guid(),
                dt=Helpers.pacific_now(),
                field_app_identifier="3c47819e1fdd802dd6f47c6e6dd0c115284e085a0881cf5c9f431c81bf84fa086bd8a1f84b31a57a040f7adf9b477fa6c5fdd32567dfd9905321ba31ad6d1e7e",
                solar_pro_identifier="047c363e3f19ba7dbbc6bcf2ea306177f207d836830d6e5f80f0bb6273ba76d7d80ef64043e50d4c3d388a52c236d00876653a2e6c7b8bb5f5a424edcac041f4",
                rep_identifier="fff4eb8e26f78c8fc8ec1ca092dc94061f9b470e058cf91a3e0db3d902accb45c17b8744669a6ab2ce20e6bd9d0ea591ef2b6fbcf64c19bb0d02c86fba8da828"
            )
            pending_ak.put()

    elif self.request.get("fn") == "cd_quickie":
        pending_cd = PendingCDPayment(
            identifier=Helpers.guid(),
            dt=Helpers.pacific_now(),
            field_app_identifier="c545e02de8ea4bb8b825eec7d02caf38cbf346d10b10a68b3b4e05303d42c821e1f9f6d1e37cdf34c9302f044275062a5886b8593936ad8958a706d3a31be428",
            solar_pro_identifier="1a046aa337301bd85fe966408fd0a16d497d583c8883f884bd47dab203ed6813c08d40ec6d163930f63718d0858d738e5034fb96eafa1ed8480a3cfba6d3e9e5",
            rep_identifier="28e700623c13b03b7d077c5106fd93962a5f6ee813429b8659bb76046d4cd68c8fd136c14b661af3f77df190c17f9182cd60e7a2c2e5be91861103486a8f9c14"
        )
        pending_cd.put()

    elif self.request.get("fn") == "drop_pending_cd":
        ret_json = {}
        cd = PendingCDPayment.first(PendingCDPayment.identifier == self.request.get("identifier"))
        if not cd is None:
            cd.key.delete()
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "drop_pending_ak":
        self.response.content_type = "application/json"
        ret_json = {}
        ret_json["success"] = True
        aks = PendingAK.query(PendingAK.field_app_identifier == self.request.get("field_app_identifier"))
        for ak in aks:
            ak.key.delete()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "commit_ak_payment":
        self.response.content_type = "application/json"

        ret_json = {"already_paid": False}

        from google.appengine.api import search
        h_p_n = Helpers.pacific_now()

        payout_dt = h_p_n.date()
        this_weekday = h_p_n.isoweekday()
        if this_weekday == 1:
            payout_dt = (h_p_n + timedelta(days=11)).date()
        elif this_weekday == 2:
            payout_dt = (h_p_n + timedelta(days=10)).date()
        elif this_weekday == 3:
            payout_dt = (h_p_n + timedelta(days=9)).date()
        elif this_weekday == 4:
            payout_dt = (h_p_n + timedelta(days=8)).date()
        elif this_weekday == 5:
            payout_dt = (h_p_n + timedelta(days=7)).date()
        elif this_weekday == 6:
            payout_dt = (h_p_n + timedelta(days=6)).date()
        elif this_weekday == 7:
            payout_dt = (h_p_n + timedelta(days=12)).date()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if str(self.request.get("dummy")) == "1":            
            if not app_entry is None:
                existing_transaction = MonetaryTransactionV2.first(
                    ndb.AND(
                        MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                        MonetaryTransactionV2.description_key == "ak_pay"
                    )
                )
                if existing_transaction is None:
                    t2 = MonetaryTransactionV2(
                        approved=True,
                        cents=25,
                        check_number=-1,
                        created=h_p_n,
                        denied=False,
                        description=app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " is ineligible for AK payment. One or more of the following is true: The customer was CARE/Medical, not all decision makers were present in the meeting.",
                        description_key="ak_pay",
                        dollars=0,
                        extra_info="{}",
                        field_app_identifier=self.request.get("identifier"),
                        identifier=Helpers.guid(),
                        paid=False,
                        payout_date=payout_dt,
                        recipient=self.request.get("solar_pro")
                    )
                    if self.request.get("first_ak") == "1":
                        t2.description = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " was the first AK for the week, which makes payment ineligible."

                    docs_to_put = []
                    s_index = search.Index(name="v2_transactions")
                    
                    docs_to_put.append(
                        search.Document(
                            fields=[
                                search.TextField(name="identifier", value=t2.identifier),
                                search.TextField(name="description", value=t2.description)
                            ]
                        )
                    )
                    t2.put()
                    s_index.put(docs_to_put)

        if str(self.request.get("dummy")) == "0":
            full_amount = float(self.request.get("pre_tax_amount"))
            dollars1 = int(full_amount)
            cents1 = full_amount - float(dollars1)
            cents1 = int(cents1)

            rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("rep"))
            if not rep is None:
                app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
                if not app_entry is None:
                    existing_transaction = MonetaryTransactionV2.first(
                        ndb.AND(
                            MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                            MonetaryTransactionV2.description_key == "ak_pay"
                        )
                    )
                    pt_tax_amt = float(self.request.get("post_tax_amount"))
                    is_instant_payment = (pt_tax_amt > float(0))
                    if not (existing_transaction is None) and is_instant_payment:
                        ret_json["already_paid"] = True

                    if existing_transaction is None:                        
                        t2 = MonetaryTransactionV2(
                            approved=True,
                            cents=cents1,
                            check_number=-1,
                            created=h_p_n,
                            denied=False,
                            description="AK payment for " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " meeting with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " with " + self.request.get("usage_type") + " usage data obtained. After tax payment of " + Helpers.currency_format(float(self.request.get("post_tax_amount"))) + " was issued on " + str(Helpers.pacific_today()) + " via New Power payroll card",
                            description_key="ak_pay",
                            dollars=dollars1,
                            extra_info="{}",
                            field_app_identifier=self.request.get("identifier"),
                            identifier=Helpers.guid(),
                            paid=False,
                            payout_date=payout_dt,
                            recipient=self.request.get("solar_pro")
                        )
                        if is_instant_payment:
                            t2.dollars = 0
                            t2.cents = 1
                        if not is_instant_payment:
                            t2.description = "AK payment for " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " meeting with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + " with " + self.request.get("usage_type") + " usage data obtained."
                        else:
                            text_recipient = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
                            if not text_recipient is None:
                                Helpers.send_sms(text_recipient.rep_phone, "New Power just paid you " + Helpers.currency_format(float(self.request.get("post_tax_amount"))) + " for an AK with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ". Congrats!")

                        docs_to_put = []
                        s_index = search.Index(name="v2_transactions")
                        
                        docs_to_put.append(
                            search.Document(
                                fields=[
                                    search.TextField(name="identifier", value=t2.identifier),
                                    search.TextField(name="description", value=t2.description)
                                ]
                            )
                        )

                        debt = UserDebt.first(UserDebt.field_app_identifier == self.request.get("solar_pro"))
                        if not debt is None:
                            debt_items = json.loads(debt.items)
                            rounded = round(full_amount, 2)
                            debt_items.append({"date": str(h_p_n.date()), "amount": rounded, "description": "Advance/Early AK payment for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()})
                            debt.items = json.dumps(debt_items)
                            debt.total += debt_items[len(debt_items) - 1]["amount"]

                            

                            if False:
                                #if is_instant_payment:
                                debt.put()
                            t2.put()
                            s_index.put(docs_to_put)

                        stat_recipient = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
                        if not stat_recipient is None:
                            stat = LeaderBoardStat(
                                identifier=Helpers.guid(),
                                rep_id=stat_recipient.rep_id,                    
                                office_identifier=stat_recipient.main_office,
                                field_app_identifier=app_entry.identifier,
                                in_bounds=True,
                                pin_identifier="-1",
                                metric_key="aks_paid",
                                dt=Helpers.pacific_now()
                            )
                            if self.request.get("usage_type") == "real":
                                stat.put()

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "commit_cd_payment":
        self.response.content_type = "application/json"
        ret_json = {"already_paid": False}
        from google.appengine.api import search
        h_p_n = Helpers.pacific_now()

        payout_dt = h_p_n.date()
        this_weekday = h_p_n.isoweekday()
        if this_weekday == 1:
            payout_dt = (h_p_n + timedelta(days=11)).date()
        elif this_weekday == 2:
            payout_dt = (h_p_n + timedelta(days=10)).date()
        elif this_weekday == 3:
            payout_dt = (h_p_n + timedelta(days=9)).date()
        elif this_weekday == 4:
            payout_dt = (h_p_n + timedelta(days=8)).date()
        elif this_weekday == 5:
            payout_dt = (h_p_n + timedelta(days=7)).date()
        elif this_weekday == 6:
            payout_dt = (h_p_n + timedelta(days=6)).date()
        elif this_weekday == 7:
            payout_dt = (h_p_n + timedelta(days=12)).date()

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))

        full_amount = float(self.request.get("pre_tax_amount"))
        dollars1 = int(full_amount)
        cents1 = full_amount - float(dollars1)
        cents1 = int(cents1)

        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("rep"))
        if not rep is None:
            app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
            if not app_entry is None:
                existing_transaction = MonetaryTransactionV2.first(
                    ndb.AND(
                        MonetaryTransactionV2.field_app_identifier == self.request.get("identifier"),
                        MonetaryTransactionV2.description_key == "cd_sp_pay"
                    )
                )
                pt_tax_amt = float(self.request.get("post_tax_amount"))
                is_instant_payment = (pt_tax_amt > float(0))

                if (not existing_transaction is None) and is_instant_payment:
                    ret_json["already_paid"] = True

                if existing_transaction is None:                    
                    t2 = MonetaryTransactionV2(
                        approved=True,
                        cents=cents1,
                        check_number=-1,
                        created=h_p_n,
                        denied=False,
                        description="CD payment for " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " closing " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s deal. After tax payment of " + Helpers.currency_format(float(self.request.get("post_tax_amount"))) + " was issued on " + str(Helpers.pacific_today()) + " via New Power payroll card",
                        description_key="cd_sp_pay",
                        dollars=dollars1,
                        extra_info="{}",
                        field_app_identifier=self.request.get("identifier"),
                        identifier=Helpers.guid(),
                        paid=False,
                        payout_date=payout_dt,
                        recipient=self.request.get("solar_pro")
                    )
                    if is_instant_payment:
                        t2.dollars = 0
                        t2.cents = 1
                    if not is_instant_payment:
                        t2.description = "CD payment for " + rep.first_name.strip().title() + " " + rep.last_name.strip().title() + " closing " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + "'s deal."
                    else:
                        text_recipient = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
                        if not text_recipient is None:
                            Helpers.send_sms(text_recipient.rep_phone, "New Power just paid you " + Helpers.currency_format(float(self.request.get("post_tax_amount"))) + " for a CD with " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ". Congrats!")

                    docs_to_put = []
                    s_index = search.Index(name="v2_transactions")
                    
                    docs_to_put.append(
                        search.Document(
                            fields=[
                                search.TextField(name="identifier", value=t2.identifier),
                                search.TextField(name="description", value=t2.description)
                            ]
                        )
                    )

                    t2.put()
                    s_index.put(docs_to_put)

                    #COPY/PASTED, change if you want to uncomment. This is CD, not AK.

                    #stat_recipient = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("solar_pro"))
                    #if not stat_recipient is None:
                    #    stat = LeaderBoardStat(
                    #        identifier=Helpers.guid(),
                    #        rep_id=stat_recipient.rep_id,                    
                    #        office_identifier=stat_recipient.main_office,
                    #        field_app_identifier=app_entry.identifier,
                    #        in_bounds=True,
                    #        pin_identifier="-1",
                    #        metric_key="aks_paid",
                    #        dt=Helpers.pacific_now()
                    #    )
                    #    if self.request.get("usage_type") == "real":
                    #        stat.put()
      
        self.response.out.write(json.dumps(ret_json))
            
    elif self.request.get("fn") == "upload_closer_sig":
        from PIL import Image
        from io import BytesIO
        import StringIO

        sig_image = Image.open(BytesIO(self.request.POST.multi["img"].file.read()))
        sig_image.load()

        output = StringIO.StringIO()

        sig_image.save(output, format='JPEG')

        output.seek(0)
        output_s = output.read()

        b64 = base64.b64encode(output_s)

        bytes_stream = BytesIO(base64.b64decode(b64))

        output2 = StringIO.StringIO()
        sig_image.save(output2, format='JPEG')
        output2.seek(0)

        output2_s = output2.read()

        bucket_name = os.environ.get('BUCKET_NAME', app_identity.get_default_gcs_bucket_name())
        bucket = '/' + bucket_name

        write_retry_params = gcs.RetryParams(backoff_factor=1.1)


        filename = bucket + '/Images/RepSignatures/' + self.request.get("identifier") + '.jpg'
        gcs_file = gcs.open(
                    filename,
                    'w',
                    content_type="image/jpeg",
                    options=
                    {
                        'x-goog-meta-foo': 'foo',
                        'x-goog-meta-bar': 'bar',
                        'x-goog-acl': 'public-read',
                        'cache-control': 'no-cache'
                    },
                    retry_params=write_retry_params
        )
        gcs_file.write(output2_s)
        gcs_file.close()

        output.close()
        output2.close()
        bytes_stream.close()

    elif self.request.get("fn") == "thomas_2019_one_time_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/thomas_one_time_2019", params={"month": self.request.get("month")})

    elif self.request.get("fn") == "mail_test":
        msg = "Hello Ray, can we schedule a follow-up appointment sometime next month?"
        Helpers.send_email("rnirnber@gmail.com", "Follow-Up?", msg)

    elif self.request.get("fn") == "grandfather_clock":
        self.response.content_type = "application/json"
        ret = {"grandfathers_response": str(Helpers.pacific_today())}
        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "2020_report_one_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/twenty_twenty_report_one", params={"year": self.request.get("year"), "month": self.request.get("month")})

    elif self.request.get("fn") == "sp_debugging_report":
        self.response.content_type = "text/plain"
        sp_stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.dt >= datetime(2018, 6, 1, 0, 0, 0),
                LeaderBoardStat.dt <= datetime(2018, 6, 30, 23, 59, 59),
                LeaderBoardStat.metric_key == "leads_acquired"
            )
        )

        app_ids_to_query = ["-2"]
        for sp_stat in sp_stats:
            app_ids_to_query.append(sp_stat.field_app_identifier)

        customers = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for customer in customers:
            if not customer.lead_generator == "-1":
                self.response.out.write(customer.lead_generator)
                self.response.out.write("\r\n")

    elif self.request.get("fn") == "pp_sub_details":
        self.response.content_type = "application/json"
        identifiers = json.loads(self.request.get("identifiers"))
        ret = {"results": []}

        identifier_idx_dict = {}
        for identifier in identifiers:
            obj = {"identifier": identifier, "pto_received": "N/A", "install_date": "N/A"}
            identifier_idx_dict[identifier] = len(ret["results"])
            ret["results"].append(obj)

        pp_subs = PerfectPacketSubmission.query(PerfectPacketSubmission.field_application_identifier.IN(identifiers))
        for pp_sub in pp_subs:
            extra_info = json.loads(pp_sub.extra_info)
            idx = identifier_idx_dict[pp_sub.field_application_identifier]
            if "project_management_checkoffs" in extra_info.keys():
                if "install" in extra_info["project_management_checkoffs"].keys():
                    if "date" in extra_info["project_management_checkoffs"]["install"].keys():                        
                        ret["results"][idx]["install_date"] = extra_info["project_management_checkoffs"]["install"]["date"]
                if "received_pto" in extra_info["project_management_checkoffs"].keys():
                    if "date" in extra_info["project_management_checkoffs"]["received_pto"].keys():
                        if extra_info["project_management_checkoffs"]["received_pto"].keys():
                            ret["results"][idx]["pto_received"] = extra_info["project_management_checkoffs"]["received_pto"]["date"]

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "kevin_danas_pins":
        ret = []
        self.response.content_type = "application/json"

        quadrants = RepQuadrant.query(
            ndb.AND(
                RepQuadrant.rep_identifier == "b5784e4cc54ecad51cfb2514cddf7dfac070f5df16cb087be40001658a598c14bd775217c7ceb57e05d3f6de57ec259184836526bace120a529811637822d50e",
                RepQuadrant.active == True
            )
        )
        cnt = 0
        quad_ids_to_query = ["-2"]
        for quadrant in quadrants:
            quad_ids_to_query.append(quadrant.identifier)

        pin_ids = []
        pins = PinPoint.query(PinPoint.quadrant_identifier.IN(quad_ids_to_query))
        for pin in pins:
            obj = {}
            obj["lat"] = str(pin.latitude)
            obj["lng"] = str(pin.longitude)
            ret.append(obj)

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "pull_active_areas_for_rep":
        self.response.content_type = "application/json"
        ret = {"quads": []}
        quads = RepQuadrant.query(
            ndb.AND(
                RepQuadrant.rep_identifier == self.request.get("identifier"),
                RepQuadrant.active == True
            )
        )
        for quad in quads:
            obj = {}
            obj["identifier"] = quad.identifier
            obj["points"] = quad.all_points            
            
            ret["quads"].append(obj)

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "pull_pins_for_nirnberger_quad":
        ret_json = {"pins": []}
        self.response.content_type = "application/json"
        pins = PinPoint.query(PinPoint.quadrant_identifier == self.request.get("identifier"))
        for pin in pins:
            obj = {"identifier": pin.identifier}
            obj["latitude"] = pin.latitude
            obj["longitude"] = pin.longitude            
            ret_json["pins"].append(obj)

        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "complete_nirnberger_special_pin":
        quad = RepQuadrant.first(RepQuadrant.identifier == self.request.get("quad_identifier"))
        if not quad is None:
            pin_array = []

            ts = str(quad.modified).split(".")[0]
            ts = ts.replace(" ", "_")
            filename = "/NirnbergerSpecial/QuadHistory/" + quad.identifier + "__" + ts
            if Helpers.gcs_file_exists(filename):
                f = GCSLockedFile(filename)
                pin_array = json.loads(f.read())
                f.unlock()

            pin_array.append(self.request.get("pin_identifier"))

            f2 = GCSLockedFile(filename)
            f2.write(json.dumps(pin_array), "application/json", "public-read")
            f2.unlock()

    elif self.request.get("fn") == "pull_active_areas_for_nirnberger_rep":
        self.response.content_type = "application/json"
        ret = {"quads": []}
        quads = RepQuadrant.query(
            ndb.AND(
                RepQuadrant.rep_identifier == self.request.get("identifier"),
                RepQuadrant.active == True
            )
        )
        for quad in quads:
            obj = {}
            obj["identifier"] = quad.identifier
            obj["points"] = quad.all_points
            obj["completed"] = []
            ts = str(quad.modified).split(".")[0]
            ts = ts.replace(" ", "_")
            filename = "/NirnbergerSpecial/QuadHistory/" + quad.identifier + "__" + ts
            if Helpers.gcs_file_exists(filename):
                f = GCSLockedFile(filename)
                obj["completed"] = json.loads(f.read())
                f.unlock()
            
            ret["quads"].append(obj)

        self.response.out.write(json.dumps(ret))

#    elif self.request.get("fn") == "save_pin_for_nirnberger_quad":
#        self.response.content_type = "application/json"
#        ret = {"pins": []}
#        pins = PinPoint.query(PinPoint.quadrant_identifier == self.request.get("identifier"))
#        for pin in pins:
#            obj = {"identifier": pin.identifier}
#            obj["latitude"] = pin.latitude
#            obj["longitude"] = pin.longitude
#            ret["pins"].append(obj)
#
#        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "rnirnber_test":
        Helpers.send_email("rnirnber@gmail.com", "Testing Question", "Are you able to test the new field app feature?")

    elif self.request.get("fn") == "system_size_report":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/system_size_report", params={})

    elif self.request.get("fn") == "record_dive_in":
        rep = FieldApplicationUser.first(FieldApplicationUser.identifier == self.request.get("identifier"))
        if not rep is None:
            lb_stat = LeaderBoardStat(
                identifier=Helpers.guid(),
                dt=Helpers.pacific_now(),
                field_app_identifier="-1",
                in_bounds=True,
                metric_key="dive_in",
                rep_id=rep.rep_id,
                pin_identifier="-1",
                office_identifier=rep.main_office
            )
            lb_stat.put()

    elif self.request.get("fn") == "dive_in_suspicion":
        self.response.content_type = "text/plain"
        content = "Dive In Timestamps\r\n\r\n"

        stats = LeaderBoardStat.query(
            ndb.AND(
                LeaderBoardStat.metric_key == "dive_in",
                LeaderBoardStat.rep_id == "ARTE0924"
            )
        )
        data = {"timestamps": []}
        timestamps = []
        for stat in stats:            
            stamp = str(stat.dt).split(".")[0]
            obj = {"dt": stamp}
            data["timestamps"].append(obj)

        timestamps = Helpers.bubble_sort(timestamps, "dt")

        for stamp in timestamps:
            content += str(stamp).split(".")[0]
            content += "\r\n"

        self.response.out.write(content)

    elif self.request.get("fn") == "one_time_job_wed_apr_22_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/apr_22", params={})

    elif self.request.get("fn") == "affirm_roof_work_needed":        
        from google.appengine.api import app_identity
        import time

        app_entry = FieldApplicationEntry.first(FieldApplicationEntry.identifier == self.request.get("identifier"))
        if not app_entry is None:
            rep = FieldApplicationUser.first(FieldApplicationUser.rep_id == app_entry.rep_id)
            if not rep is None:                                                

                data = {"roof_type": self.request.get("work_type")}
                data["solar_area_only_cost"] = self.request.get("solar_area_only_cost")
                data["description"] = self.request.get("description")
                data["rep_selection_one"] = "solar_area_only"
                if not data["roof_type"] == "comp_inset":
                    if self.request.get("skip_reroof_photo") == "0":
                        file_content0 = self.request.POST.multi["reroof_photo"].file.read()
                        f0 = GCSLockedFile("/Images/RoofWorkDetails/" + app_entry.identifier + "/reroof_photo.jpg")
                        f0.write(file_content0, "image/jpeg", "public-read")
                        f0.unlock()

                    data["full_reroof_cost"] = self.request.get("full_reroof_cost")

                data["exclusions"] = self.request.get("extra_roof_question_one")
                data["material_question"] = self.request.get("extra_roof_question_two")

                if self.request.get("skip_proof_photo_1") == "0":
                    file_content1 = self.request.POST.multi['proof_photo_1'].file.read()
                    f1 = GCSLockedFile("/Images/RoofWorkDetails/" + app_entry.identifier + "/proof_photo_1.jpg")
                    f1.write(file_content1, "image/jpeg", "public-read")
                    f1.unlock()

                if self.request.get("skip_proof_photo_2") == "0":
                    file_content2 = self.request.POST.multi['proof_photo_2'].file.read()
                    f2 = GCSLockedFile("/Images/RoofWorkDetails/" + app_entry.identifier + "/proof_photo_2.jpg")
                    f2.write(file_content2, "image/jpeg", "public-read")
                    f2.unlock()

                if self.request.get("skip_solar_area_only_photo") == "0":
                    #solar_area_photo
                    file_content3 = self.request.POST.multi['solar_area_photo'].file.read()
                    f3 = GCSLockedFile("/Images/RoofWorkDetails/" + app_entry.identifier + "/solar_area_photo.jpg")
                    f3.write(file_content3, "image/jpeg", "public-read")
                    f3.unlock()

                existing_roof_items = RoofWorkItem.query(RoofWorkItem.field_app_identifier == app_entry.identifier)
                for existing_roof_item in existing_roof_items:
                    existing_roof_item.key.delete()

                roof_item = RoofWorkItem(
                    identifier=Helpers.guid(),
                    field_app_identifier=app_entry.identifier,
                    rep_identifier=rep.identifier,
                    info=json.dumps(data),
                    dt=Helpers.pacific_now()
                )
                roof_item.put()

                identity = app_identity.get_application_id()
                recipients = []
                if identity == "devnfieldapp":
                    recipients = ["rnirnber@gmail.com"]
                else:
                    recipients = ["thomas@newpower.net", "reimer@newpower.net", rep.rep_email]

                subj = "URGENT: Roof work needed for "
                subj += app_entry.customer_first_name.strip().title()
                subj += " "
                subj += app_entry.customer_last_name.strip().title()
                
                msg = "Please log into the field app, click on Roof Work Needed, and click on the customer name to get details."
                for recipient in recipients:
                    Helpers.send_email(recipient, subj, msg)

                Helpers.send_sms(rep.rep_phone, "Roof work is needed for " + app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title() + ". Please log into the field app and click on Roof Work Needed to see details.")


    elif self.request.get("fn") == "daily_postal_campaign_reports":        
        from google.appengine.api import urlfetch

        items = []
        f1 = GCSLockedFile("/PostalCampaign/texts.json")
        deserialized = json.loads(f1.read())
        f1.unlock()

        phone_rep_mapping = {"6194898681": "Dallin", "6194898676": "Taylor", "6194899203": "Derek", "9513385574": "Duvall", "9513374684": "Adam", "9513385565": "Ryan", "8312735984": "Raymond"}
        phone_rep_mapping2 = {"(435) 868 - 7415": "Taylor", "(951) 404 - 6912": "Dallin", "(858) 414 - 7413": "Duvall", "(951) 729 - 0802": "Adam", "(661) 492 - 5737": "Ryan", "(801) 703 - 0001": "Derek", "(831) 275 - 0754": "Raymond"}

        now = Helpers.pacific_now()
        yesterday = now + timedelta(days=-1)
        yesterday_start = datetime(yesterday.year, yesterday.month, yesterday.day, 0, 0, 0)
        yesterday_end = datetime(yesterday.year, yesterday.month, yesterday.day, 23, 59, 59)

        phone_numbers_called = []
        for item in deserialized:
            date_vals = item["dt"].split(" ")[0].split("-")
            time_vals = item["dt"].split(" ")[1].split(":")

            item_dt = datetime(int(date_vals[0]), int(date_vals[1]), int(date_vals[2]), int(time_vals[0]), int(time_vals[1]))

            if item_dt >= yesterday_start and item_dt <= yesterday_end:
                obj = {"from": Helpers.format_phone_number(item["from"])}
                obj["to"] = phone_rep_mapping[item["to"]]
                obj["timestamp"] = item["dt"]
                obj["method"] = "SMS"

                if not obj["to"] in phone_numbers_called:
                    items.append(obj)
                    phone_numbers_called.append(obj["to"])

        req = urlfetch.fetch(
                url="https://storage.googleapis.com/devopalus.appspot.com/TwilioPostalCampaign/callsv3.json",
                method=urlfetch.GET,
                deadline=30
            )

        texts_sent = []
        deserialized = json.loads(req.content)
        for item in deserialized:
            date_vals = item["dt"].split(" ")[0].split("-")
            time_vals = item["dt"].split(" ")[1].split(":")

            item_dt = datetime(int(date_vals[0]), int(date_vals[1]), int(date_vals[2]), int(time_vals[0]), int(time_vals[1]))

            if item_dt >= yesterday_start and item_dt <= yesterday_end:
                obj = {"from": item["caller"]}
                obj["to"] = phone_rep_mapping2[item["rep"]]
                obj["timestamp"] = item["dt"]
                obj["method"] = "phone"
                
                if not obj["to"] in texts_sent:
                    items.append(obj)
                    texts_sent.append(obj["to"])

        import tablib
        headers = ("To", "From", "Timestamp", "Method")
        csv_data = []

        for item in items:
            csv_data.append((item["to"],
                    item["from"],
                    item["timestamp"],
                    item["method"]))

        structured_data = tablib.Dataset(*csv_data, headers=headers)
        attachment_data = {}
        attachment_data["data"] = []
        attachment_data["content_types"] = []
        attachment_data["filenames"] = []

        attachment_data["data"].append(base64.b64encode(structured_data.csv))
        attachment_data["content_types"].append("text/csv")
        attachment_data["filenames"].append("postal_campaign_communication_from_" + str(yesterday_start.date()).replace("-", "_"))

        subject = "Postal Campaign Data - " + str(yesterday_start.date())
        msg_body = "See Attached..."
        Helpers.send_email("thomas@newpower.net", subject, msg_body, attachment_data)

    elif self.request.get("fn") == "confirm_supplement_details":        
        roof_work_extras_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "confirmed_roof_work_numbers_" + self.request.get("identifier"))
        if not roof_work_extras_kv == None:
            roof_work_extras_kv.key.delete()

        stored_values = {}
        stored_values["fund_one_cost"] = self.request.get("fund_one_cost")
        stored_values["fund_two_cost"] = self.request.get("fund_two_cost")
        stored_values["roof_scope"] = self.request.get("roof_scope")

        new_kv = KeyValueStoreItem(
            identifier=Helpers.guid(),
            keyy="confirmed_roof_work_numbers_" + self.request.get("identifier"),
            val=json.dumps(stored_values),
            expiration=datetime(1970, 1, 1)
        )
        new_kv.put()

    elif self.request.get("fn") == "get_roof_work_for_rep":
        self.response.content_type = "application/json"
        ret = {"items": [], "funds": Helpers.list_funds()}
        items = RoofWorkItem.query(RoofWorkItem.rep_identifier == self.request.get("identifier"))
        field_app_identifier_idx_dict = {}
        app_ids_to_query = ["-2"]
        for item in items:
            obj = {}
            obj["identifier"] = item.identifier
            obj["field_app_identifier"] = item.field_app_identifier
            obj["dt"] = str(item.dt).split(".")[0]

            app_ids_to_query.append(obj["field_app_identifier"])
            field_app_identifier_idx_dict[obj["field_app_identifier"]] = len(ret["items"])
            
            ret["items"].append(obj)

        app_entries = FieldApplicationEntry.query(FieldApplicationEntry.identifier.IN(app_ids_to_query))
        for app_entry in app_entries:
            idx = field_app_identifier_idx_dict[app_entry.identifier]
            ret["items"][idx]["name"] = app_entry.customer_first_name.strip().title() + " " + app_entry.customer_last_name.strip().title()

        self.response.out.write(json.dumps(ret))

    elif self.request.get("fn") == "level_two_lookup":
        self.response.content_type = "application/json"
        ret_json = []

        cnt = 0
        while not cnt == 10:
            obj = {}
            obj["selfie_exists"] = Helpers.gcs_file_exists("/Level22Selfies/" + self.request.get("identifier") + "_" + str(cnt) + ".jpg")
            obj["selfie_timestamp"] = None
            if obj["selfie_exists"]:
                kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_selfie_timestamp_" + str(cnt) + "_" + self.request.get("identifier"))
                if not kv is None:
                    obj["selfie_timestamp"] = kv.val

            obj["hks"] = None
            hk_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_hks_" + str(cnt) + "_" + self.request.get("identifier"))
            if not hk_kv is None:
                obj["hks"] = int(hk_kv.val)

            obj["abs"] = None
            ab_kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_abs_" + str(cnt) + "_" + self.request.get("identifier"))
            if not ab_kv is None:
                obj["abs"] = int(ab_kv.val)

            ret_json.append(obj)
            cnt += 1
        
        self.response.out.write(json.dumps(ret_json))

    elif self.request.get("fn") == "l2_up_selfie":
        f = GCSLockedFile("/Level22Selfies/" + self.request.get("identifier") + "_" + self.request.get("idx") + ".jpg")
        file_content = self.request.POST.multi['img'].file.read()
        f.write(file_content, "image/jpeg", "public-read")
        f.unlock()

        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_selfie_timestamp_" + self.request.get("idx") + "_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="level_two_selfie_timestamp_" + self.request.get("idx") + "_" + self.request.get("identifier"),                
                expiration=Helpers.pacific_now() + timedelta(days=90)
        )
        now = Helpers.pacific_now()
        now_str = str(now)
        now_split = now_str.split(".")[0]
        kv.val=now_split
        kv.put()

    elif self.request.get("fn") == "set_abs_for_level_two":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_abs_" + self.request.get("idx") + "_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="level_two_abs_" + self.request.get("idx") + "_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=90)
            )
        kv.val = self.request.get("tally")
        kv.put()

    elif self.request.get("fn") == "set_hks_for_level_two":
        kv = KeyValueStoreItem.first(KeyValueStoreItem.keyy == "level_two_hks_" + self.request.get("idx") + "_" + self.request.get("identifier"))
        if kv is None:
            kv = KeyValueStoreItem(
                identifier=Helpers.guid(),
                keyy="level_two_hks_" + self.request.get("idx") + "_" + self.request.get("identifier"),
                expiration=Helpers.pacific_now() + timedelta(days=90)
            )
        kv.val = self.request.get("tally")
        kv.put()

    elif self.request.get("fn") == "runway_report_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/runway_report", params={})

    elif self.request.get("fn") == "backfill_3_kickoff":
        from google.appengine.api import taskqueue
        taskqueue.add(url="/tq/backfill3", params={"year": self.request.get("year")})
    else:               
        self.response.out.write("")
